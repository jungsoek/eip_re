# 목차

### 1. **소프트웨어 설계**

#### 1-1. 요구사항 분석

- 요구사항의 개념
- 요구사항 분류 (기능 / 비기능)
- 요구사항 수집 기법 (인터뷰, 설문, 워크숍 등)
- 요구사항 명세 기법 (정형/비정형, Use Case 등)

#### 1-2. 소프트웨어 아키텍처 설계

- 아키텍처 스타일 (MVC, Layered, Pipe & Filter 등)
- 품질 속성 (성능, 확장성, 가용성)
- 설계 원리 (SRP, OCP, DIP 등)
- 디자인 패턴 (GoF 23가지)

#### 1-3. UI/UX 설계

- UI 개념 및 설계 지침
- UX 설계 절차
- UI 프로토타입, 와이어프레임, 스토리보드 작성

#### 1-4. 데이터 설계

- 개체-관계 모델 (ERD)
- 정규화 / 반정규화
- 트랜잭션 설계
- 무결성 제약조건

### 2. **소프트웨어 개발**

#### 2-1. 프로그래밍 언어 기초

- 절차지향 vs 객체지향
- C언어, Java, Python 기본 문법
- 자료형, 연산자, 제어문

#### 2-2. 객체지향 프로그래밍

- 클래스, 객체, 상속, 다형성
- 추상화, 캡슐화
- UML 다이어그램 (클래스, 시퀀스, 상태 등)

#### 2-3. 알고리즘 및 자료구조

- 정렬, 탐색, 분할 정복, 그리디, DP
- 스택, 큐, 연결리스트, 트리, 그래프
- 시간복잡도, 공간복잡도

#### 2-4. 소프트웨어 테스트

- 테스트 레벨 (단위, 통합, 시스템)
- 테스트 기법 (명세 기반, 구조 기반)
- 테스트 자동화 도구

### 3. **데이터베이스 구축**

#### 3-1. 데이터 모델링

- 개념/논리/물리 모델링
- 정규화 단계 (1NF~BCNF)
- 식별자, 관계, 속성, 카디널리티

#### 3-2. SQL

- DDL, DML, DCL, TCL
- SELECT, JOIN, GROUP BY, 서브쿼리
- 인덱스, 뷰, 시퀀스, 트리거, 프로시저

#### 3-3. 트랜잭션 & 동시성 제어

- ACID 특성
- Lock, Deadlock, Isolation Level

#### 3-4. DBMS 구조 및 성능

- 데이터 저장구조 (Tablespace, Segment)
- 인덱스 구조 (B-Tree, Bitmap)
- 분산 DB / 병렬 처리

### 4. **프로그래밍 언어 활용**

#### 4-1. 언어별 활용 (실습)

- Java: 클래스/인터페이스, 예외처리, 입출력, Thread
- Python: 자료구조, 함수, 모듈, Pandas/Numpy 기초
- C: 포인터, 구조체, 파일 입출력

#### 4-2. 라이브러리 활용

- java.util, java.io, java.net
- Python 표준 라이브러리
- 외부 패키지 연동

#### 4-3. 응용 SW API 사용

- Open API 호출
- JSON, XML 파싱
- RESTful 통신 구현

#### 4-4. 웹 프로그래밍 개론

- HTML, CSS, JavaScript
- 클라이언트-서버 모델
- 프론트엔드/백엔드 개념

### 5. **정보시스템 구축관리**

#### 5-1. 프로젝트 관리

- 프로젝트 생명주기
- WBS, CPM, Gantt Chart
- 형상관리 / 변경관리

#### 5-2. 품질보증 및 시험

- ISO/IEC 25010
- 품질 측정 기준
- 결함 추적 및 리포팅

#### 5-3. 소프트웨어 개발 방법론

- 폭포수, 프로토타입, 나선형, 애자일(Scrum, XP)
- DevOps 개념
- 요구사항 추적성

#### 5-4. 운영체제와 네트워크

- OS 구조, 메모리/프로세스 관리
- IP, TCP, HTTP, DNS
- 클라이언트-서버 모델

### A. 알고리즘 코딩

- 문제 해결 패턴 (완전탐색, DFS/BFS, 그리디)
- 문자열 처리, 수학, 시뮬레이션
- 파일 입출력 처리

### B. SQL & DB 설계

- 복잡한 SQL 쿼리 작성
- 조건 처리, JOIN, 윈도우 함수
- 트랜잭션 처리 및 오류 디버깅

### C. 프로그램 구현

- 요구사항 분석 → 클래스 설계 → 기능 구현
- 입력/출력 설계, 예외처리, 로직 구현
- REST API 통신 (GET/POST)

### D. 테스트 및 배포

- 단위 테스트 코드 작성
- 로그 확인 / 예외 처리
- 배포 스크립트 작성 (bash, bat)

# 1. **소프트웨어 설계**

# 1-1. 요구사항 분석

# 요구사항의 개념

## ✅ **요구사항(Requirement)의 개념이란?**

요구사항이란,
 **"소프트웨어가 갖추어야 할 기능, 성능, 제약 조건 등을 사용자 또는 이해관계자가 개발자에게 전달하는 명세 또는 기대 사항"**을 말해.
 쉽게 말하면, 소프트웨어가 **무엇을 해야 하는지, 어떻게 동작해야 하는지에 대한 약속과 기대치**라고 볼 수 있어.

## 📌 **요구사항의 핵심 특징**

| 구분              | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| ✨ 추상성          | 요구사항은 종종 명확하지 않거나, 추상적으로 표현되므로 해석이 중요함 |
| 🔄 변화 가능성     | 프로젝트 진행 중 요구사항은 변경될 수 있음 (요구사항 변경 관리가 필요함) |
| 👥 이해관계자 중심 | 요구사항은 고객, 사용자, 관리자 등 다양한 관점에서 도출됨    |
| 📋 문서화 필요     | 말로만 전달되면 안 되고, 명확한 문서로 관리되어야 함         |

## 📂 **요구사항의 종류 (2가지)**

| 구분                                              | 설명                                      | 예시                                       |
| ------------------------------------------------- | ----------------------------------------- | ------------------------------------------ |
| 🔹 기능적 요구사항 (Functional Requirements)       | 소프트웨어가 제공해야 할 **기능**과 동작  | "사용자는 게시글을 작성할 수 있어야 한다." |
| 🔸 비기능적 요구사항 (Non-functional Requirements) | 품질, 성능, 보안, 신뢰성 등 **제약 조건** | "웹페이지는 2초 이내에 로딩되어야 한다."   |

※ 품질 속성 (비기능 요구사항)에는 다음이 포함됨:

- 성능, 가용성, 확장성, 이식성, 보안성, 유지보수성 등

## 🔍 **요구사항과 관련된 개념 비교**

| 용어                    | 정의                                             | 예시                                        |
| ----------------------- | ------------------------------------------------ | ------------------------------------------- |
| 요구사항(Requirement)   | 사용자/고객이 소프트웨어에 바라는 기능 및 제약   | “로그인이 가능해야 한다”                    |
| 명세(Specification)     | 요구사항을 기술적으로 명확하게 문서화한 것       | "로그인 시 사용자 ID는 8자 이상이어야 한다" |
| 요구사항 분석(Analysis) | 요구사항을 정제하고, 논리적 구조로 이해하는 활동 | Use Case 분석, 흐름도 작성 등               |

## 🛠️ **요구사항이 중요한 이유**

1. **프로젝트 방향을 설정**함 → 시작점
2. 요구사항이 불명확하면 **개발 오류·재작업**이 발생함
3. 프로젝트의 **범위·일정·비용 산정**에 핵심적 근거 제공
4. 요구사항대로 구현되었는지 테스트 기준(Test Case) 제공
5. **클라이언트와의 분쟁 예방**에도 중요한 역할

## 🎯 실무에서의 요구사항 표현 방식

| 표현 도구                       | 설명                                                    |
| ------------------------------- | ------------------------------------------------------- |
| Use Case Diagram                | 사용자와 시스템의 상호작용 시나리오를 도식화            |
| 요구사항 명세서 (SRS)           | Software Requirements Specification. IEEE-830 문서 형식 |
| 사용자 스토리(User Story)       | 애자일 방식에서 “누가 어떤 목적을 위해 무엇을 원하는가” |
| UML (Unified Modeling Language) | 요구사항 분석/설계용 다이어그램 집합                    |

## ⚠️ 요구사항 도출 실패 시 위험

- 프로젝트 범위가 무한정 확장됨 (Scope Creep)
- 개발 완료 후 고객 불만족
- 납기/비용 초과
- 테스트 불가 → 결함 증가

## 🧠 심화 포인트: 요구사항 공학 (Requirements Engineering)

요구사항 공학은 다음 4단계로 구성돼:

1. **도출(Elicitation)**: 이해관계자 인터뷰, 관찰, 워크숍
2. **분석(Analysis)**: 모순, 중복, 누락 등을 찾아 정제
3. **명세(Specification)**: SRS 문서로 구조화
4. **검증(Validation)**: 요구사항이 현실성, 일관성 있는지 확인

## 🧪 예제

> ✅ "온라인 서점 시스템의 요구사항" 예시

- 기능 요구사항:
  - 사용자는 도서를 검색할 수 있어야 한다.
  - 사용자는 장바구니에 도서를 추가할 수 있어야 한다.
- 비기능 요구사항:
  - 검색 결과는 1초 이내에 출력되어야 한다.
  - 웹 서버는 하루 1만 건의 접속을 견뎌야 한다.

# 요구사항 분류 (기능 / 비기능)

## ✅ 요구사항 분류란?

요구사항 분류(Requirements Classification)는 사용자의 요구를 성격에 따라 구분하여 정리하는 과정이야.
 일반적으로 **기능 요구사항(Functional Requirements)**과 **비기능 요구사항(Non-functional Requirements)**으로 구분돼.

## 1️⃣ 기능 요구사항 (Functional Requirements)

### ● 정의

시스템이 **어떤 동작(기능)**을 수행해야 하는지를 명시한 요구사항.
 즉, 사용자가 어떤 행위를 할 수 있는지, 시스템이 어떤 응답을 해야 하는지를 설명해.

### ● 주요 특징

| 항목   | 설명                                        |
| ------ | ------------------------------------------- |
| 목적   | 사용자의 목적을 실현하기 위한 기능 제공     |
| 기반   | 시스템의 핵심 행위 정의                     |
| 측정   | 참/거짓(True/False)으로 구현 여부 확인 가능 |
| 테스트 | 기능 단위 테스트로 검증 가능                |

### ● 예시

| 시스템         | 기능 요구사항 예시                             |
| -------------- | ---------------------------------------------- |
| 쇼핑몰         | 사용자는 상품을 장바구니에 담을 수 있어야 한다 |
| 병원관리시스템 | 의사는 진료기록을 입력할 수 있어야 한다        |
| 은행앱         | 사용자는 계좌 이체를 할 수 있어야 한다         |
| 게시판         | 글 작성, 수정, 삭제, 검색 기능을 제공해야 한다 |

### ● 기능 요구사항의 표현 방식

- 유스케이스 다이어그램
- 플로우차트(순서도)
- 시나리오 기반 기술
- 명세 기반 표 형식(SRS)

## 2️⃣ 비기능 요구사항 (Non-functional Requirements)

### ● 정의

시스템이 **어떻게 작동해야 하는지**, 즉 품질 속성, 제약 조건, 운영 환경 등을 정의하는 요구사항.
 "기능을 어떻게 제공할 것인가"에 집중한다.

### ● 주요 특징

| 항목      | 설명                              |
| --------- | --------------------------------- |
| 목적      | 품질 보장 및 시스템의 사용성 향상 |
| 기준      | 계량적 기준 or 정책적 기준 사용   |
| 예외 처리 | 성능 미달, 보안 취약 시 리스크 큼 |
| 측정      | 수치/정책 기반으로 테스트 가능    |

### ● 주요 비기능 요구사항 분류

| 분류                | 설명                             | 예시                                        |
| ------------------- | -------------------------------- | ------------------------------------------- |
| ⏱ 성능              | 응답 시간, 처리 속도             | "0.5초 이내에 검색 결과를 보여줘야 함"      |
| 🔐 보안              | 인증, 권한, 데이터 보호          | "모든 로그인 요청은 암호화되어야 한다"      |
| 🔁 가용성            | 시스템의 사용 가능성             | "99.9% 연중무휴 가동"                       |
| 🧰 유지보수성        | 오류 수정 및 기능 변경 용이성    | "코드 변경 없이 설정 파일로 기능 전환 가능" |
| 🌐 이식성            | 다양한 OS/환경에서 실행 가능성   | "Windows, macOS, Linux에서 동작"            |
| 📈 확장성            | 기능/사용자 증가에 유연하게 대응 | "사용자 10만 명으로 확장 가능해야 함"       |
| 💬 사용성(Usability) | 사용자 인터페이스 품질           | "비전문가도 5분 내 조작 가능해야 함"        |
| 🧱 제약조건          | 기술, 법률, 하드웨어 제약 등     | "Oracle DB를 사용해야 한다"                 |

## 🔍 기능 vs 비기능 요구사항 비교표

| 항목   | 기능 요구사항                       | 비기능 요구사항                    |
| ------ | ----------------------------------- | ---------------------------------- |
| 정의   | 시스템이 수행해야 할 기능           | 기능의 품질, 조건, 동작 방식       |
| 질문   | “무엇을 해야 하는가?”               | “어떻게 해야 하는가?”              |
| 형태   | 명령, 조건, 시나리오 중심           | 수치, 정책, 제약 중심              |
| 예시   | “회원은 로그인을 할 수 있어야 한다” | “로그인 응답은 1초 이내여야 한다”  |
| 테스트 | 기능 단위 테스트 가능               | 성능 테스트, 보안 검증 등으로 확인 |

## ⚠️ 실무에서 발생하는 실수

| 실수 유형                | 설명                               | 예시                                               |
| ------------------------ | ---------------------------------- | -------------------------------------------------- |
| ❌ 기능으로 오해한 비기능 | 응답 시간 제한을 "기능"이라고 착각 | 성능 조건을 기능 리스트에 포함                     |
| ❌ 비기능 누락            | 품질 속성 없이 기능만 명시         | “검색 기능만 정의, 속도 기준 없음”                 |
| ❌ 제약조건 미고려        | 운영 환경/기술 스택 무시           | “Windows 기반 개발인데 Linux 전용 라이브러리 사용” |

## 📄 실전 예제 (요구사항 명세서 일부)

> ✅ **온라인 쇼핑몰 시스템 요구사항 정리**

### ● 기능 요구사항

- 사용자는 회원 가입을 할 수 있어야 한다.
- 사용자는 상품을 장바구니에 추가할 수 있어야 한다.
- 관리자는 상품을 등록하고 재고를 관리할 수 있어야 한다.

### ● 비기능 요구사항

- 모든 페이지는 2초 이내에 로드되어야 한다.
- 시스템은 하루 1만 명의 동시 접속을 지원해야 한다.
- 결제 모듈은 금융보안원의 기준에 따라 암호화되어야 한다.

## 🧠 심화 포인트: 비기능 요구사항 정량화

> 비기능 요구사항은 수치로 명확하게 표현되어야 검증이 가능함.
>  불분명한 표현은 금물!

| 나쁜 예                      | 좋은 예                                      |
| ---------------------------- | -------------------------------------------- |
| “빠른 속도로 응답해야 한다”  | “모든 응답은 1초 이내여야 한다”              |
| “안정적으로 운영되어야 한다” | “월간 가동률은 99.9% 이상이어야 한다”        |
| “사용하기 쉬워야 한다”       | “초보자가 5분 내 기능을 익힐 수 있어야 한다” |

# 요구사항 수집 기법 (인터뷰, 설문, 워크숍 등)

## ✅ 요구사항 수집(Elicitation)의 개념

요구사항 수집(Elicitation)은
 **사용자, 이해관계자, 시스템 등으로부터 요구사항을 찾아내고 문서화하는 초기 과정**이야.

이 단계는 단순히 말로 듣는 것이 아니라, **관찰·대화·문서 분석·시뮬레이션** 등 다양한 방법을 통해 이루어져.

## 📂 주요 요구사항 수집 기법 정리

| 기법                                   | 설명                               | 장점                               | 단점                           | 사용 예                        |
| -------------------------------------- | ---------------------------------- | ---------------------------------- | ------------------------------ | ------------------------------ |
| **1. 인터뷰 (Interview)**              | 이해관계자와 일대일 또는 그룹 대화 | 직접 질문 가능, 신속한 피드백      | 주관성, 시간 소모              | 핵심 사용자나 전문가 대상      |
| **2. 설문조사 (Questionnaire)**        | 다수 대상에게 동일한 질문 배포     | 넓은 범위, 정량적 데이터 확보      | 질문 해석 오류 가능            | 다수 사용자 의견 수렴          |
| **3. 워크숍 (Workshop)**               | 다양한 이해관계자가 모여 공동 논의 | 신속한 의사결정, 갈등 조율 가능    | 조율 난이도 높음               | 프로젝트 착수 전 회의          |
| **4. 브레인스토밍 (Brainstorming)**    | 자유로운 아이디어 도출 회의        | 창의적 발상 유도                   | 품질 낮은 아이디어 다수 가능성 | 신기능 또는 혁신 아이디어 도출 |
| **5. 관찰 (Observation)**              | 사용자의 작업 수행을 실제로 관찰   | 실제 환경 기반, 무의식적 습관 파악 | 비효율적일 수 있음             | 현업 시스템 분석 시            |
| **6. 문서 분석 (Document Analysis)**   | 기존 시스템 문서/보고서 등 분석    | 빠른 초기 정보 획득                | 오래된 정보일 수 있음          | 레거시 시스템 참조             |
| **7. 프로토타이핑 (Prototyping)**      | 초기 샘플 시스템을 보여주고 피드백 | 빠른 피드백, 요구 구체화 가능      | 초기 오해 발생 가능            | UI/UX 설계 시 자주 사용        |
| **8. 시나리오 기법 (Scenario)**        | 사용자 작업 흐름 시나리오 제시     | 직관적 이해 도움                   | 시나리오 누락 시 한계          | 프로세스 중심 설계             |
| **9. Focus Group**                     | 비슷한 역할의 사용자 그룹 토의     | 유사 그룹 의견 수렴                | 중립 유지 어려움               | 사용자 경험 평가               |
| **10. Joint Application Design (JAD)** | 사용자 + 개발자 + 기획자 합동 설계 | 전사적 관점 반영                   | 비용·시간 소모 많음            | 복잡한 기업 시스템 분석        |

## 🔍 기법별 상세 설명

### 1. **인터뷰**

- **형식**: 구조화 / 반구조화 / 자유형
- **질문 유형**: 개방형(Open-ended), 폐쇄형(Closed-ended)
- **주의점**: 질문 목적 명확화, 중복 질문 피하기

### 2. **설문조사**

- **형식**: Google Form, MS Forms 등
- **질문 유형**: 객관식, 주관식, 리커트 척도
- **분석 방법**: 빈도분석, 통계 분석, 키워드 분류

### 3. **워크숍**

- 다양한 의견을 동시에 조율하여 정제
- 갈등 중재, 우선순위 설정에 매우 효과적
- **보통 요구사항 도출 후 명세 직전 단계에 사용**

### 4. **관찰**

- **현장관찰(Field Study)**: 실제 환경에서 사용자가 시스템을 어떻게 사용하는지 관찰
- **참여관찰 vs 비참여관찰**: 직접 참여 여부에 따른 구분

### 5. **프로토타이핑**

- **Low-fidelity**: 스케치, 와이어프레임
- **High-fidelity**: 실제 기능 일부 구현
- 피드백 기반 요구사항 명확화에 탁월

## 🧠 수집 기법 선택 기준

| 기준            | 설명                                                |
| --------------- | --------------------------------------------------- |
| 이해관계자 수   | 다수일 경우 설문, 소수일 경우 인터뷰 적합           |
| 시간/비용       | 시간 부족 시 문서분석, 비용 여유 있으면 워크숍 활용 |
| 요구사항 명확성 | 모호할 경우 프로토타이핑, 시나리오 기법 활용        |
| 시스템 복잡도   | 복잡한 시스템은 JAD, 워크숍 등 종합 접근이 유리     |

## 🎯 실무 예시

> “**대형 병원 전자차트 시스템 구축**” 요구사항 수집

| 기법       | 목적                                     |
| ---------- | ---------------------------------------- |
| 인터뷰     | 의사/간호사별 진료 흐름 파악             |
| 관찰       | 외래접수 → 진료 → 처방의 실제 흐름 분석  |
| 설문       | 환자 대상, 예약 시스템 만족도 조사       |
| 문서 분석  | 기존 EMR 시스템의 기능 목록 파악         |
| 프로토타입 | 새로운 모바일 차트 시스템 UI 설계 피드백 |

## ⚠️ 요구사항 수집 시 주의사항

| 항목                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| 중복 피하기          | 유사한 요구를 여러 번 수집하여 비용 증가 가능                |
| 모호한 표현 제거     | “빠르게”, “편리하게” 등의 추상어는 금물                      |
| 이해관계자 무시 금지 | 관리자, 사용자, 개발자 등 다양한 관점 고려 필수              |
| 기록 필수            | 음성 녹음, 회의록, 요약본은 반드시 작성하여 추적 가능성 확보 |

# 요구사항 명세 기법 (정형/비정형, Use Case 등)

## ✅ 요구사항 명세란?

> 요구사항 명세(Requirements Specification)는
>  “수집된 요구사항을 **정형화된 문서나 다이어그램으로 구조화**하여, 개발·테스트·검증이 가능하도록 작성하는 과정”이야.

이 단계는 추상적 요구를 **구체적이고, 일관성 있게, 명확히 표현**하는 데 초점이 있어.

## 📂 요구사항 명세의 주요 목표

| 목적          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| 📘 명확성      | 누구나 이해할 수 있게 작성 (개발자, 테스터, 관리자 모두)     |
| 🧩 일관성      | 중복·모순 없는 요구사항 정리                                 |
| 📏 검증 가능성 | 테스트 케이스 생성이 가능해야 함                             |
| 🔁 추적 가능성 | 각 요구사항이 어디서 유래했고, 어떻게 구현되었는지 추적 가능 |

## 🧱 요구사항 명세 기법 분류

크게 두 가지 방식으로 나뉘어:

| 구분                          | 설명                       | 대표 예                        |
| ----------------------------- | -------------------------- | ------------------------------ |
| **비정형 명세 (Informal)**    | 자연어 중심의 기술 방식    | 요구사항 명세서, 사용자 스토리 |
| **정형 명세 (Formal)**        | 수학적, 논리적 표현식 사용 | Z 언어, B 방법, Petri-Net      |
| **반정형 명세 (Semi-formal)** | 구조화된 언어와 다이어그램 | Use Case, ERD, UML 등          |

## 1️⃣ 비정형 명세 (자연어 중심)

### ● 정의

자연어(한국어/영어 등)로 작성된 설명 위주의 문서.
 일반적으로 사용하는 **요구사항 명세서(SRS)**가 이에 해당해.

### ● 예시

> “사용자는 아이디와 비밀번호를 입력하여 로그인할 수 있어야 한다.”

### ● 장점

- 누구나 쉽게 이해 가능
- 초기 의사소통에 용이

### ● 단점

- 중의적 표현 발생 가능 (예: “빠르게”는 얼마만큼?)
- 일관성 관리 어려움

## 2️⃣ 반정형 명세 (Use Case, UML 등)

### ● 정의

구조화된 언어와 도식 표현으로 기술하는 방식.
 **정확성과 명확성을 동시에 잡으려는 절충안**으로 널리 쓰여.

### ● 대표 기법

#### 📌 Use Case (유스케이스)

| 구성 요소          | 설명                                                   |
| ------------------ | ------------------------------------------------------ |
| Actor              | 시스템과 상호작용하는 외부 사용자 또는 시스템          |
| Use Case           | Actor가 수행할 수 있는 기능 단위                       |
| System Boundary    | 시스템의 경계                                          |
| 관계(Relationship) | 포함(Include), 확장(Extend), 일반화(Generalization) 등 |

> 예:
>
> - 유스케이스: “상품 주문”
> - 액터: “고객”, “관리자”
> - 시나리오: 고객이 상품을 장바구니에 담고, 결제 정보를 입력하여 주문을 완료한다.

#### 📌 UML 다이어그램

| 다이어그램 종류   | 설명                         |
| ----------------- | ---------------------------- |
| 클래스 다이어그램 | 객체 간 관계와 속성 표현     |
| 시퀀스 다이어그램 | 시간에 따른 메시지 흐름 표현 |
| 상태 다이어그램   | 객체의 상태 전이 표현        |
| 활동 다이어그램   | 작업 흐름을 절차적으로 표현  |

#### 📌 시나리오 명세

- 정형화된 템플릿으로 작성
- 시나리오 ID, 입력 조건, 정상/예외 흐름 등

## 3️⃣ 정형 명세 (수학 기반)

### ● 정의

수학적·논리적 언어를 사용하여 **정확하고 기계적으로 검증 가능한 명세**를 작성하는 방식이야.

### ● 대표 기법

| 기법      | 설명                                | 사용 예                      |
| --------- | ----------------------------------- | ---------------------------- |
| Z 언어    | 집합론과 1차 논리 기반의 명세 언어  | 안전-critical 시스템         |
| B 방법    | 수학적 모델로 상태 기반 시스템 명세 | 철도, 항공 제어 시스템       |
| Petri-Net | 상태 변화 모델링                    | 동시성 시스템, 통신 프로토콜 |
| VDM       | 형식적 모델링 방법                  | 임베디드 시스템 명세         |

### ● 장점

- 엄격한 명세 가능
- 오류 사전 제거
- 자동 분석 및 정형 검증 가능

### ● 단점

- 수학적 지식 요구
- 개발팀의 거부감 존재
- 생산성 낮음 (현장에서는 잘 안 씀)

## 📄 SRS (Software Requirements Specification) 명세서 구성 예시

> IEEE 830 표준 기반

| 항목               | 설명                                  |
| ------------------ | ------------------------------------- |
| 1. 소개            | 문서 목적, 범위, 용어 정의            |
| 2. 전체 설명       | 제품의 개요, 사용자 특성, 제한사항 등 |
| 3. 시스템 기능     | 기능 목록 및 설명                     |
| 4. 비기능 요구사항 | 성능, 보안, 가용성 등                 |
| 5. 인터페이스      | 외부 시스템, UI, 하드웨어 인터페이스  |
| 6. 제약 조건       | 개발 언어, DBMS, 운영환경 등          |
| 7. 부록            | 용어사전, 참조문헌 등                 |

## 🔍 Use Case 작성 예시

```
[Use Case: 주문 생성]

목표: 고객이 상품을 주문한다

Actors: 고객

전제 조건: 고객은 로그인한 상태여야 함

기본 흐름:
1. 고객은 상품을 장바구니에 추가한다
2. 주문서를 확인하고 결제 버튼을 누른다
3. 시스템은 주문을 생성하고 주문번호를 반환한다

예외 흐름:
3a. 결제 실패 시, 오류 메시지를 반환한다
```

## ⚠️ 요구사항 명세 시 주의사항

| 항목          | 잘못된 예                                 | 바람직한 예                                 |
| ------------- | ----------------------------------------- | ------------------------------------------- |
| 중의성 제거   | “빠르게 동작해야 함”                      | “모든 요청은 1초 이내에 처리되어야 함”      |
| 일관성 유지   | 로그인 화면과 회원가입 화면에 용어 불일치 | 용어 사전 정의 후 동일 용어 사용            |
| 추적 가능성   | 요구사항 번호 없음                        | 각 요구사항에 ID 부여 (REQ-001, REQ-002 등) |
| 테스트 가능성 | “사용자가 만족할만한 UI 제공”             | “비전문가가 5분 내 주요 기능 탐색 가능”     |

## ✅ 요약 정리

| 분류   | 예시          | 특징                          |
| ------ | ------------- | ----------------------------- |
| 비정형 | 자연어 명세서 | 작성 쉬움, 모호성 있음        |
| 반정형 | Use Case, UML | 구조화 용이, 가장 일반적      |
| 정형   | Z, B 방법     | 명확성 최고, 실무 활용도 낮음 |

# 1-2. 소프트웨어 아키텍처 설계

## 아키텍처 스타일 (MVC, Layered, Pipe & Filter 등)

## ✅ 아키텍처 스타일(Architecture Style)이란?

> 아키텍처 스타일은 소프트웨어 시스템의 **기능적 컴포넌트들과 이들 사이의 관계를 정의하는 패턴 또는 청사진**이야.

- **무엇을 어떤 역할로 분리할 것인가**
- **각 컴포넌트가 어떤 방식으로 데이터를 주고받을 것인가**
- **어디에 책임을 둘 것인가** 등을 결정해주는 설계 방식이자 사고 틀이야.

## 📂 대표 아키텍처 스타일 종류 정리

| 스타일                               | 구조                  | 특징                           | 적용 예시            |
| ------------------------------------ | --------------------- | ------------------------------ | -------------------- |
| **1. 계층형(Layered)**               | 수직 분할             | 책임 분리, 계층 간 데이터 흐름 | 웹 애플리케이션      |
| **2. MVC**                           | 모델-뷰-컨트롤러 분리 | UI/비즈니스 로직 분리          | Spring, Android      |
| **3. 파이프 앤 필터(Pipe & Filter)** | 연속적 처리 체인      | 필터 간 데이터 흐름            | 컴파일러, 영상 처리  |
| **4. 이벤트 기반(Event-Driven)**     | 이벤트 ↔ 리스너       | 비동기 처리, 확장성 우수       | Node.js, IoT         |
| **5. 클라이언트-서버**               | 요청 ↔ 응답           | 역할 분리, 네트워크 기반       | 웹 브라우저 & 웹서버 |
| **6. 마이크로커널**                  | 핵심 기능 + 플러그인  | 경량 코어 + 확장               | Eclipse, VSCode      |
| **7. 마이크로서비스**                | 독립 서비스들         | 독립 배포, 고가용성            | Netflix, Amazon      |
| **8. 서비스 지향(SOA)**              | 서비스 조합           | 비즈니스 프로세스 중심         | 엔터프라이즈 통합    |

## 1️⃣ **계층형 아키텍처 (Layered Architecture)**

### ● 구조

```
[Presentation Layer]
      ↓
[Business Logic Layer]
      ↓
[Persistence Layer]
      ↓
[Database]
```

### ● 설명

- 기능을 계층으로 나누어 각 계층이 상하위 계층과만 소통
- 책임과 관심사를 명확히 분리 (Separation of Concerns)

### ● 장점

- 유지보수성 높음
- 테스트 용이 (단위 계층만 테스트 가능)
- 책임 분리가 직관적

### ● 단점

- 수직 구조로 인해 성능 저하 가능 (많은 계층 통과)
- 상위 계층 변경 시 하위 계층 영향 가능성

## 2️⃣ **MVC 아키텍처 (Model-View-Controller)**

### ● 구조

```
[View] ↔ [Controller] ↔ [Model]
```

| 컴포넌트   | 역할                       |
| ---------- | -------------------------- |
| Model      | 비즈니스 로직, 데이터 처리 |
| View       | 사용자 인터페이스(UI)      |
| Controller | 입력 제어, 흐름 제어       |

### ● 장점

- 로직과 UI 분리 → 유지보수 편리
- 테스트 및 병렬 개발에 유리
- 스프링, 장고 등 많은 프레임워크에서 채택

### ● 단점

- 작은 프로젝트에선 과도한 구조
- View-Model 간 복잡한 데이터 연동 필요

## 3️⃣ **파이프 앤 필터 아키텍처 (Pipe and Filter)**

### ● 구조

```
[Input] → [Filter1] → [Filter2] → [Filter3] → [Output]
```

### ● 설명

- 데이터를 처리 단계별로 Filter라는 독립 모듈에 전달
- 각 필터는 순차적으로 데이터를 가공하여 다음 필터에 전달

### ● 장점

- 모듈 독립성, 재사용성 높음
- 병렬 처리 가능

### ● 단점

- 실시간 상호작용 시스템에 부적합
- 에러 추적 어려움

### ● 적용 예시

- Unix Shell 명령어 파이프: `cat file.txt | grep "hello" | sort`
- 영상 필터링, 스트림 처리

## 4️⃣ **이벤트 기반 아키텍처 (Event-Driven Architecture)**

### ● 구조

```
[Event Generator] → [Event Queue] → [Event Listener]
```

### ● 설명

- 이벤트가 발생하면 이를 감지하여 대응하는 리스너(Listener)가 동작
- 구성 요소들은 느슨하게 결합되어 있음

### ● 장점

- 비동기, 실시간 처리에 강함
- 확장성, 유연성 탁월

### ● 단점

- 이벤트 흐름 추적 어려움
- 디버깅, 오류 처리 복잡

### ● 예시

- JavaScript 이벤트 리스너
- Kafka, RabbitMQ 기반 시스템
- IoT, 게임엔진

## 5️⃣ **클라이언트-서버 아키텍처**

### ● 구조

```
[Client] ⇄ [Server]
```

### ● 설명

- 요청(Request)과 응답(Response) 기반
- 역할이 명확히 분리되어 있음

### ● 장점

- 보안·관리 용이
- 서버 집중 처리로 자원 최적화 가능

### ● 단점

- 서버 과부하 시 전체 서비스 장애 위험
- 클라이언트 수 증가 시 성능 저하

## 6️⃣ **마이크로커널 아키텍처 (Microkernel Architecture)**

### ● 구조

```
[Core System] + [Plugin1] + [Plugin2] ...
```

### ● 설명

- 핵심 기능(Core)은 작고 안정적으로 유지
- 확장 기능은 플러그인 형태로 추가

### ● 장점

- 경량화, 모듈성 우수
- 기능 확장 용이

### ● 단점

- 플러그인 간 의존성 주의
- 초기 설계 난이도 높음

### ● 예시

- Eclipse, IntelliJ IDEA, 웹 브라우저 확장 시스템

## 7️⃣ **마이크로서비스 아키텍처 (Microservices Architecture)**

### ● 구조

```
[Service A]   [Service B]   [Service C]
   ↓              ↓              ↓
[REST API]     [DB1]         [DB2]
```

### ● 설명

- 서비스 단위로 시스템 분할, 각각 독립 배포·스케일링 가능
- 각 서비스는 고유 DB, API, 배포 주기를 가짐

### ● 장점

- 장애 격리, 확장성 우수
- 팀별 독립 개발 가능

### ● 단점

- 분산 시스템의 복잡성
- 통합 테스트 및 배포 복잡

### ● 예시

- Netflix, Amazon, 쿠팡, 카카오페이

## 🧠 정리 비교표

| 항목            | 설명                 | 대표 활용             |
| --------------- | -------------------- | --------------------- |
| 계층형          | 책임 분리, 수직 구조 | 전통적 웹 시스템      |
| MVC             | UI/로직 분리         | 스프링, 안드로이드    |
| Pipe & Filter   | 순차 처리            | 컴파일러, 미디어      |
| 이벤트 기반     | 비동기, 느슨한 결합  | Node.js, Kafka        |
| 클라이언트-서버 | 역할 분리            | 모든 웹 구조          |
| 마이크로커널    | 핵심 + 플러그인      | IDE, OS               |
| 마이크로서비스  | 독립 서비스          | 클라우드, 대형 서비스 |

## 품질 속성 (성능, 확장성, 가용성)

## ✅ 품질 속성(Quality Attributes)이란?

> 품질 속성은 소프트웨어 시스템이 **비기능적으로 가져야 할 성능, 구조, 동작 특성에 대한 요구사항**을 의미해.

기능 요구사항이 “**무엇을 할 것인가**”를 다룬다면,
 품질 속성은 “**어떻게 잘 할 것인가**”를 정의하는 거야.

## 🧩 대표적인 품질 속성 9가지 (기초 핵심)

| 분류        | 품질 속성           | 설명                                           |
| ----------- | ------------------- | ---------------------------------------------- |
| 성능        | **Performance**     | 시스템이 얼마나 빠르게 응답하고 처리하는가     |
| 확장성      | **Scalability**     | 부하 증가 시 얼마나 효율적으로 확장 가능한가   |
| 가용성      | **Availability**    | 시스템이 얼마나 자주, 지속적으로 동작 가능한가 |
| 신뢰성      | **Reliability**     | 시스템이 얼마나 오류 없이 정확하게 동작하는가  |
| 유지보수성  | **Maintainability** | 변경·수정·업그레이드가 얼마나 쉬운가           |
| 이식성      | **Portability**     | 다양한 환경에서도 얼마나 잘 작동하는가         |
| 보안성      | **Security**        | 시스템과 데이터가 얼마나 안전하게 보호되는가   |
| 사용성      | **Usability**       | 사용자가 얼마나 쉽게 학습하고 사용할 수 있는가 |
| 시험 가능성 | **Testability**     | 테스트가 얼마나 용이하고 자동화 가능한가       |

## 1️⃣ **성능 (Performance)**

### ● 정의

시스템이 **주어진 시간 안에 사용자 요청을 얼마나 빠르게 처리할 수 있는가**를 의미해.

### ● 주요 지표

- **응답 시간 (Response Time)**: 요청 후 응답까지 걸리는 시간
- **처리량 (Throughput)**: 단위 시간당 처리 가능한 트랜잭션 수
- **동시 사용자 수 (Concurrency)**: 동시에 처리 가능한 사용자 수
- **자원 사용률 (CPU, Memory)**

### ● 설계 고려 사항

- 캐싱 (Redis 등)
- 로드 밸런싱
- DB 튜닝 (인덱스, 쿼리 최적화)
- 비동기 처리, CDN 활용

### ● 예시

- "웹 페이지는 1초 이내에 로딩되어야 한다"
- "초당 1000건의 요청을 처리해야 한다"

## 2️⃣ **확장성 (Scalability)**

### ● 정의

시스템이 **사용자 증가, 데이터 증가, 트래픽 증가**에 따라 **유연하게 확장**될 수 있는 능력

### ● 종류

| 확장 방식                | 설명             | 예시                 |
| ------------------------ | ---------------- | -------------------- |
| **수직 확장(Scale-Up)**  | CPU, RAM 증가    | 서버 성능 업그레이드 |
| **수평 확장(Scale-Out)** | 인스턴스 수 증가 | 여러 서버로 분산     |

### ● 설계 고려

- Stateless 설계 (세션 외부 저장)
- 마이크로서비스 구조
- 분산 캐시, DB 샤딩

### ● 예시

- "동시 접속자 수 1만 명까지 문제 없이 처리 가능"
- "서버 1대 → 10대로 무중단 확장 가능"

## 3️⃣ **가용성 (Availability)**

### ● 정의

시스템이 **얼마나 오랜 시간 정상적으로 동작할 수 있는가**, 즉 **서비스 중단 없이 얼마나 운영 가능한가**를 말해.

### ● 수식

> 가용성 (%) = (정상 운영 시간 / 전체 시간) × 100
>  예: 99.9% 가용성 = 1년 중 약 8.76시간 다운 가능

### ● 설계 고려

- 장애 복구(Failover), 이중화(Redundancy)
- 무중단 배포(Blue-Green, Canary)
- Auto Healing, 모니터링 시스템

### ● 예시

- "서비스는 연간 99.99% 가용성을 유지해야 한다"
- "장애 발생 시 30초 이내 자동 복구되어야 한다"

## 🧠 성능 vs 확장성 vs 가용성 비교

| 속성   | 질문                          | 측정 지표           | 전략                      |
| ------ | ----------------------------- | ------------------- | ------------------------- |
| 성능   | 얼마나 빠른가?                | 응답시간, 처리량    | 캐시, 병렬처리            |
| 확장성 | 얼마나 많이 처리할 수 있는가? | 서버 수, TPS 증가율 | 수평 확장, 마이크로서비스 |
| 가용성 | 얼마나 자주 멈추지 않는가?    | 다운타임 시간       | 이중화, 자동복구          |

## 📌 품질 속성은 서로 상충할 수 있다

- **성능** 향상을 위해 캐시를 사용하면 → **정합성** 저하
- **가용성**을 위해 이중화하면 → **비용** 증가
- **보안 강화**를 위해 복잡한 인증 도입 → **사용성** 저하

→ 그래서 설계 초기 단계에서 **우선순위(Trade-off)**를 정해야 해.

## 🛠️ 실제 품질 속성 기반 설계 예시

> ✅ 예: 대규모 온라인 쇼핑몰 서버

| 품질 속성  | 적용 설계                          |
| ---------- | ---------------------------------- |
| 성능       | CloudFront CDN + Redis 캐시        |
| 확장성     | Kubernetes 기반 오토스케일링       |
| 가용성     | 이중화된 DB + Active-Passive LB    |
| 보안       | JWT 인증, SSL, 방화벽              |
| 유지보수성 | CI/CD 파이프라인, 로그 모니터링    |
| 시험가능성 | JUnit, Selenium 자동 테스트 시스템 |

## 📄 요구사항 문서에 표현하는 방법

> 잘못된 예:
>  “빠르게 작동해야 함” → ❌
>  “이용자 로그인 요청은 95% 이상 1초 이내 처리되어야 함” → ✅

> 잘못된 예:
>  “확장 가능해야 함” → ❌
>  “사용자 수 5배 증가 시 성능 저하 10% 이내” → ✅

## 설계 원리 (SRP, OCP, DIP 등)

## ✅ 설계 원리(Design Principles)란?

> 소프트웨어 시스템을 **유지보수성 높고, 유연하며, 확장 가능하게 만드는 설계 지침**이야.
>  특히 객체지향 설계에서는 SOLID 원칙이 **가장 기초이자 궁극의 원칙**으로 간주돼.

## 🔠 SOLID 원칙이란?

SOLID는 5가지 객체지향 설계 원칙의 머릿글자를 따서 만든 약어야:

| 약어 | 원칙 이름                  | 핵심 개념                                                    |
| ---- | -------------------------- | ------------------------------------------------------------ |
| S    | SRP - 단일 책임 원칙       | 하나의 클래스는 하나의 책임만 가져야 함                      |
| O    | OCP - 개방 폐쇄 원칙       | 확장엔 열려 있고 변경엔 닫혀 있어야 함                       |
| L    | LSP - 리스코프 치환 원칙   | 자식 클래스는 부모 클래스의 대체가 가능해야 함               |
| I    | ISP - 인터페이스 분리 원칙 | 인터페이스는 사용하지 않는 기능을 포함하지 말아야 함         |
| D    | DIP - 의존 역전 원칙       | 고수준 모듈은 저수준 모듈에 의존하지 말고 추상에 의존해야 함 |

## 1️⃣ **SRP (Single Responsibility Principle) — 단일 책임 원칙**

### ● 정의

> 클래스는 **단 하나의 책임**만 가져야 한다.
>  즉, 변경 이유가 하나뿐이어야 한다.

### ● WHY?

- 하나의 클래스에 여러 책임이 있으면, **변경 시 충돌 위험**이 있음
- 책임을 분리하면 **테스트, 유지보수, 변경**이 쉬워짐

### ● 예시

```java
// ❌ 잘못된 설계 (두 가지 책임: 계산 + 출력)
class Report {
    public String generateReport() { ... }
    public void printReport() { ... }
}

// ✅ 좋은 설계
class ReportGenerator {
    public String generateReport() { ... }
}

class ReportPrinter {
    public void print(String report) { ... }
}
```

## 2️⃣ **OCP (Open-Closed Principle) — 개방-폐쇄 원칙**

### ● 정의

> 소프트웨어 요소는 **확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.**

즉, 기존 코드를 **수정하지 않고도** 새로운 기능을 추가할 수 있어야 한다.

### ● WHY?

- 요구사항 변경이 발생해도 기존 코드를 건드리지 않음 → 안정성↑

### ● 적용 기술

- 다형성 (추상 클래스, 인터페이스)
- 전략 패턴, 템플릿 메서드 패턴

### ● 예시

```java
interface DiscountPolicy {
    int discount(int price);
}

class FixDiscount implements DiscountPolicy {
    public int discount(int price) { return 1000; }
}

class RateDiscount implements DiscountPolicy {
    public int discount(int price) { return price * 10 / 100; }
}

// 서비스 클래스는 DiscountPolicy 인터페이스만 의존
class OrderService {
    private DiscountPolicy discountPolicy;

    public OrderService(DiscountPolicy discountPolicy) {
        this.discountPolicy = discountPolicy;
    }

    public int finalPrice(int price) {
        return price - discountPolicy.discount(price);
    }
}

```

## 3️⃣ **LSP (Liskov Substitution Principle) — 리스코프 치환 원칙**

### ● 정의

> **하위 타입은 상위 타입을 대체할 수 있어야 한다.**
>  즉, 부모 객체를 사용하는 코드는 자식 객체로 교체해도 문제없이 작동해야 한다.

### ● WHY?

- 다형성을 제대로 활용하기 위해 반드시 지켜야 할 원칙

### ● 잘못된 예 (위반 사례)

```java
class Bird {
    public void fly() { ... }
}

class Ostrich extends Bird {
    public void fly() { throw new UnsupportedOperationException(); }
}

```

→ `Ostrich`는 `Bird`지만 날 수 없어!
→ `Bird`를 사용하는 코드에서 `fly()` 호출 시 오류 발생 → LSP 위반

## 4️⃣ **ISP (Interface Segregation Principle) — 인터페이스 분리 원칙**

### ● 정의

> **하나의 일반적인 인터페이스보다, 여러 개의 구체적인 인터페이스를 분리하라.**

클라이언트는 **자신이 사용하지 않는 메서드에 의존하지 않아야 한다.**

### ● WHY?

- 불필요한 메서드 구현 강요 방지
- 인터페이스가 작을수록 구현이 유연해짐

### ● 잘못된 예

```java
interface Printer {
    void print();
    void scan();     // ❌ 단순 프린터는 스캔 못함
    void fax();
}

class SimplePrinter implements Printer {
    void print() { ... }
    void scan() { throw new UnsupportedOperationException(); }
    void fax()  { throw new UnsupportedOperationException(); }
}

```

### ● 개선된 예

```java
interface Printable {
    void print();
}

interface Scannable {
    void scan();
}

interface Faxable {
    void fax();
}

```

## 5️⃣ **DIP (Dependency Inversion Principle) — 의존 역전 원칙**

### ● 정의

> 고수준 모듈은 저수준 모듈에 의존하면 안 된다.
>  **둘 다 추상(인터페이스, 추상 클래스)에 의존**해야 한다.

### ● WHY?

- 구현체가 바뀌어도 고수준 모듈은 변경되지 않음
- 테스트, 확장, 유지보수 유리

### ● 적용 기술

- 의존성 주입(Dependency Injection)
- IoC 컨테이너(Spring 등)

### ● 예시

```java
// 추상화된 인터페이스
interface MessageSender {
    void send(String message);
}

// 구현체
class EmailSender implements MessageSender {
    public void send(String message) {
        System.out.println("Email: " + message);
    }
}

// 고수준 클래스는 인터페이스에만 의존
class Notification {
    private MessageSender sender;

    public Notification(MessageSender sender) {
        this.sender = sender;
    }

    public void notify(String msg) {
        sender.send(msg);
    }
}

```

## 🧠 SOLID 원칙 요약 비교

| 원칙 | 핵심 개념             | 효과               |
| ---- | --------------------- | ------------------ |
| SRP  | 책임 하나만 가져라    | 변경 이유 최소화   |
| OCP  | 확장 가능, 수정 금지  | 유연한 기능 추가   |
| LSP  | 부모 자리에 자식 가능 | 다형성 안정성 확보 |
| ISP  | 인터페이스 쪼개기     | 강한 결합 방지     |
| DIP  | 추상에 의존하라       | 모듈 독립성 확보   |

## 📌 SOLID 원칙은 같이 쓰일수록 효과가 커진다!

- SRP와 OCP는 함께 사용되면 유지보수성과 확장성이 대폭 향상됨
- DIP는 DI 컨테이너(Spring Framework)와 같이 쓰면 극대화됨
- LSP와 OCP는 다형성 설계의 핵심 기반

# 디자인 패턴 (GoF 23가지)

## ✅ 디자인 패턴이란?

> **반복적으로 발생하는 소프트웨어 설계 문제를 해결하기 위해 검증된 설계 구조를 일반화한 것**
>  즉, 좋은 설계 사례를 **이름 붙이고 재사용할 수 있도록 만든 일종의 설계 템플릿**이야.

## 📂 GoF 디자인 패턴 23가지 분류표

| 분류                 | 목적                  | 패턴 이름                                                    |
| -------------------- | --------------------- | ------------------------------------------------------------ |
| **생성(Creational)** | 객체 생성 방법 추상화 | Singleton, Factory Method, Abstract Factory, Builder, Prototype |
| **구조(Structural)** | 클래스/객체 구성 방식 | Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy |
| **행위(Behavioral)** | 책임 분산, 행위 제어  | Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, Visitor |

## 🧱 1. **생성 패턴 (Creational)**

## 1.1 Singleton 패턴

### ✅ Singleton 패턴이란?

> **클래스의 인스턴스를 오직 하나만 생성**하고,
>  **그 인스턴스에 전역적으로 접근할 수 있도록 보장**하는 디자인 패턴

- 인스턴스 1개만 생성하여 **전역 접근** 가능하게 함
- 예: DB 커넥션 풀, 로그 관리자

### ✅ 1. 왜 쓰는가? (목적)

| 필요성                                | 설명                                            |
| ------------------------------------- | ----------------------------------------------- |
| **인스턴스 1개만 존재해야 하는 객체** | DB 연결, 로그 시스템, 환경 설정, 캐시 관리자 등 |
| **중앙 집중 제어 필요**               | 모든 클래스에서 동일한 객체를 공유해야 할 때    |
| **자원 절약**                         | 객체 생성을 반복하지 않고 재사용 가능           |

### ✅ 2. 구조 다이어그램 (UML)

```
┌────────────────────┐
│    Singleton       │
├────────────────────┤
│ - instance         │ ← static 필드 (자기 자신)
│ + getInstance()    │ ← static 메서드 (접근 통로)
└────────────────────┘
```

### ✅ 3. 기본 구현 (Java 예시)

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {
        // 생성자 비공개
    }

    public static Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}

```

#### 🔹 사용법

```java
Singleton obj1 = Singleton.getInstance();
Singleton obj2 = Singleton.getInstance();
System.out.println(obj1 == obj2); // true
```

### ✅ 4. 다양한 구현 방식

#### 🔸 ① **게으른 초기화 (Lazy Initialization)**

```java
public static Singleton getInstance() {
    if (instance == null)
        instance = new Singleton(); // 필요한 순간 생성
    return instance;
}
```

❌ 단점: 멀티스레드 환경에서 두 번 생성될 수 있음

#### 🔸 ② **동기화 사용 (Thread-safe)**

```java
public static synchronized Singleton getInstance() {
    if (instance == null)
        instance = new Singleton();
    return instance;
}
```

❌ 단점: 성능 저하 (매 호출마다 락이 걸림)

#### 🔸 ③ **이중 검사 잠금 (Double-Checked Locking)**

```java
public static Singleton getInstance() {
    if (instance == null) {
        synchronized (Singleton.class) {
            if (instance == null)
                instance = new Singleton();
        }
    }
    return instance;
}
```

✅ 성능 + 안정성 확보

#### 🔸 ④ **정적 초기화 (Eager Initialization)**

```java
public class Singleton {
    private static final Singleton instance = new Singleton(); // 클래스 로딩 시 생성

    private Singleton() {}

    public static Singleton getInstance() {
        return instance;
    }
}
```

✅ 단순함, 스레드 안전

❌ 객체가 항상 생성됨 (쓸지 안 쓸지와 무관)

#### 🔸 ⑤ **정적 내부 클래스 (Bill Pugh Singleton)** ✅ 추천

```java
public class Singleton {
    private Singleton() {}

    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

✅ 지연 초기화 + 스레드 안전 + 간결함 → 가장 권장됨

### ✅ 5. 스레드 안전성과 Lazy Loading 비교

| 구현 방식        | Lazy Loading | Thread-safe | 성능     |
| ---------------- | ------------ | ----------- | -------- |
| Lazy 초기화      | O            | ❌           | 빠름     |
| synchronized     | O            | ✅           | 느림     |
| double-check     | O            | ✅           | 좋음     |
| static 초기화    | ❌            | ✅           | 좋음     |
| 내부 정적 클래스 | O            | ✅           | **최고** |

### ✅ 6. Singleton의 한계와 주의점

| 한계                          | 설명                                                    |
| ----------------------------- | ------------------------------------------------------- |
| **테스트 어려움**             | 상태가 전역으로 유지되어 단위 테스트 어려움 (Mock 불가) |
| **의존성 숨김**               | 다른 객체가 어디서 이 싱글턴을 참조하는지 불분명        |
| **멀티스레드 동시 접근 문제** | 잘못 구현하면 2개 이상 생성될 수 있음                   |
| **GC로부터 해제 안 됨**       | 애플리케이션이 끝날 때까지 메모리에 남음                |

### ✅ 7. 실무 예시

| 적용 대상                      | 설명                                               |
| ------------------------------ | -------------------------------------------------- |
| **Logger**                     | 여러 곳에서 로그 찍을 때 동일 Logger 인스턴스 사용 |
| **Database Connection Pool**   | 연결을 하나의 객체에서 중앙 관리                   |
| **환경 설정 객체**             | 설정 값 한 번만 로딩 후 어디서든 사용              |
| **스프링의 Bean (기본 Scope)** | 기본적으로 Singleton (컨테이너 관리)               |

### ✅ 8. Python Singleton 예시

```python
class Singleton:
    _instance = None

    def __new__(cls):
        if not cls._instance:
            cls._instance = super().__new__(cls)
        return cls._instance
```

또는

```python
def singleton(cls):
    instances = {}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper

@singleton
class MyConfig:
    pass
```

### 🧠 마무리 요약

| 항목      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 목적      | **전역적으로 1개 인스턴스**를 사용                           |
| 구현 핵심 | 생성자 `private`, static `getInstance()`                     |
| 추천 구현 | **정적 내부 클래스 방식** (Java), `@singleton` 데코레이터 (Python) |
| 주의점    | 테스트 어려움, 상태 공유 부작용, 메모리 누수 위험            |
| 대안      | 의존성 주입(DI), Factory + Scope 컨트롤                      |

## 1.2 Factory Method (팩토리 메서드)

- 객체 생성을 서브클래스에 위임
- `Product`라는 인터페이스 → `createProduct()`가 구현체를 리턴

### ✅ Factory Method 패턴이란?

> 객체 생성 코드를 **서브클래스에서 책임지도록** 위임하여,
>  **구체적인 클래스에 의존하지 않고 객체를 생성**할 수 있게 만드는 디자인 패턴

### ✅ 목적 (왜 쓰는가?)

| 이유                    | 설명                                          |
| ----------------------- | --------------------------------------------- |
| 객체 생성 로직을 캡슐화 | new 키워드 남발 방지, 의존도 낮춤             |
| 확장성 향상             | 새로운 클래스 추가 시 클라이언트 수정 최소화  |
| 느슨한 결합             | 인터페이스/추상 클래스 기반 프로그래밍 가능   |
| 유연한 객체 생성        | 상황에 따라 다른 객체를 리턴 가능 (전략 분기) |

### ✅ 구조 (핵심 개념)

#### 구성요소

| 구성                          | 설명                                          |
| ----------------------------- | --------------------------------------------- |
| **Product (제품 인터페이스)** | 생성될 객체의 공통 인터페이스                 |
| **ConcreteProduct**           | 실제 생성될 객체                              |
| **Creator (추상 Creator)**    | 팩토리 메서드를 선언한 클래스                 |
| **ConcreteCreator**           | 팩토리 메서드를 오버라이드하여 구체 객체 생성 |

### ✅ UML 구조

```
        ┌─────────────┐
        │  Product    │◄────────────┐
        └─────────────┘             │
               ▲                    │
       ┌─────────────┐        ┌─────────────┐
       │ConcreteProd1│        │ConcreteProd2│
       └─────────────┘        └─────────────┘

        ┌──────────────┐
        │   Creator    │
        ├──────────────┤
        │+factoryMethod()│
        └──────────────┘
               ▲
        ┌──────────────┐
        │ConcreteCreator│ → factoryMethod() returns ConcreteProd1 or 2
        └──────────────┘
```

### ✅ Java 예제

#### 1. Product (인터페이스)

```java
public interface Button {
    void render();
}

```

#### 2. ConcreteProduct

```java
public class WindowsButton implements Button {
    public void render() {
        System.out.println("윈도우 버튼 렌더링");
    }
}

public class MacButton implements Button {
    public void render() {
        System.out.println("맥 버튼 렌더링");
    }
}

```

#### 3. Creator (추상 팩토리 클래스)

```java
public abstract class Dialog {
    public void renderWindow() {
        Button okButton = createButton(); // 팩토리 메서드 호출
        okButton.render();
    }

    protected abstract Button createButton(); // 팩토리 메서드
}

```

#### 4. ConcreteCreator

```java
public class WindowsDialog extends Dialog {
    protected Button createButton() {
        return new WindowsButton();
    }
}

public class MacDialog extends Dialog {
    protected Button createButton() {
        return new MacButton();
    }
}

```

#### 5. 클라이언트 코드

```java
public class Client {
    public static void main(String[] args) {
        Dialog dialog;

        String os = System.getProperty("os.name");
        if (os.contains("Windows")) {
            dialog = new WindowsDialog();
        } else {
            dialog = new MacDialog();
        }

        dialog.renderWindow(); // 추상에 의존 → 구체 클래스 몰라도 됨
    }
}

```

### ✅ Python 예제 (간단하게)

```python
from abc import ABC, abstractmethod

class Button(ABC):
    @abstractmethod
    def render(self): pass

class WindowsButton(Button):
    def render(self): print("윈도우 버튼")

class MacButton(Button):
    def render(self): print("맥 버튼")

class Dialog(ABC):
    def render_window(self):
        btn = self.create_button()
        btn.render()

    @abstractmethod
    def create_button(self): pass

class WindowsDialog(Dialog):
    def create_button(self): return WindowsButton()

class MacDialog(Dialog):
    def create_button(self): return MacButton()
```

### ✅ 팩토리 메서드 vs 단순 팩토리 vs 추상 팩토리

| 구분      | Factory Method    | Simple Factory       | Abstract Factory                     |
| --------- | ----------------- | -------------------- | ------------------------------------ |
| 생성 책임 | 서브클래스에 위임 | 하나의 static 메서드 | 제품군 생성 책임                     |
| 확장성    | 좋음 (상속 기반)  | 낮음                 | 매우 높음                            |
| 구조      | 상속 필요         | 정적 메서드로 구현   | 관련 객체 집합 생성                  |
| 예시      | GUI 버튼 생성     | 자동차 공장          | GUI + 창 + 메뉴팩토리 등 전체 제품군 |

### ✅ 장점

- 새로운 제품을 쉽게 추가 가능
- **상위 클래스는 객체 생성 방식과 타입을 몰라도 됨**
- 객체 생성을 캡슐화하여 책임 분리

### ❌ 단점

- **클래스 수 증가** (Creator, Product 둘 다 계층화)
- 단순한 경우에는 과한 구조가 될 수 있음

### ✅ 실무 활용 예시

| 분야             | 적용                                                         |
| ---------------- | ------------------------------------------------------------ |
| GUI 라이브러리   | OS별 버튼/다이얼로그 팩토리                                  |
| JDBC             | `DriverManager.getConnection()` 내부에서 팩토리 방식         |
| Spring Framework | `ApplicationContext.getBean()` → Bean 생성이 팩토리 메서드 기반 |
| 웹 클라이언트    | 요청 타입별 핸들러 생성기 (`RequestHandlerFactory`) 등       |

### 🧠 마무리 요약

| 항목      | 내용                                                   |
| --------- | ------------------------------------------------------ |
| 목적      | **객체 생성 로직을 서브클래스로 위임**해 유연한 설계   |
| 핵심 구조 | Product, Creator, ConcreteProduct, ConcreteCreator     |
| 사용 시점 | 객체 생성 방식이 다양할 때 / 클라이언트가 타입 모를 때 |
| 대안      | Builder, Abstract Factory, Dependency Injection        |

## 1.3 Abstract Factory (추상 팩토리)

- 관련 있는 객체들을 **통일된 팩토리 인터페이스**로 생성
- 예: GUI 버튼 + 체크박스 (Windows용 / Mac용 등)

### ✅ Abstract Factory 패턴이란?

> **관련된 객체들의 “제품군(family)”을 생성하는 인터페이스**를 제공하되,
>  **구체적인 클래스는 지정하지 않고**,
>  **구상 클래스들을 생성할 수 있게 만드는** 디자인 패턴

### ✅ 1. 핵심 목적

| 목적                      | 설명                                                 |
| ------------------------- | ---------------------------------------------------- |
| 제품군을 통째로 교체 가능 | GUI, DB, 드라이버 등 계열별 객체를 **한 번에** 교체  |
| 구상 클래스 은닉          | 클라이언트는 **인터페이스만** 알고, 구체 타입은 모름 |
| 일관된 제품 사용 보장     | 같은 계열의 컴포넌트만 혼용 없이 생성 가능           |

### ✅ 2. 구조 (UML)

```
         ┌──────────────────────┐
         │ AbstractFactory      │◄─────────────┐
         ├──────────────────────┤              │
         │ + createButton()     │              │
         │ + createCheckbox()   │              │
         └──────────────────────┘              │
                 ▲                             │
     ┌────────────────────────┐      ┌────────────────────────┐
     │ WinFactory             │      │ MacFactory             │
     ├────────────────────────┤      ├────────────────────────┤
     │ + createButton()       │      │ + createButton()       │
     │ + createCheckbox()     │      │ + createCheckbox()     │
     └────────────────────────┘      └────────────────────────┘

┌────────────┐     ┌────────────┐
│Button       │     │Checkbox     │ ← 제품 인터페이스
└────────────┘     └────────────┘
     ▲                   ▲
┌────────────┐     ┌────────────┐
│WinButton    │     │WinCheckbox │
└────────────┘     └────────────┘
```

### ✅ 3. Java 예시

#### 🔸 ① 제품 인터페이스

```java
public interface Button {
    void paint();
}

public interface Checkbox {
    void paint();
}
```

#### 🔸 ② 구체 제품

```java
public class WinButton implements Button {
    public void paint() {
        System.out.println("Windows 스타일 버튼");
    }
}

public class MacButton implements Button {
    public void paint() {
        System.out.println("Mac 스타일 버튼");
    }
}

public class WinCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Windows 스타일 체크박스");
    }
}

public class MacCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Mac 스타일 체크박스");
    }
}
```

#### 🔸 ③ 추상 팩토리

```java
public interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}
```

#### 🔸 ④ 구체 팩토리

```java
public class WinFactory implements GUIFactory {
    public Button createButton() {
        return new WinButton();
    }

    public Checkbox createCheckbox() {
        return new WinCheckbox();
    }
}

public class MacFactory implements GUIFactory {
    public Button createButton() {
        return new MacButton();
    }

    public Checkbox createCheckbox() {
        return new MacCheckbox();
    }
}
```

#### 🔸 ⑤ 클라이언트 코드

```java
public class Application {
    private final Button button;
    private final Checkbox checkbox;

    public Application(GUIFactory factory) {
        this.button = factory.createButton();
        this.checkbox = factory.createCheckbox();
    }

    public void render() {
        button.paint();
        checkbox.paint();
    }
}
```

#### 🔸 ⑥ 실행

```java
public class Client {
    public static void main(String[] args) {
        GUIFactory factory;
        String os = System.getProperty("os.name");

        if (os.contains("Mac")) {
            factory = new MacFactory();
        } else {
            factory = new WinFactory();
        }

        Application app = new Application(factory);
        app.render();
    }
}
```

### ✅ 4. Abstract Factory vs Factory Method

| 항목       | Factory Method      | Abstract Factory                          |
| ---------- | ------------------- | ----------------------------------------- |
| 생성 대상  | 단일 객체           | **제품군 전체**                           |
| 확장 방식  | 서브클래스에서 생성 | 제품군 팩토리를 새로 만듦                 |
| 클라이언트 | 단일 객체만 생성    | 여러 관련 객체를 일관되게 생성            |
| 예시       | Button만 만들기     | Button + Checkbox + Menu 등 전체 GUI 구성 |

### ✅ 5. 장점

| 장점                   | 설명                                            |
| ---------------------- | ----------------------------------------------- |
| 제품군 통일성          | 동일한 스타일의 컴포넌트만 생성되도록 강제 가능 |
| 클라이언트와 구현 분리 | 클라이언트는 팩토리 인터페이스만 알면 됨        |
| OCP 만족               | 새 제품군이 필요하면 팩토리만 추가              |

### ❌ 단점

| 단점               | 설명                                                  |
| ------------------ | ----------------------------------------------------- |
| 클래스 수 증가     | 제품 × 계열만큼 팩토리 클래스가 필요함                |
| 제품군 확장 어려움 | Button/Checkbox 외 제품 추가 시 모든 팩토리 수정 필요 |

### ✅ 6. 실무 적용 예시

| 분야             | 적용 예시                                     |
| ---------------- | --------------------------------------------- |
| GUI Toolkit      | Java Swing, Qt, Android XML UI 등             |
| 테마 적용        | 다크모드 vs 라이트모드 스타일 컴포넌트 제공   |
| DB 연동          | DAO 팩토리: OracleDAOFactory, MySQLDAOFactory |
| 스프링 Bean 설정 | `@Profile` 기반으로 다른 Bean 생성 전략       |

### ✅ 7. Python 간단 예시

```python
class Button:
    def paint(self): pass

class MacButton(Button):
    def paint(self): print("맥 버튼")

class WinButton(Button):
    def paint(self): print("윈도우 버튼")

class GUIFactory:
    def create_button(self): pass

class MacFactory(GUIFactory):
    def create_button(self): return MacButton()

class WinFactory(GUIFactory):
    def create_button(self): return WinButton()
```

### 🧠 마무리 요약

| 항목      | 내용                                                     |
| --------- | -------------------------------------------------------- |
| 핵심 개념 | **제품군 전체를 일관되게 생성하는 추상 인터페이스** 제공 |
| 사용 조건 | 여러 연관된 객체들을 **한 번에 대체해야 할 때**          |
| 대표 예시 | GUI 위젯 세트, 테마 스킨 세트, DAO 팩토리 세트           |
| 주의점    | 제품 수보다 제품군 수가 늘어날수록 효과가 크다           |

## 1.4 Builder (빌더)

- 복잡한 객체를 단계적으로 생성
- `setX().setY().build()` 형태

### ✅ Builder 패턴이란?

> **복잡한 객체의 생성 과정을 분리**해서
>  **동일한 생성 절차로 서로 다른 표현 결과**를 만들 수 있게 하는 디자인 패턴

- 객체를 **부분적으로, 단계적으로 구성**
- 객체 생성의 **과정을 캡슐화**하여,
   **객체 내부 구조와 생성 과정을 분리**

### ✅ 1. 언제 쓰는가? (적용 목적)

| 상황                                   | 설명                                                  |
| -------------------------------------- | ----------------------------------------------------- |
| 생성자 파라미터가 너무 많을 때         | new Car("red", 4, false, true, ...)처럼 혼란스러울 때 |
| 선택적 파라미터가 많을 때              | 필수/옵션 구분해 유연하게 생성                        |
| 복잡한 객체 생성 절차를 숨기고 싶을 때 | 디렉터에게 빌더만 넘기면 됨                           |

### ✅ 2. 구조 (UML 기준)

```
         ┌──────────────┐
         │  Director    │ ← 생성 순서 관리
         └─────┬────────┘
               │
         ┌─────▼────────┐
         │  Builder     │ ← 추상 빌더 인터페이스
         ├──────────────┤
         │+buildPartA() │
         │+buildPartB() │
         │+getResult()  │
         └─────▲────────┘
       ┌───────────────┐
       │ConcreteBuilder│ ← 실제 구성 책임
       └───────────────┘

        ┌──────────────┐
        │  Product     │ ← 완성 객체
        └──────────────┘
```

### ✅ 3. Java 예제

#### 🔸 Product 클래스

```java
public class Car {
    private String engine;
    private String wheels;
    private boolean sunroof;

    // setter 방식 or 생성자 생략
    public void setEngine(String engine) { this.engine = engine; }
    public void setWheels(String wheels) { this.wheels = wheels; }
    public void setSunroof(boolean sunroof) { this.sunroof = sunroof; }

    public void showSpec() {
        System.out.println("엔진: " + engine);
        System.out.println("바퀴: " + wheels);
        System.out.println("썬루프: " + sunroof);
    }
}
```

#### 🔸 Builder 인터페이스

```java
public interface CarBuilder {
    void buildEngine();
    void buildWheels();
    void buildSunroof();
    Car getResult();
}
```

#### 🔸 ConcreteBuilder

```java
public class SportsCarBuilder implements CarBuilder {
    private Car car = new Car();

    public void buildEngine() { car.setEngine("V8 엔진"); }
    public void buildWheels() { car.setWheels("레이싱 타이어"); }
    public void buildSunroof() { car.setSunroof(true); }
    public Car getResult() { return car; }
}
```

#### 🔸 Director (조립 순서 담당)

```java
public class CarDirector {
    public Car construct(CarBuilder builder) {
        builder.buildEngine();
        builder.buildWheels();
        builder.buildSunroof();
        return builder.getResult();
    }
}
```

#### 🔸 사용 예

```java
public class Client {
    public static void main(String[] args) {
        CarBuilder builder = new SportsCarBuilder();
        CarDirector director = new CarDirector();
        Car car = director.construct(builder);
        car.showSpec();
    }
}
```

### ✅ 4. 파라미터 체이닝 방식 (Java 스타일 빌더)

```java
public class User {
    private final String name;
    private final int age;
    private final String email;

    private User(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.email = builder.email;
    }

    public static class Builder {
        private String name;
        private int age;
        private String email;

        public Builder name(String name) {
            this.name = name; return this;
        }

        public Builder age(int age) {
            this.age = age; return this;
        }

        public Builder email(String email) {
            this.email = email; return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

### 🔹 사용 예

```java
User user = new User.Builder()
    .name("홍길동")
    .age(30)
    .email("hong@example.com")
    .build();
```

### ✅ 5. Python 예시

```python
class Burger:
    def __init__(self):
        self.parts = []

    def add(self, part):
        self.parts.append(part)

    def show(self):
        print("버거 구성:", self.parts)

class BurgerBuilder:
    def __init__(self):
        self.burger = Burger()

    def add_bun(self):
        self.burger.add("빵")
        return self

    def add_patty(self):
        self.burger.add("패티")
        return self

    def add_lettuce(self):
        self.burger.add("양상추")
        return self

    def build(self):
        return self.burger

# 사용
burger = BurgerBuilder().add_bun().add_patty().add_lettuce().build()
burger.show()
```

### ✅ 6. Builder vs Abstract Factory vs Factory Method

| 패턴                 | 목적                         | 특징                               |
| -------------------- | ---------------------------- | ---------------------------------- |
| **Builder**          | **복합 객체 생성 절차 분리** | 단계별 생성, 구조 유연             |
| **Factory Method**   | **단일 객체 생성 위임**      | 구상 객체 숨기고 서브클래스에 위임 |
| **Abstract Factory** | **제품군 일관성 유지**       | 팩토리로 여러 객체 일괄 생성       |

### ✅ 7. 장점

| 장점                  | 설명                                     |
| --------------------- | ---------------------------------------- |
| 복잡한 생성 로직 분리 | 생성과 표현을 분리함으로써 유지보수 용이 |
| 유연한 객체 생성      | 생성 순서/구성 선택 가능                 |
| 가독성 향상           | `builder.setX().setY()`로 코드 명확      |
| 불변 객체 생성에 유리 | 생성 후 변경 불가 객체 생성 시 효과적    |

### ❌ 단점

| 단점               | 설명                                |
| ------------------ | ----------------------------------- |
| 클래스 수 증가     | Builder, Director 등 추가 코드 필요 |
| 간단한 객체엔 과함 | 단순 객체엔 불필요한 구조           |

### ✅ 8. 실무 활용 예시

| 분야              | 활용                             |
| ----------------- | -------------------------------- |
| Lombok @Builder   | DTO, 엔티티 생성자 대체          |
| Jackson / GSON    | JSON → 객체 변환 시 Builder 지원 |
| REST API 응답     | 복합 응답 객체 생성 시 유용      |
| 객체 시리얼라이징 | 상태를 단계별로 구성할 때 효과적 |

### 🧠 마무리 요약

| 항목      | 핵심 내용                                          |
| --------- | -------------------------------------------------- |
| 목적      | 복잡한 객체 생성 과정을 분리하고, 다양한 표현 지원 |
| 핵심 구성 | Product, Builder, ConcreteBuilder, Director        |
| 사용 조건 | 파라미터가 많거나 조합이 다양한 객체 생성 시       |
| 대안      | `@Builder`, 체이닝 생성자, 팩토리 패턴과 조합      |

## 1.5 Prototype (프로토타입)

- 객체를 **복제(clone)**해서 생성
- 예: 객체 복사 성능 이슈 해결

### ✅ 1. 언제 쓰는가? (목적)

| 목적                                          | 설명                                          |
| --------------------------------------------- | --------------------------------------------- |
| 생성 비용이 큰 객체                           | 매번 생성하기 어려운 경우 복제하여 재사용     |
| 설정/상태가 동일한 객체가 여러 개 필요한 경우 | 공통 틀에서 복제해 다른 속성만 살짝 바꿔 사용 |
| `new` 키워드 사용을 줄이고 싶을 때            | 클래스가 뭔지 몰라도 객체 복제가 가능하게     |

### ✅ 2. 구조 (UML)

```
     ┌──────────────┐
     │ Prototype    │ ← clone() 메서드 선언 (interface or abstract)
     └─────┬────────┘
           │
     ┌─────▼────────┐
     │ ConcretePrototype │ ← clone() 구현
     └──────────────┘

           ▲
           │
     ┌──────────────┐
     │   Client     │ ← clone() 호출
     └──────────────┘
```

### ✅ 3. Java 예제

#### 🔸 ① Prototype 인터페이스

```java
public interface Prototype extends Cloneable {
    Prototype clone();
}
```

#### 🔸 ② ConcretePrototype

```java
public class Document implements Prototype {
    private String content;

    public Document(String content) {
        this.content = content;
    }

    public void print() {
        System.out.println("문서 내용: " + content);
    }

    @Override
    public Document clone() {
        try {
            return (Document) super.clone(); // 얕은 복사
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    public void setContent(String content) {
        this.content = content;
    }
}
```

#### 🔸 ③ 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        Document doc1 = new Document("원본 문서");
        Document doc2 = doc1.clone(); // 복제

        doc2.setContent("복제 문서");
        doc1.print(); // 원본 문서
        doc2.print(); // 복제 문서
    }
}
```

### ✅ 4. 얕은 복사 vs 깊은 복사

| 구분                    | 설명                                         | 영향                |
| ----------------------- | -------------------------------------------- | ------------------- |
| **얕은 복사 (Shallow)** | 기본 타입은 값 복사, 참조 타입은 주소만 복사 | 내부 참조 객체 공유 |
| **깊은 복사 (Deep)**    | 모든 내부 객체까지 재귀적으로 복사           | 독립된 객체 복사    |

#### 🔸 Java 깊은 복사 예시

```java
@Override
public Document clone() {
    Document copy = new Document(this.content); // 직접 새로 생성
    return copy;
}
```

### ✅ 5. Python 예제 (copy 모듈)

```python
import copy

class Prototype:
    def __init__(self, name, meta):
        self.name = name
        self.meta = meta

    def __str__(self):
        return f"{self.name}, {self.meta}"

# 얕은 복사
a = Prototype("원본", {"id": 1})
b = copy.copy(a)
b.meta["id"] = 2

print(a)  # meta도 바뀜!
print(b)
```

```python
# 깊은 복사
b = copy.deepcopy(a)
b.meta["id"] = 999
```

### ✅ 6. Prototype vs Factory Method

| 항목      | Prototype               | Factory Method                 |
| --------- | ----------------------- | ------------------------------ |
| 생성 방식 | 객체 복제               | 클래스 통해 직접 생성          |
| 속도      | 빠름 (복사)             | 상대적으로 느림                |
| 목적      | 동일한 구조의 객체 복제 | 객체 생성을 하위 클래스로 위임 |
| 유연성    | 동적으로 구조 복제      | 구조 확장에 강함               |

### ✅ 7. 장점

| 장점                    | 설명                               |
| ----------------------- | ---------------------------------- |
| 객체 생성 비용 감소     | 복제로 빠른 생성 가능              |
| 클래스에 의존하지 않음  | `.clone()`만 있으면 됨             |
| 다양한 객체의 동적 생성 | 런타임에서 객체 동적으로 복제 가능 |

### ❌ 단점

| 단점                              | 설명                                         |
| --------------------------------- | -------------------------------------------- |
| clone 구현이 까다로움             | 깊은 복사 시 재귀 처리, 참조 객체 고려 필요  |
| cloneable 미지원 객체 처리 어려움 | Java: `CloneNotSupportedException` 처리 필요 |
| 무분별한 복제는 혼란 유발         | 상태 관리 주의 필요 (공유된 객체 파손 가능)  |

### ✅ 8. 실무 활용 예

| 분야          | 사용 예                     |
| ------------- | --------------------------- |
| GUI 복제      | 컴포넌트 복사해서 UI 배치   |
| 게임 오브젝트 | 무기/캐릭터 템플릿 복사     |
| 문서 편집기   | 페이지/요소 복사 기능 구현  |
| 데이터 템플릿 | 양식 기반 입력폼, 보고서 등 |

### ✅ 9. Prototype Registry (프로토타입 캐시)

```java
Map<String, Prototype> registry = new HashMap<>();
registry.put("basic", new Document("템플릿"));
Document copy = registry.get("basic").clone();
```

→ 자주 쓰는 **템플릿 객체를 복제용으로 보관**해두는 방식

### 🧠 마무리 요약

| 항목        | 내용                                                     |
| ----------- | -------------------------------------------------------- |
| 목적        | **비용이 큰 객체 생성 대신, 복제(clone)로 새 객체 생성** |
| 구성        | Prototype 인터페이스, ConcretePrototype, Client          |
| 구현 포인트 | 얕은 복사 vs 깊은 복사 구분 필수                         |
| 실전 활용   | 문서 복제, 게임 객체, UI 컴포넌트 복사                   |
| 주의        | 복사 시 참조된 객체들의 상태 공유 주의                   |

## 🧱 2. **구조 패턴 (Structural)**

## 2.1 Adapter (어댑터)

- **호환되지 않는 인터페이스**를 연결
- `USB → Micro5핀`, `ListAdapter`, `@ResponseEntity` 등

### ✅ Adapter 패턴이란?

> **인터페이스 호환이 되지 않는 클래스를 클라이언트가 사용하도록 중간에 어댑터를 끼워 맞추는 구조 패턴**
>  즉, **"끼워 맞추기"**, "**변환기 역할**"을 하는 패턴.

### ✅ 1. 목적 (왜 쓰는가?)

| 목적                          | 설명                                                    |
| ----------------------------- | ------------------------------------------------------- |
| 인터페이스가 다른 클래스 사용 | 기존 코드 재사용, 외부 라이브러리 적용                  |
| 호환성 문제 해결              | 클라이언트는 A 인터페이스를 기대하는데, B만 제공될 경우 |
| 기존 클래스를 수정 없이 활용  | 변경 없이 어댑터만 만들어서 호환                        |

### ✅ 2. 구조 요약

```
Client ──────▶ Target (사용하고자 하는 인터페이스)
                          ▲
                          │
                  ┌───────┴────────┐
                  │   Adapter      │ ← 중간 변환자 (Target을 흉내냄)
                  └───────┬────────┘
                          │
                          ▼
                      Adaptee (기존 구현체)
```

### ✅ 3. Adapter 패턴의 2가지 종류

| 유형              | 설명                        | 구현 방식                                       |
| ----------------- | --------------------------- | ----------------------------------------------- |
| **클래스 어댑터** | 상속을 통해 인터페이스 변환 | `extends` + `implements` 사용 (Java에서 제한적) |
| **객체 어댑터**   | 위임(Composition)으로 변환  | 어댑터가 기존 객체를 참조하여 메서드 변환       |

→ 일반적으로 **객체 어댑터 방식이 더 유연하고 흔하게 쓰임**

### ✅ 4. UML (객체 어댑터 기준)

```
       ┌────────────┐
       │   Client   │
       └────┬───────┘
            ▼
       ┌────────────┐
       │   Target   │◄──────┐
       └────┬───────┘       │
            ▼               │
       ┌────────────┐       │
       │  Adapter   │──────►│
       └────────────┘       │
            ▲               │
            │ has-a         │
       ┌────────────┐       │
       │  Adaptee   │───────┘
       └────────────┘
```

### ✅ 5. Java 예제 (객체 어댑터 방식)

#### 🔹 기존 클래스 (Adaptee)

```java
public class OldPrinter {
    public void oldPrint(String msg) {
        System.out.println("OLD 출력: " + msg);
    }
}
```

#### 🔹 원하는 인터페이스 (Target)

```java
public interface Printer {
    void print(String msg);
}
```

#### 🔹 어댑터

```java
public class PrinterAdapter implements Printer {
    private OldPrinter oldPrinter;

    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }

    public void print(String msg) {
        oldPrinter.oldPrint(msg); // 변환 수행
    }
}
```

#### 🔹 클라이언트 사용 예

```java
public class Client {
    public static void main(String[] args) {
        OldPrinter legacy = new OldPrinter();
        Printer printer = new PrinterAdapter(legacy); // 호환 가능

        printer.print("Hello Adapter!");
    }
}
```

### ✅ 6. Python 예시

```python
class OldPrinter:
    def old_print(self, text):
        print("OLD:", text)

class PrinterAdapter:
    def __init__(self, adaptee):
        self.adaptee = adaptee

    def print(self, msg):
        self.adaptee.old_print(msg)

# 사용
legacy = OldPrinter()
adapter = PrinterAdapter(legacy)
adapter.print("어댑터 패턴 예제")
```

### ✅ 7. 실무 활용 예

| 분야                 | 사용 예                                                      |
| -------------------- | ------------------------------------------------------------ |
| 외부 API 연동        | 인터페이스가 다를 때 중간 어댑터로 변환                      |
| 레거시 코드 리팩토링 | 기존 시스템 클래스를 새 시스템에 맞춰 사용할 때              |
| GUI 컴포넌트 연결    | 시스템마다 다른 인터페이스를 일관된 인터페이스로 통일        |
| JDBC/ORM             | `DataSource`, `ResultSet` 등 다양한 구현이 하나의 인터페이스로 작동 |

### ✅ 8. 장점

| 장점               | 설명                                           |
| ------------------ | ---------------------------------------------- |
| 재사용성 ↑         | 기존 클래스 변경 없이 재활용                   |
| 분리 구조 유지     | 새 시스템과 기존 구현 간 결합도 낮춤           |
| 유연한 시스템 구성 | 다양한 형식의 객체를 통일된 방식으로 사용 가능 |

### ❌ 단점

| 단점           | 설명                                               |
| -------------- | -------------------------------------------------- |
| 클래스 수 증가 | Adapter, Target 등 인터페이스 구성 필요            |
| 복잡도 증가    | 너무 많은 어댑터는 오히려 구조를 복잡하게 만듦     |
| 성능 이슈      | 중간 어댑터를 통해 호출되므로 약간의 오버헤드 존재 |

### ✅ 9. Adapter vs 다른 구조 패턴 비교

| 패턴          | 목적                                     | 특징                                           |
| ------------- | ---------------------------------------- | ---------------------------------------------- |
| **Adapter**   | 기존 인터페이스 ↔ 새로운 인터페이스 연결 | 클래스 수정 없이 연결                          |
| **Decorator** | 기능 확장                                | 인터페이스는 동일, 기능만 추가                 |
| **Facade**    | 서브시스템 간소화                        | 여러 인터페이스를 하나로 묶어 제공             |
| **Bridge**    | 구현과 추상 분리                         | 계층구조 확장에 유리 (interface + implementor) |

### 🧠 마무리 요약

| 항목      | 내용                                                     |
| --------- | -------------------------------------------------------- |
| 정의      | **호환되지 않는 인터페이스를 연결하는 중간 객체**        |
| 핵심 구조 | `Client → Target → Adapter → Adaptee`                    |
| 추천 방식 | **객체 어댑터 방식 (위임 기반)**                         |
| 실무 활용 | 레거시 ↔ 신규 연결, API 호환 처리                        |
| 주의점    | Adapter는 "변환기"일 뿐, 과도하게 남용하면 구조가 흐려짐 |

## 2.2 Bridge (브리지)

- **기능과 구현을 분리**
- 서로 독립적 확장 가능

### ✅ Bridge 패턴이란?

> **추상(Abstraction)과 구현(Implementation)을 분리**해서
>  **서로 독립적으로 확장할 수 있게** 만드는 구조 패턴

### ✅ 1. 언제 쓰는가? (목적)

| 상황                                          | 설명                                                  |
| --------------------------------------------- | ----------------------------------------------------- |
| **계층적으로 변화하는 클래스 구조가 있을 때** | ex) "도형"은 확장돼야 하고, "색상"도 계속 추가된다면? |
| **구현과 인터페이스를 독립적으로 확장**       | 각 변화가 서로 영향을 주지 않도록 분리                |
| **다형적 구조를 유지하면서 조합 가능한 경우** | 조합 개수 증가 시, 클래스 수 증가 폭을 줄이기 위해    |

### ✅ 2. 구조 요약 (핵심 개념)

| 요소                    | 설명                                                   |
| ----------------------- | ------------------------------------------------------ |
| **Abstraction**         | 인터페이스나 추상 클래스 역할. 구현에 대한 참조를 포함 |
| **RefinedAbstraction**  | Abstraction의 확장 (클라이언트가 사용하는 객체)        |
| **Implementor**         | 실제 기능을 수행할 인터페이스 (플랫폼 종속적 작업 등)  |
| **ConcreteImplementor** | Implementor의 구체 구현체                              |

### ✅ 3. UML 구조

```
        ┌────────────────────┐
        │   Abstraction      │
        ├────────────────────┤
        │ +operation()       │
        │ -impl : Implementor│──┐
        └────────────────────┘  │
                ▲               │
        ┌──────────────┐        │
        │ RefinedAbstr │        │
        └──────────────┘        │
                                ▼
                      ┌──────────────────┐
                      │   Implementor    │
                      ├──────────────────┤
                      │ +operationImpl() │
                      └──────────────────┘
                                ▲
                     ┌──────────┴──────────┐
                     │ ConcreteImplementor │
                     └─────────────────────┘
```

### ✅ 4. 예제 시나리오: **모양(Shape)** + **색상(Color)**

#### ✦ "Shape"와 "Color"를 독립적으로 확장하고 싶다면?

### ✅ 5. Java 예제

#### 🔸 Implementor

```java
public interface Color {
    String fill();
}
```

#### 🔸 ConcreteImplementor

```java
public class Red implements Color {
    public String fill() {
        return "빨간색";
    }
}

public class Blue implements Color {
    public String fill() {
        return "파란색";
    }
}
```

#### 🔸 Abstraction

```java
public abstract class Shape {
    protected Color color;

    public Shape(Color color) {
        this.color = color;
    }

    public abstract void draw();
}
```

#### 🔸 RefinedAbstraction

```java
public class Circle extends Shape {
    public Circle(Color color) {
        super(color);
    }

    public void draw() {
        System.out.println(color.fill() + " 원 그리기");
    }
}

public class Square extends Shape {
    public Square(Color color) {
        super(color);
    }

    public void draw() {
        System.out.println(color.fill() + " 정사각형 그리기");
    }
}
```

#### 🔸 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        Shape redCircle = new Circle(new Red());
        Shape blueSquare = new Square(new Blue());

        redCircle.draw();     // 빨간색 원 그리기
        blueSquare.draw();    // 파란색 정사각형 그리기
    }
}
```

### ✅ 6. Python 예시

```python
class Color:
    def fill(self): pass

class Red(Color):
    def fill(self): return "빨간색"

class Shape:
    def __init__(self, color):
        self.color = color

    def draw(self): pass

class Circle(Shape):
    def draw(self): print(f"{self.color.fill()} 원")

class Square(Shape):
    def draw(self): print(f"{self.color.fill()} 정사각형")

# 사용
Circle(Red()).draw()
```

### ✅ 7. 장점

| 장점                | 설명                                           |
| ------------------- | ---------------------------------------------- |
| 변화에 유연         | Abstraction ↔ Implementor 독립적으로 확장 가능 |
| 조합 수 증가에 강함 | 2개 축이 조합되더라도 클래스 수 폭발 막음      |
| 의존성 역전         | 상위 계층이 하위 구현에 직접 의존하지 않음     |

### ❌ 단점

| 단점                                | 설명                                     |
| ----------------------------------- | ---------------------------------------- |
| 구조가 복잡해짐                     | 추상 계층 + 구현 계층 → 구성 요소 많아짐 |
| 단순한 문제에 오버엔지니어링 가능성 | 작은 프로젝트엔 과한 설계일 수 있음      |

### ✅ 8. Bridge vs Adapter

| 구분      | Bridge                        | Adapter                                    |
| --------- | ----------------------------- | ------------------------------------------ |
| 목적      | **추상 ↔ 구현 분리 (확장성)** | **호환되지 않는 인터페이스 연결 (호환성)** |
| 사용 시점 | **설계 단계부터 적용**        | **기존 코드 재사용 시 적용**               |
| 관계      | 새로운 조합 설계              | 기존 코드 수정 없이 변환                   |
| 구조      | 다형성 기반 위임 구조         | 하나의 Target을 변환하는 중간 객체         |

### ✅ 9. 실무 적용 예

| 적용 분야     | 예시                                                     |
| ------------- | -------------------------------------------------------- |
| UI 프레임워크 | 테마(Abstraction) + 렌더러(Implementor) 분리             |
| DB 연결       | DAO와 DB 드라이버를 독립적으로 관리                      |
| 그래픽 API    | Shape 클래스 ↔ OpenGL/DirectX 같은 렌더링 계층 분리      |
| 리포트 생성기 | 리포트 타입(Excel, PDF) + 출력 방식(API, 파일 저장) 분리 |

### 🧠 마무리 요약

| 항목      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 정의      | **추상과 구현을 분리**해서 각자 독립적으로 확장 가능하게 만드는 구조 패턴 |
| 구조      | `Abstraction ↔ Implementor`, 상호 위임                       |
| 장점      | 확장성 ↑, 조합 수 ↑, 느슨한 결합                             |
| 사용 시점 | "2개 이상의 확장 축"이 필요한 상황                           |
| 비교      | Adapter는 호환, Bridge는 구조적 확장                         |

## 2.3 Composite (컴포지트)

- 트리 구조 표현, **개별 객체와 그룹을 동일하게 취급**
- 예: 폴더와 파일, 댓글과 대댓글

### ✅ Composite 패턴이란?

> **부분-전체 계층 구조(트리 구조)**를 표현할 때,
>  **개별 객체와 복합 객체(그룹)를 동일하게 다룰 수 있게 하는 패턴**

즉, 클라이언트가 **"Leaf"와 "Group"을 구분하지 않고 동일한 방식으로 다루게** 해줌.

### ✅ 1. 목적

| 목표              | 설명                                  |
| ----------------- | ------------------------------------- |
| 트리 구조 표현    | 예: 디렉터리 안에 또 디렉터리, 파일   |
| 클라이언트 단순화 | Leaf/Group 구분 없이 통일된 연산 사용 |
| 재귀적 구조 처리  | 재귀 호출로 전체 구조를 손쉽게 탐색   |

### ✅ 2. 구조 (UML)

```
                ┌───────────────┐
                │   Component   │ ← 공통 인터페이스 (추상)
                ├───────────────┤
                │ +operation()  │
                └──────┬────────┘
             ┌─────────┴──────────┐
             ▼                    ▼
     ┌───────────────┐     ┌──────────────┐
     │     Leaf      │     │   Composite  │
     ├───────────────┤     ├──────────────┤
     │ +operation()  │     │ +add()       │
     └───────────────┘     │ +remove()    │
                           │ +operation() │ → 자식에게 위임
                           └──────────────┘
```

### ✅ 3. 현실 예시

- **파일 시스템**: 파일(Leaf) vs 폴더(Composite)
- **GUI 컴포넌트**: 버튼(Leaf) vs 패널(Composite)
- **조직도**: 직원(Leaf) vs 부서(Composite)

### ✅ 4. Java 예제: 파일 시스템 구조

#### 🔸 Component (공통 인터페이스)

```java
public interface FileComponent {
    void showInfo(String indent);
}
```

#### 🔸 Leaf

```java
public class FileLeaf implements FileComponent {
    private String name;

    public FileLeaf(String name) {
        this.name = name;
    }

    public void showInfo(String indent) {
        System.out.println(indent + "- 파일: " + name);
    }
}
```

#### 🔸 Composite

```java
import java.util.ArrayList;
import java.util.List;

public class DirectoryComposite implements FileComponent {
    private String name;
    private List<FileComponent> children = new ArrayList<>();

    public DirectoryComposite(String name) {
        this.name = name;
    }

    public void add(FileComponent component) {
        children.add(component);
    }

    public void remove(FileComponent component) {
        children.remove(component);
    }

    public void showInfo(String indent) {
        System.out.println(indent + "+ 폴더: " + name);
        for (FileComponent child : children) {
            child.showInfo(indent + "  ");
        }
    }
}
```

#### 🔸 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        FileComponent root = new DirectoryComposite("루트");
        FileComponent img = new DirectoryComposite("이미지");
        FileComponent doc = new DirectoryComposite("문서");

        img.add(new FileLeaf("photo.jpg"));
        doc.add(new FileLeaf("resume.pdf"));
        doc.add(new FileLeaf("report.docx"));

        root.add(img);
        root.add(doc);
        root.add(new FileLeaf("readme.txt"));

        root.showInfo(""); // 전체 트리 출력
    }
}
```

### ✅ 5. Python 예시 (간단 버전)

```python
class FileComponent:
    def show(self, indent=""): pass

class FileLeaf(FileComponent):
    def __init__(self, name):
        self.name = name

    def show(self, indent=""):
        print(indent + "- 파일:", self.name)

class DirectoryComposite(FileComponent):
    def __init__(self, name):
        self.name = name
        self.children = []

    def add(self, component):
        self.children.append(component)

    def show(self, indent=""):
        print(indent + "+ 폴더:", self.name)
        for child in self.children:
            child.show(indent + "  ")
```

### ✅ 6. 장점

| 장점                   | 설명                                               |
| ---------------------- | -------------------------------------------------- |
| 구조적 유연성 ↑        | 트리 구조에 적합, 구성 요소 간 계층 관계 표현 쉬움 |
| 클라이언트 코드 단순화 | Leaf/Composite 구분 없이 동일한 인터페이스 사용    |
| 재귀적 처리            | 트리 순회, 출력, 계산 등이 자연스러움              |

### ❌ 단점

| 단점                     | 설명                                            |
| ------------------------ | ----------------------------------------------- |
| 전체 구조 이해 어려움    | 중첩 구조가 깊어지면 디버깅 복잡                |
| 너무 범용적인 인터페이스 | Leaf에 필요 없는 메서드까지 정의하게 될 수 있음 |

### ✅ 7. Composite vs 다른 구조 패턴

| 패턴                        | 목적               | 특징                                 |
| --------------------------- | ------------------ | ------------------------------------ |
| **Composite**               | 트리 구조 표현     | Leaf와 Composite를 동일하게 사용     |
| **Decorator**               | 동적으로 기능 추가 | 계층 구조지만 목적은 “기능 덧붙이기” |
| **Bridge**                  | 추상과 구현 분리   | Tree 구조 아님, 계층 분리 중심       |
| **Chain of Responsibility** | 책임 전가          | 계층이지만 순차적 전달 구조          |

### ✅ 8. 실무 적용 예

| 분야            | 예시                                   |
| --------------- | -------------------------------------- |
| HTML DOM        | 태그 내부에 또 태그 (div > ul > li 등) |
| UI 구성         | 컴포넌트 → 패널 → 프레임               |
| 디렉터리 탐색기 | 폴더-파일 계층                         |
| 메뉴 시스템     | 메뉴 > 서브메뉴 > 항목                 |

### 🧠 마무리 요약

| 항목      | 내용                                                     |
| --------- | -------------------------------------------------------- |
| 정의      | **부분-전체 트리 구조에서 Leaf와 Group을 동일하게 처리** |
| 핵심 구조 | `Component ↔ Leaf`, `Composite → children 구성`          |
| 장점      | 트리 구조 표현, 재귀적 처리, 코드 단순화                 |
| 사용 시점 | 복합 구조를 클라이언트가 재귀적으로 처리해야 할 때       |

## 2.4 Decorator (데코레이터)

- 객체에 **기능을 동적으로 추가**
- 상속 대신 조합으로 확장
- 예: `BufferedInputStream`, `@Transactional`

### ✅ Decorator 패턴이란?

> **기존 객체를 변경하지 않고, 런타임에 기능을 동적으로 추가**할 수 있도록 하는 구조 패턴
>  즉, **상속 없이 기능을 확장하고 싶을 때 사용하는 패턴**

### ✅ 1. 언제 쓰는가? (적용 목적)

| 상황                            | 설명                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 기능 조합이 많아질 때           | 상속으로 모든 조합 만들기 어려움 → 데코레이터로 유연하게 조합 |
| 클래스 수정이 불가능할 때       | 이미 배포된 라이브러리 등                                    |
| 실행 중 기능을 덧붙이고 싶을 때 | 런타임에 기능을 조절하고 확장해야 할 때                      |

### ✅ 2. 구조 (UML)

```
        ┌──────────────┐
        │  Component   │ ← 공통 인터페이스
        └─────┬────────┘
              │
   ┌──────────┴────────────┐
   ▼                       ▼
ConcreteComponent      Decorator (추상)
                          │
                ┌─────────┴────────┐
                ▼                  ▼
       ConcreteDecoratorA   ConcreteDecoratorB
```

### ✅ 3. 동작 방식 요약

- **Component**: 공통 인터페이스 정의
- **ConcreteComponent**: 기본 기능 구현
- **Decorator**: Component를 구현하고, 내부에 Component를 포함
- **ConcreteDecorator**: 실제로 기능을 덧붙이는 클래스

### ✅ 4. Java 예제: 메시지 포맷터

#### 🔸 Component

```java
public interface Message {
    String getContent();
}
```

#### 🔸 ConcreteComponent

```java
public class TextMessage implements Message {
    private String content;

    public TextMessage(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }
}
```

#### 🔸 Decorator (추상 클래스)

```java
public abstract class MessageDecorator implements Message {
    protected Message message;

    public MessageDecorator(Message message) {
        this.message = message;
    }
}
```

#### 🔸 ConcreteDecoratorA: HTML 태그로 감싸기

```java
public class HtmlDecorator extends MessageDecorator {
    public HtmlDecorator(Message message) {
        super(message);
    }

    public String getContent() {
        return "<html>" + message.getContent() + "</html>";
    }
}
```

#### 🔸 ConcreteDecoratorB: 암호화

```java
public class EncryptionDecorator extends MessageDecorator {
    public EncryptionDecorator(Message message) {
        super(message);
    }

    public String getContent() {
        return encrypt(message.getContent());
    }

    private String encrypt(String msg) {
        return new StringBuilder(msg).reverse().toString(); // 단순 반전
    }
}
```

#### 🔸 사용 예

```java
public class Client {
    public static void main(String[] args) {
        Message msg = new TextMessage("안녕하세요");

        Message html = new HtmlDecorator(msg);
        Message encrypted = new EncryptionDecorator(html);

        System.out.println(encrypted.getContent()); // >lmth/<요세하녕안><html>
    }
}
```

### ✅ 5. Python 예시

```python
class Message:
    def get_content(self): pass

class TextMessage(Message):
    def __init__(self, content):
        self.content = content

    def get_content(self):
        return self.content

class Decorator(Message):
    def __init__(self, msg):
        self.msg = msg

class HtmlDecorator(Decorator):
    def get_content(self):
        return f"<html>{self.msg.get_content()}</html>"

class EncryptDecorator(Decorator):
    def get_content(self):
        return self.msg.get_content()[::-1]

# 사용
msg = TextMessage("Hello")
decorated = EncryptDecorator(HtmlDecorator(msg))
print(decorated.get_content())  # >lmth<olleH>html<
```

### ✅ 6. 실무 활용 예시

| 분야               | 적용 사례                                             |
| ------------------ | ----------------------------------------------------- |
| **Java I/O**       | `InputStream → BufferedInputStream → GZIPInputStream` |
| **스프링 AOP**     | 프록시 기반 메서드 감싸기                             |
| **HTTP 필터 체인** | 요청/응답에 기능을 덧붙이면서 연결                    |
| **GUI 컴포넌트**   | 테두리, 스크롤바, 그림자 등 기능 계층적 조합          |

### ✅ 7. 장점

| 장점                | 설명                                          |
| ------------------- | --------------------------------------------- |
| 상속 없이 기능 확장 | 클래스 계층 없이 기능을 유연하게 붙일 수 있음 |
| 조합 가능           | 데코레이터를 중첩해서 다단계 기능 제공 가능   |
| OCP 만족            | 기존 코드 변경 없이 기능 확장 가능            |

### ❌ 단점

| 단점                                    | 설명                                         |
| --------------------------------------- | -------------------------------------------- |
| 디버깅 어려움                           | 여러 개가 중첩되면 어떤 순서인지 추적 어려움 |
| 클래스 수 증가                          | 데코레이터 수가 많아지면 구조 복잡           |
| Client가 내부 구조 모르면 사용이 어려움 | 어떤 데코레이터를 적용했는지 파악해야 함     |

### ✅ 8. 데코레이터 vs 관련 패턴

| 비교 대상     | 차이점                      |
| ------------- | --------------------------- |
| **Adapter**   | 인터페이스 변환             |
| **Composite** | 트리 구조                   |
| **Proxy**     | 객체 접근 제어 (보안, 캐싱) |
| **Decorator** | 기능을 확장                 |

### 🧠 마무리 요약

| 항목 | 내용                                            |
| ---- | ----------------------------------------------- |
| 정의 | **객체를 감싸 기능을 동적으로 추가**하는 패턴   |
| 구조 | `Component ↔ Decorator` 계층 + 내부 위임        |
| 목적 | 상속 대신 조합으로 기능 확장                    |
| 실전 | I/O 스트림, AOP, GUI 효과 조합                  |
| 특징 | 중첩 가능, 코드 확장성 우수, 디버깅 난이도 높음 |

## 2.5 Facade (퍼사드)

- 복잡한 서브시스템을 단순화
- 하나의 인터페이스로 여러 컴포넌트 묶기

### ✅ Facade 패턴이란?

> 복잡한 서브시스템(여러 클래스, 모듈 등)을
>  **단순한 인터페이스 하나로 감싸**,
>  **클라이언트가 쉽게 사용할 수 있도록 만든 구조 패턴**

### ✅ 1. 왜 사용하는가? (목적)

| 목적              | 설명                                       |
| ----------------- | ------------------------------------------ |
| 서브시스템 단순화 | 복잡한 하위 로직 묶음에 단일 진입점 제공   |
| 클라이언트 단순화 | 내부 구조를 몰라도 쉽게 사용 가능          |
| 결합도 낮추기     | 변경에 유연하게 대응 가능 (중간 계층 역할) |

### ✅ 2. 구조 요약 (UML)

```
Client
   │
   ▼
┌────────┐
│ Facade │ ◄────────────┐
└────────┘              │
  │     │     │         ▼
  ▼     ▼     ▼     SubsystemA
SubA  SubB  SubC     SubsystemB
                     SubsystemC
```

- **Client**: 복잡한 서브시스템을 직접 호출 X
- **Facade**: 여러 서브시스템에 대한 단순화된 인터페이스 제공
- **Subsystem**: 실질적인 작업 수행

### ✅ 3. Java 예제: 홈시어터 시스템

#### 🔸 하위 시스템들

```java
public class Amplifier {
    public void on() { System.out.println("앰프 켬"); }
    public void off() { System.out.println("앰프 끔"); }
}

public class Projector {
    public void on() { System.out.println("프로젝터 켬"); }
    public void off() { System.out.println("프로젝터 끔"); }
}

public class StreamingPlayer {
    public void play(String movie) {
        System.out.println("영화 재생: " + movie);
    }
    public void stop() {
        System.out.println("재생 중지");
    }
}
```

#### 🔸 퍼사드 클래스

```java
public class HomeTheaterFacade {
    private Amplifier amp;
    private Projector projector;
    private StreamingPlayer player;

    public HomeTheaterFacade(Amplifier amp, Projector proj, StreamingPlayer player) {
        this.amp = amp;
        this.projector = proj;
        this.player = player;
    }

    public void watchMovie(String movie) {
        System.out.println("=== 영화 보기 시작 ===");
        amp.on();
        projector.on();
        player.play(movie);
    }

    public void endMovie() {
        System.out.println("=== 영화 종료 ===");
        player.stop();
        projector.off();
        amp.off();
    }
}
```

#### 🔸 클라이언트 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        Amplifier amp = new Amplifier();
        Projector proj = new Projector();
        StreamingPlayer player = new StreamingPlayer();

        HomeTheaterFacade home = new HomeTheaterFacade(amp, proj, player);

        home.watchMovie("Inception");
        home.endMovie();
    }
}
```

### ✅ 4. Python 예제 (간단 버전)

```python
class Amplifier:
    def on(self): print("앰프 켜짐")
    def off(self): print("앰프 꺼짐")

class Projector:
    def on(self): print("프로젝터 켜짐")
    def off(self): print("프로젝터 꺼짐")

class Player:
    def play(self, movie): print(f"{movie} 재생 중")
    def stop(self): print("재생 중지")

class HomeTheater:
    def __init__(self, amp, proj, player):
        self.amp = amp
        self.proj = proj
        self.player = player

    def start(self, movie):
        self.amp.on(); self.proj.on(); self.player.play(movie)

    def stop(self):
        self.player.stop(); self.proj.off(); self.amp.off()

# 사용
facade = HomeTheater(Amplifier(), Projector(), Player())
facade.start("Interstellar")
facade.stop()
```

### ✅ 5. 실무 활용 예

| 분야                 | 예시                                                         |
| -------------------- | ------------------------------------------------------------ |
| **스프링 Framework** | `JdbcTemplate`, `RestTemplate`, `WebClient` 모두 내부 복잡한 로직 감쌈 |
| **JPA/Hibernate**    | `EntityManager` → SQL, 트랜잭션, flush 등 복잡한 기능 포장   |
| **AWS SDK Wrapper**  | S3, EC2 등 여러 API 호출을 하나의 서비스로 감싸는 래퍼       |
| **UI 라이브러리**    | `DialogHelper.showLoading()`, `PopupHelper.showConfirm()` 등 복잡한 로직 단순화 |

### ✅ 6. 장점

| 장점                               | 설명                              |
| ---------------------------------- | --------------------------------- |
| 서브시스템 캡슐화                  | 내부 구조 숨김으로 유지보수 유리  |
| 사용 편의성 향상                   | 단순한 API 제공으로 진입장벽 낮춤 |
| 클라이언트와 시스템 간 결합도 낮춤 | 변경에도 영향 최소화              |

### ❌ 단점

| 단점                                                         | 설명 |
| ------------------------------------------------------------ | ---- |
| 너무 많은 기능 위임시 "하나의 거대한 God 클래스" 가능성      |      |
| 퍼사드에 너무 의존하면 내부 기능을 세밀하게 사용하지 못함 (유연성 저하) |      |

### ✅ 7. Facade vs 관련 패턴

| 비교 대상     | Facade               | 다른 패턴                  |
| ------------- | -------------------- | -------------------------- |
| **Adapter**   | 인터페이스 변환 목적 | 사용 방식 호환성 중시      |
| **Decorator** | 기능 확장 목적       | 기존 객체에 새 기능 덧붙임 |
| **Proxy**     | 접근 제어 목적       | 기능은 유지하되 제어만 함  |
| **Facade**    | 복잡한 시스템 단순화 | 내부 구현 다수 묶어 제공   |

### 🧠 마무리 요약

| 항목      | 내용                                                  |
| --------- | ----------------------------------------------------- |
| 정의      | **복잡한 서브시스템을 감싸는 단순한 인터페이스** 제공 |
| 구조      | Client → Facade → Subsystems                          |
| 핵심 장점 | 캡슐화, 결합도↓, 사용성↑                              |
| 사용 조건 | 내부 모듈 수가 많고, 이를 일괄 처리할 필요가 있을 때  |

## 2.6 Flyweight (플라이웨이트)

- 동일한 객체를 **공유**해서 메모리 절약
- 예: 텍스트 에디터에서 글자 객체 공유

### ✅ Flyweight 패턴이란?

> **객체를 공유해서 메모리 사용을 최소화**하는 구조 패턴
>  즉, **수많은 유사 객체를 효율적으로 관리**할 수 있도록
>  **공통 속성(불변, intrinsic)을 공유하고**,
>  **다른 속성(외부, extrinsic)은 외부에서 주입하는 방식**

### ✅ 1. 왜 사용하는가? (목적)

| 목적                                               | 설명                                                    |
| -------------------------------------------------- | ------------------------------------------------------- |
| 대규모 객체를 수천 개 이상 만들 경우 메모리 최적화 | 게임에서 수천 개의 나무, 문자 처리 등                   |
| 공통 속성 공유                                     | 동일한 형태의 객체를 반복 생성하지 않고 캐싱해서 재사용 |
| 성능 향상                                          | 객체 수를 줄여 GC 부담 감소                             |

### ✅ 2. 구성 요소 (핵심 구조)

| 구성                            | 설명                                        |
| ------------------------------- | ------------------------------------------- |
| **Flyweight (공통 인터페이스)** | 공유 가능한 객체의 인터페이스               |
| **ConcreteFlyweight**           | 내부 상태(intrinsic)를 가지며 재사용 가능   |
| **UnsharedFlyweight**           | 공유하지 않는 예외적 객체 (필요 시)         |
| **FlyweightFactory**            | Flyweight 객체를 생성하고 재사용하도록 관리 |
| **Client**                      | 외부 상태(extrinsic)를 전달하여 객체 사용   |

### ✅ 3. UML 구조

```
               Client
                 │
                 ▼
        ┌────────────────┐
        │ FlyweightFactory│
        └────────────────┘
                 │
      ┌──────────┼────────────┐
      ▼                       ▼
ConcreteFlyweightA    ConcreteFlyweightB
    ▲     ▲                 ▲
    │     │                 │
  내부 상태 공유     외부 상태는 Client가 전달
```

### ✅ 4. 핵심 개념: 내부 vs 외부 상태

| 구분                      | 설명                    | 예시                      |
| ------------------------- | ----------------------- | ------------------------- |
| **Intrinsic (내부 상태)** | 공유 가능한 불변 데이터 | 나무의 종류, 색상, 크기   |
| **Extrinsic (외부 상태)** | 매번 입력받는 개별 속성 | 위치(x, y), 방향, 상태 등 |

### ✅ 5. Java 예제: 나무(Tree) 렌더링 시뮬레이션

#### 🔸 Flyweight 인터페이스

```java
public interface TreeType {
    void render(int x, int y);
}
```

#### 🔸 ConcreteFlyweight

```java
public class TreeTypeImpl implements TreeType {
    private String name;
    private String color;
    private String texture;

    public TreeTypeImpl(String name, String color, String texture) {
        this.name = name;
        this.color = color;
        this.texture = texture;
    }

    public void render(int x, int y) {
        System.out.printf("(%d,%d) 위치에 [%s/%s] 나무 렌더링\n", x, y, name, color);
    }
}
```

#### 🔸 FlyweightFactory

```java
import java.util.*;

public class TreeFactory {
    private static final Map<String, TreeType> pool = new HashMap<>();

    public static TreeType getTreeType(String name, String color, String texture) {
        String key = name + color + texture;
        if (!pool.containsKey(key)) {
            pool.put(key, new TreeTypeImpl(name, color, texture));
        }
        return pool.get(key);
    }
}
```

#### 🔸 Client 사용 예시

```java
public class Forest {
    public static void main(String[] args) {
        TreeType oak = TreeFactory.getTreeType("Oak", "Green", "Rough");
        TreeType pine = TreeFactory.getTreeType("Pine", "DarkGreen", "Smooth");

        oak.render(10, 20);  // extrinsic (x, y)
        pine.render(15, 25);
        oak.render(100, 200);
    }
}
```

> 🧠 결과적으로 같은 TreeType 객체가 1개만 생성되어 여러 좌표에서 재사용됨

### ✅ 6. Python 예시 (간단)

```python
class TreeType:
    def __init__(self, name, color, texture):
        self.name = name
        self.color = color
        self.texture = texture

    def render(self, x, y):
        print(f"({x},{y}) 위치에 {self.name} 나무 [{self.color}] 렌더링")

class TreeFactory:
    _pool = {}

    @classmethod
    def get_tree(cls, name, color, texture):
        key = (name, color, texture)
        if key not in cls._pool:
            cls._pool[key] = TreeType(name, color, texture)
        return cls._pool[key]

# 사용
for i in range(0, 10000, 1000):
    tree = TreeFactory.get_tree("Oak", "Green", "Rough")
    tree.render(i, i)
```

### ✅ 7. 장점

| 장점            | 설명                                |
| --------------- | ----------------------------------- |
| 메모리 절약     | 공통 속성 공유 → 객체 수 감소       |
| 성능 향상       | GC, 메모리 비용 절감                |
| 시스템 확장성 ↑ | 많은 객체 생성에도 시스템 유지 가능 |

### ❌ 단점

| 단점                            | 설명                                 |
| ------------------------------- | ------------------------------------ |
| 코드 복잡도 증가                | 내부/외부 상태 구분 필요             |
| 멀티스레드 환경에서 동기화 주의 | 공유 객체에 동시 접근 시 오류 가능   |
| 객체 관리 복잡                  | 캐싱 전략, 재사용 정책이 명확해야 함 |

### ✅ 8. 실무 활용 예

| 분야            | 적용 예시                                |
| --------------- | ---------------------------------------- |
| **게임 엔진**   | 몬스터, 배경 나무, 총알 등 반복되는 개체 |
| **폰트 렌더링** | 자주 사용하는 글자 Glyph 객체 재사용     |
| **문서 편집기** | 스타일 정보 공유 (폰트, 크기, 색상 등)   |
| **지도 앱**     | 마커, 라벨 아이콘, 도형 공유             |

### ✅ 9. Flyweight vs Singleton vs Prototype

| 패턴          | 목적                  | 공유 여부     | 인스턴스 수           |
| ------------- | --------------------- | ------------- | --------------------- |
| **Flyweight** | 다수의 유사 객체 공유 | ✅             | 여러 개 (유형별 1개)  |
| **Singleton** | 전역 단일 인스턴스    | ✅             | 오직 1개              |
| **Prototype** | 객체 복제             | ❌ (개별 복사) | 복제할 때마다 새 객체 |

### 🧠 마무리 요약

| 항목        | 설명                                              |
| ----------- | ------------------------------------------------- |
| 정의        | **공통 속성을 공유하여 메모리 절약**하는 패턴     |
| 핵심 개념   | 내부 상태 공유, 외부 상태는 클라이언트가 제공     |
| 추천 사용처 | 수천~수만 개 객체 생성되는 상황                   |
| 구조        | `Client ↔ FlyweightFactory ↔ Flyweight 객체 공유` |

## 2.7 Proxy (프록시)

- 대상 객체를 **대신 사용하는 대리자**
- 예: 가상 프록시, 보안 프록시, RPC 프록시

### ✅ Proxy 패턴이란?

> 어떤 객체에 대한 **접근을 제어**하기 위해
>  **그 객체의 대리자(프록시)를 제공**하는 디자인 패턴.

즉, **진짜 객체 대신 Proxy 객체를 통해 접근**하고,
 그 과정에서 **추가 기능, 보안, 지연 처리, 로깅, 캐싱** 등을 수행할 수 있음.

### ✅ 1. 왜 사용하는가? (목적)

| 목적                   | 설명                                          |
| ---------------------- | --------------------------------------------- |
| 객체 생성 비용이 클 때 | 필요한 순간에만 실제 객체 생성 (Lazy Loading) |
| 접근 통제              | 보안 또는 권한 제어 목적                      |
| 로깅/캐싱              | 호출 전후의 작업 수행                         |
| 원격 통신              | 네트워크 넘어 있는 객체를 로컬처럼 사용       |

### ✅ 2. 구성 요소 (UML 구조)

```
Client
  │
  ▼
┌────────┐       implements       ┌────────────┐
│ Proxy  │ ─────────────────────▶ │ Subject     │
└────────┘                        └────────────┘
   │    ▲                            ▲
   ▼    │                            │
┌────────────┐            ┌──────────────────┐
│ RealSubject│◄───────────┘  (Concrete 구현) │
└────────────┘
```

- **Subject**: 공통 인터페이스 (Real + Proxy 모두 구현)
- **RealSubject**: 실제 작업을 수행하는 객체
- **Proxy**: RealSubject에 대한 접근을 대신 처리

### ✅ 3. Proxy 패턴의 유형

| 유형              | 설명                                 | 예시                     |
| ----------------- | ------------------------------------ | ------------------------ |
| **가상 프록시**   | 실제 객체 생성을 지연 (Lazy loading) | 이미지 로딩, 대형 문서   |
| **보호 프록시**   | 접근 권한 제어                       | 관리자 전용 페이지       |
| **원격 프록시**   | 네트워크 너머의 객체를 로컬처럼      | RMI, gRPC                |
| **스마트 프록시** | 사용량 측정, 로깅, 참조 카운팅       | 캐시 프록시, 로그 프록시 |

### ✅ 4. Java 예제: 가상 프록시

#### 🔸 Subject 인터페이스

```java
public interface Image {
    void display();
}
```

#### 🔸 RealSubject

```java
public class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk(); // 비용이 큰 작업
    }

    private void loadFromDisk() {
        System.out.println("이미지 로딩: " + filename);
    }

    public void display() {
        System.out.println("이미지 표시: " + filename);
    }
}
```

#### 🔸 Proxy

```java
public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // 실제 객체 생성
        }
        realImage.display();
    }
}
```

#### 🔸 클라이언트 사용

```java
public class Client {
    public static void main(String[] args) {
        Image image = new ProxyImage("sample.png");

        System.out.println("프록시 생성 완료. 아직 로딩 X");
        image.display(); // 로딩 발생
        image.display(); // 캐싱된 객체 사용
    }
}
```

### ✅ 5. Python 예시 (가상 프록시)

```python
class RealImage:
    def __init__(self, filename):
        self.filename = filename
        self.load()

    def load(self):
        print(f"이미지 로딩: {self.filename}")

    def display(self):
        print(f"이미지 표시: {self.filename}")

class ProxyImage:
    def __init__(self, filename):
        self.filename = filename
        self.real = None

    def display(self):
        if not self.real:
            self.real = RealImage(self.filename)
        self.real.display()

# 사용
img = ProxyImage("cat.jpg")
print("프록시 생성됨")
img.display()
img.display()
```

### ✅ 6. 실무 활용 예

| 분야                           | 예시                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **Spring AOP**                 | 프록시 기반으로 `@Transactional`, `@Cacheable`, `@Loggable` 적용 |
| **MyBatis / JPA Lazy Loading** | 연관 객체를 프록시로 감싸고, 필요 시 로딩                    |
| **보안 인증**                  | API 요청 프록시에서 인증 검사                                |
| **RPC / RMI**                  | Stub-Proxy 패턴으로 원격 객체 호출                           |

### ✅ 7. 장점

| 장점                                 | 설명                                              |
| ------------------------------------ | ------------------------------------------------- |
| 접근 제어                            | 보안, 인증, 제한된 권한 등 구현 가능              |
| Lazy Loading                         | 무거운 객체의 지연 생성 처리 가능                 |
| 기능 확장 용이                       | 로깅, 트래픽 제어, 모니터링 등 부가기능 삽입 용이 |
| 클라이언트는 RealSubject를 몰라도 됨 | 프록시와 같은 인터페이스 사용                     |

### ❌ 단점

| 단점                  | 설명                                 |
| --------------------- | ------------------------------------ |
| 구조 복잡도 증가      | Real + Proxy + Interface 구성 필요   |
| 프록시 객체 관리 부담 | 캐싱, 동기화, 참조 누수 등 주의 필요 |
| 성능 오버헤드         | 중간 경유 계층이 늘어남              |

### ✅ 8. Proxy vs Decorator vs Facade 비교

| 항목            | Proxy                        | Decorator               | Facade                     |
| --------------- | ---------------------------- | ----------------------- | -------------------------- |
| 목적            | **접근 제어 또는 대리 실행** | **기능 확장**           | **서브시스템 단순화**      |
| 클라이언트 입장 | 실제 객체처럼 보임           | 실제 객체에 기능 추가됨 | 서브시스템을 감싼 단일 API |
| 구조            | 인터페이스 공유              | 인터페이스 공유         | 완전히 새로운 진입점       |

### 🧠 마무리 요약

| 항목        | 내용                                                    |
| ----------- | ------------------------------------------------------- |
| 정의        | **진짜 객체에 대한 접근을 대리자 객체가 통제**하는 패턴 |
| 목적        | 접근 제어, 지연 로딩, 보안, 원격 호출 등                |
| 구조        | `Client → Proxy → RealSubject` (모두 같은 인터페이스)   |
| 활용 분야   | Spring AOP, ORM Lazy Loading, API 접근 제어, 캐시 서버  |
| 추천 사용처 | 성능 부담 크거나, 접근을 통제해야 하는 객체에 적합      |

## 🧱 3. **행위 패턴 (Behavioral)**

## 3.1 Chain of Responsibility (책임 연쇄)

- 요청을 처리할 수 있는 객체를 **연결 리스트로 연결**
- 예: 필터 체인, 인터셉터

### ✅ Chain of Responsibility 패턴이란?

> 요청을 처리할 수 있는 **여러 객체들을 체인처럼 연결**하고,
>  요청이 발생하면 **처리 가능한 객체가 책임을 맡도록 전달**하는 구조의 디자인 패턴.

즉, **하나의 요청을 여러 핸들러 중 하나가 처리**하며,
 처리할 수 없으면 **다음 핸들러로 넘기는 방식**.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                  | 설명                                                    |
| --------------------- | ------------------------------------------------------- |
| 요청 처리 로직을 분리 | 어떤 객체가 처리할지는 런타임까지 결정될 수 있도록 위임 |
| 유연한 책임 전가      | 조건에 따라 다른 객체가 처리하도록 체인 구성            |
| 조건 기반 다단계 처리 | 승인, 검증, 필터, 에러 처리 등 순차적 흐름 처리         |

### ✅ 2. 구조 (UML)

```
         Client
           │
           ▼
    ┌─────────────┐
    │  Handler     │ ◄─── 추상 클래스 or 인터페이스
    ├─────────────┤
    │+setNext()   │
    │+handle()    │
    └────┬────────┘
         ▼
 ┌──────────────┐
 │ HandlerA     │
 └──────────────┘
         ▼
 ┌──────────────┐
 │ HandlerB     │
 └──────────────┘
         ▼
 ┌──────────────┐
 │ HandlerC     │
 └──────────────┘
```

### ✅ 3. 흐름 요약

1. **Client**는 요청을 체인의 첫 번째 핸들러에 전달함
2. 각 핸들러는 요청을 **처리하거나**, 다음 핸들러에게 **위임**
3. 어느 핸들러도 처리하지 못하면 체인의 끝에서 종료됨

### ✅ 4. Java 예제: 권한 요청 승인 체인

#### 🔸 Handler 인터페이스

```java
public abstract class Approver {
    protected Approver next;

    public void setNext(Approver next) {
        this.next = next;
    }

    public void handleRequest(int amount) {
        if (next != null) {
            next.handleRequest(amount);
        }
    }
}
```

#### 🔸 ConcreteHandler

```java
public class Manager extends Approver {
    public void handleRequest(int amount) {
        if (amount <= 1000) {
            System.out.println("매니저 승인 완료: " + amount);
        } else {
            super.handleRequest(amount);
        }
    }
}

public class Director extends Approver {
    public void handleRequest(int amount) {
        if (amount <= 5000) {
            System.out.println("이사 승인 완료: " + amount);
        } else {
            super.handleRequest(amount);
        }
    }
}

public class CEO extends Approver {
    public void handleRequest(int amount) {
        System.out.println("CEO 최종 승인: " + amount);
    }
}
```

#### 🔸 클라이언트 코드

```java
public class Client {
    public static void main(String[] args) {
        Approver manager = new Manager();
        Approver director = new Director();
        Approver ceo = new CEO();

        manager.setNext(director);
        director.setNext(ceo);

        manager.handleRequest(500);     // Manager
        manager.handleRequest(3000);    // Director
        manager.handleRequest(8000);    // CEO
    }
}
```

### ✅ 5. Python 예시 (간단)

```python
class Handler:
    def __init__(self, next_handler=None):
        self.next = next_handler

    def handle(self, level):
        if self.next:
            self.next.handle(level)

class TeamLead(Handler):
    def handle(self, level):
        if level <= 1:
            print("팀장이 처리")
        else:
            super().handle(level)

class Manager(Handler):
    def handle(self, level):
        if level <= 2:
            print("매니저가 처리")
        else:
            super().handle(level)

class CEO(Handler):
    def handle(self, level):
        print("CEO가 처리")

# 체인 연결
chain = TeamLead(Manager(CEO()))
chain.handle(1)  # 팀장
chain.handle(2)  # 매니저
chain.handle(3)  # CEO
```

### ✅ 6. 실무 활용 예

| 분야                | 적용 사례                               |
| ------------------- | --------------------------------------- |
| **웹 필터 체인**    | 인증 → 권한 → 로깅 → 캐싱 순으로 처리   |
| **GUI 이벤트 처리** | 이벤트 버블링: 자식 → 부모 → 조상 위임  |
| **에러 핸들링**     | 예외 유형에 따라 적절한 핸들러에게 위임 |
| **결재 프로세스**   | 팀장 → 부장 → 이사 → 사장 승인          |

### ✅ 7. 장점

| 장점              | 설명                                         |
| ----------------- | -------------------------------------------- |
| 책임 분리         | 각 처리 로직이 별도 클래스로 분리됨          |
| 유연한 확장       | 핸들러 추가/제거/순서 변경이 쉬움            |
| 클라이언트 단순화 | 누가 처리할지 몰라도 체인의 시작점만 알면 됨 |

### ❌ 단점

| 단점                  | 설명                                            |
| --------------------- | ----------------------------------------------- |
| 디버깅 어려움         | 어떤 핸들러가 실제로 처리했는지 추적 어려움     |
| 요청이 누락될 수 있음 | 어느 핸들러도 처리하지 않으면 silent fail 발생  |
| 순서 중요             | 체인 순서를 잘못 구성하면 잘못된 결과 발생 가능 |

### ✅ 8. 관련 패턴 비교

| 패턴                        | 목적                   | 비교 포인트                          |
| --------------------------- | ---------------------- | ------------------------------------ |
| **Chain of Responsibility** | 책임을 연쇄적으로 전달 | 처리자가 여러 명, 순서대로 요청 전달 |
| **Command**                 | 요청을 객체로 캡슐화   | 실행/취소/저장 기능 중심             |
| **Observer**                | 이벤트 전파            | 여러 리스너에게 알림 (브로드캐스트)  |
| **Decorator**               | 기능 확장              | 기능을 누적 조립 (요청 전달은 유사)  |

### 🧠 마무리 요약 | Chain of Responsibility Pattern

| 항목          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 요청을 처리할 수 있는 객체들을 연결한 **체인 구조**로, 요청이 처리될 때까지 **다음 객체로 전달**되는 패턴 |
| **구조**      | `Handler → next → next → ...` (각 핸들러는 다음 핸들러로 요청을 전달함) |
| **사용 시점** | 다단계 승인 처리, GUI 이벤트 전파, 필터 체인 (Spring Filter, Servlet Filter 등) |
| **장점**      | 처리 책임이 분리되어 **유연한 확장**이 가능하며, **클라이언트 코드가 단순화**됨 |
| **주의점**    | 체인 구성 순서가 중요하고, **처리 누락 가능성** 있음 (모든 핸들러가 실패할 수 있음) |

## 3.2 Command (커맨드)

- 요청을 **객체로 캡슐화**, 실행 취소 / 큐 처리
- 예: Ctrl+Z, Undo 기능

### ✅ 1. 목적 (언제 쓰는가?)

| 목적             | 설명                               |
| ---------------- | ---------------------------------- |
| 요청을 캡슐화    | 요청, 실행자, 인자들을 객체로 포장 |
| 실행 취소/재실행 | 요청 기록 및 되돌리기 가능         |
| 큐잉/로그 처리   | 명령 저장, 스케줄링 가능           |
| 요청과 실행 분리 | 클라이언트와 실행 로직을 완전 분리 |

### ✅ 2. 구조 (UML)

```
Client
  │
  ▼
Invoker ──▶ Command ──▶ Receiver
              │
      + execute()
```

| 구성요소            | 설명                                 |
| ------------------- | ------------------------------------ |
| **Command**         | 실행 명령을 정의하는 인터페이스      |
| **ConcreteCommand** | 실제 실행 로직을 포함                |
| **Receiver**        | 명령을 수행하는 실제 대상            |
| **Invoker**         | 명령을 보관하고 실행하는 객체        |
| **Client**          | Command 객체를 생성해 Invoker에 전달 |

### ✅ 3. Java 예제: 리모컨 제어

#### 🔸 Receiver (실제 동작 주체)

```java
public class Light {
    public void on() {
        System.out.println("💡 불 켜짐");
    }
    public void off() {
        System.out.println("💡 불 꺼짐");
    }
}
```

#### 🔸 Command 인터페이스

```java
public interface Command {
    void execute();
}
```

#### 🔸 ConcreteCommand

```java
public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.on();
    }
}

public class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.off();
    }
}
```

#### 🔸 Invoker (리모컨)

```java
public class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        Light light = new Light();

        Command on = new LightOnCommand(light);
        Command off = new LightOffCommand(light);

        RemoteControl remote = new RemoteControl();

        remote.setCommand(on);
        remote.pressButton(); // 💡 불 켜짐

        remote.setCommand(off);
        remote.pressButton(); // 💡 불 꺼짐
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Light:
    def on(self): print("💡 불 켜짐")
    def off(self): print("💡 불 꺼짐")

class Command:
    def execute(self): pass

class LightOnCommand(Command):
    def __init__(self, light): self.light = light
    def execute(self): self.light.on()

class LightOffCommand(Command):
    def __init__(self, light): self.light = light
    def execute(self): self.light.off()

class RemoteControl:
    def set_command(self, cmd): self.cmd = cmd
    def press_button(self): self.cmd.execute()

# 사용
light = Light()
on = LightOnCommand(light)
off = LightOffCommand(light)
remote = RemoteControl()

remote.set_command(on); remote.press_button()
remote.set_command(off); remote.press_button()
```

### ✅ 5. 실무 활용 예시

| 분야                   | 예시                                   |
| ---------------------- | -------------------------------------- |
| **UI 버튼 동작**       | 버튼 클릭 시 Command 객체 실행         |
| **Undo/Redo 시스템**   | 실행 기록을 저장하여 `undo()` 가능     |
| **매크로 실행**        | 여러 Command 조합으로 복잡한 동작 수행 |
| **네트워크 요청 큐잉** | Command를 큐에 넣고 순차 처리          |
| **스케줄러**           | 명령을 시간에 따라 실행                |

### ✅ 6. 장점

| 장점                   | 설명                                          |
| ---------------------- | --------------------------------------------- |
| 실행과 요청 분리       | 클라이언트는 실행 대상 몰라도 됨              |
| 취소, 재실행 구현 용이 | `undo()` 구현 시 효과적                       |
| 커맨드 큐 구현 가능    | 요청을 저장하고 순서대로 실행 가능            |
| 확장 용이              | 새로운 명령 추가 시 기존 코드 수정 없음 (OCP) |

### ❌ 단점

| 단점           | 설명                         |
| -------------- | ---------------------------- |
| 클래스 수 증가 | 명령마다 별도 클래스 필요    |
| 구조 복잡      | 간단한 작업에는 과할 수 있음 |

### ✅ 7. Command vs Strategy vs Observer

| 비교 대상    | 목적               | 구조 특징                    |
| ------------ | ------------------ | ---------------------------- |
| **Command**  | 요청 캡슐화 → 실행 | 실행 대상과 분리             |
| **Strategy** | 알고리즘 교체      | 실행 자체는 즉시 실행        |
| **Observer** | 이벤트 전파        | 등록된 객체에게 브로드캐스트 |

### 🧠 마무리 요약

| 항목          | 내용                                                        |
| ------------- | ----------------------------------------------------------- |
| **정의**      | **요청을 객체로 캡슐화**하여 실행, 취소, 큐잉이 가능한 구조 |
| **핵심 구성** | `Command ↔ Receiver`, `Invoker`는 명령을 실행               |
| **장점**      | 요청/실행 분리, undo/redo 가능, 큐/로그/스케줄링 적용 가능  |
| **단점**      | 클래스 수 증가, 단순 작업에 과도할 수 있음                  |
| **사용처**    | 리모컨 제어, GUI 이벤트 처리, 매크로, 트랜잭션 실행 기록 등 |

## 3.3 Interpreter (인터프리터)

- 언어 문법을 클래스 구조로 구현
- 예: 정규표현식 파서

### ✅ Interpreter 패턴이란?

> **언어(문법)를 객체화하여**,
>  해당 언어의 **문장을 해석(interpret)**하는 구조를 정의하는 패턴
>  즉, **작은 도메인 언어(DSL)**를 정의하고 해석할 수 있는 구조를 만드는 것

### ✅ 1. 언제 사용하는가? (목적)

| 목적                | 설명                                  |
| ------------------- | ------------------------------------- |
| 표현식 계산         | 수식 계산기, 논리 연산 해석 등        |
| DSL 해석            | 특정 분야에 특화된 언어의 해석기 구현 |
| 문법 기반 로직 표현 | 규칙, 조건, 명령을 문장 구조로 해석   |

### ✅ 2. 구조 (UML)

```
    ┌──────────────┐
    │ AbstractExpr │◄────────────┐
    └──────┬───────┘             │
           │                    │
  ┌────────▼────────┐   ┌───────▼───────┐
  │ TerminalExpr    │   │ NonTerminalExpr│
  └────────┬────────┘   └───────┬────────┘
           │                    │
         interpret()          interpret()
                               (다른 Expr 조합)

         ┌──────────────┐
         │   Context    │ ← 문자열, 변수, 결과 저장소
         └──────────────┘
```

| 요소                      | 설명                                         |
| ------------------------- | -------------------------------------------- |
| **Context**               | 해석에 필요한 정보 저장 (문자열, 변수 맵 등) |
| **AbstractExpression**    | 모든 표현식의 공통 인터페이스                |
| **TerminalExpression**    | 더 이상 쪼갤 수 없는 단말 표현식             |
| **NonTerminalExpression** | 다른 표현식들을 조합해서 해석하는 구성식     |

### ✅ 3. 간단 예시: Boolean 수식 해석기

> 예: "true OR false AND false"를 해석

### ✅ 4. Java 예제

#### 🔸 Expression 인터페이스

```java
public interface Expression {
    boolean interpret();
}
```

#### 🔸 TerminalExpression

```java
public class BoolLiteral implements Expression {
    private final boolean value;

    public BoolLiteral(boolean value) {
        this.value = value;
    }

    public boolean interpret() {
        return value;
    }
}
```

#### 🔸 NonTerminalExpression

```java
public class AndExpr implements Expression {
    private Expression left, right;

    public AndExpr(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    public boolean interpret() {
        return left.interpret() && right.interpret();
    }
}

public class OrExpr implements Expression {
    private Expression left, right;

    public OrExpr(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    public boolean interpret() {
        return left.interpret() || right.interpret();
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        // (true OR false) AND false
        Expression expr = new AndExpr(
            new OrExpr(
                new BoolLiteral(true),
                new BoolLiteral(false)
            ),
            new BoolLiteral(false)
        );

        System.out.println(expr.interpret()); // false
    }
}
```

### ✅ 5. Python 예시 (간단한 수식 해석기)

```python
class Expression:
    def interpret(self): pass

class Literal(Expression):
    def __init__(self, value): self.value = value
    def interpret(self): return self.value

class And(Expression):
    def __init__(self, left, right):
        self.left, self.right = left, right
    def interpret(self):
        return self.left.interpret() and self.right.interpret()

class Or(Expression):
    def __init__(self, left, right):
        self.left, self.right = left, right
    def interpret(self):
        return self.left.interpret() or self.right.interpret()

# 사용
expr = And(Or(Literal(True), Literal(False)), Literal(False))
print(expr.interpret())  # False
```

### ✅ 6. 실무 응용 사례

| 분야            | 예시                                                   |
| --------------- | ------------------------------------------------------ |
| 수식 계산기     | 계산기, 수학 파서                                      |
| SQL/정규식 파서 | WHERE 조건 해석기                                      |
| 텍스트 명령 DSL | 게임 AI, 챗봇 문법 해석                                |
| 정책 엔진       | 권한 조건 DSL (`user.is_admin AND resource.is_public`) |

### ✅ 7. 장점

| 장점                    | 설명                                        |
| ----------------------- | ------------------------------------------- |
| 문법을 객체화           | 문법 트리를 코드 구조로 표현 가능           |
| 확장성 ↑                | 새 문법 추가가 쉬움 (`And`, `Or`, `Not` 등) |
| 도메인 언어 설계에 유리 | Rule 기반 DSL 만들기 좋음                   |

### ❌ 단점

| 단점                   | 설명                                                |
| ---------------------- | --------------------------------------------------- |
| 성능 낮음              | 트리 구조가 커질수록 재귀적 해석 부담 ↑             |
| 복잡도 증가            | 문법 요소가 많아지면 클래스 수 증가                 |
| 문법이 복잡하면 부적합 | 정규식, 컴파일러 등에는 파서 제너레이터가 더 효율적 |

### ✅ 8. Interpreter vs Visitor vs Composite

| 패턴            | 역할                   | 비교                                    |
| --------------- | ---------------------- | --------------------------------------- |
| **Interpreter** | **문장을 해석**        | Expression Tree 기반                    |
| **Visitor**     | **노드마다 동작 분리** | Interpreter보다 연산 추가에 유리        |
| **Composite**   | **트리 구조 표현**     | Interpreter는 Composite를 기반으로 동작 |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | **언어의 문법 규칙을 클래스로 표현**하고, 해석 로직을 통해 실행 |
| **구성**      | Terminal/NonTerminal Expression + Context                    |
| **적용 시점** | 도메인 언어, 수식 해석기, 정책 시스템                        |
| **장점**      | 문법 객체화, DSL 구현, 확장성 우수                           |
| **단점**      | 느림, 복잡한 문법에 부적합, 클래스 수 증가                   |

## 3.4 Iterator (이터레이터)

- 집합 객체의 요소를 **순차적으로 접근**
- `hasNext()`, `next()`

### ✅ Iterator 패턴이란?

> 컬렉션 객체 내부 구조를 노출하지 않고,
>  그 **요소들을 순차적으로 접근할 수 있는 방법을 제공**하는 디자인 패턴

즉, `next()`, `hasNext()` 같은 방식으로
 **일관된 순회 인터페이스**를 제공하는 것

### ✅ 1. 왜 사용하는가? (목적)

| 목적                    | 설명                                                       |
| ----------------------- | ---------------------------------------------------------- |
| 컬렉션 구조 은닉        | 내부 구조를 노출하지 않고 순회                             |
| 다양한 컬렉션 순회 통일 | 배열, 리스트, 해시맵 등 다양한 구조를 동일한 방식으로 접근 |
| 커스터마이징 가능       | 역방향, 필터링 등 사용자 정의 순회도 가능                  |

### ✅ 2. 구조 (UML)

```
Client
  │
  ▼
Iterator ◄──────────── Aggregate
  │
  ▼
ConcreteIterator       ConcreteAggregate
```

| 구성요소              | 역할                                    |
| --------------------- | --------------------------------------- |
| **Aggregate**         | 컬렉션 인터페이스 (`createIterator()`)  |
| **ConcreteAggregate** | 실제 컬렉션                             |
| **Iterator**          | 순회 인터페이스 (`next()`, `hasNext()`) |
| **ConcreteIterator**  | 컬렉션 순회 구현체                      |

### ✅ 3. Java 예제: Book 컬렉션 순회

#### 🔸 Book 객체

```java
public class Book {
    private String title;

    public Book(String title) { this.title = title; }
    public String getTitle() { return title; }
}
```

#### 🔸 Iterator 인터페이스

```java
public interface Iterator {
    boolean hasNext();
    Object next();
}
```

#### 🔸 BookShelf (ConcreteAggregate)

```java
import java.util.ArrayList;

public class BookShelf {
    private ArrayList<Book> books = new ArrayList<>();

    public void addBook(Book book) {
        books.add(book);
    }

    public Book getBookAt(int index) {
        return books.get(index);
    }

    public int getLength() {
        return books.size();
    }

    public BookIterator iterator() {
        return new BookIterator(this);
    }
}
```

#### 🔸 BookIterator (ConcreteIterator)

```java
public class BookIterator implements Iterator {
    private BookShelf shelf;
    private int index = 0;

    public BookIterator(BookShelf shelf) {
        this.shelf = shelf;
    }

    public boolean hasNext() {
        return index < shelf.getLength();
    }

    public Object next() {
        return shelf.getBookAt(index++);
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        BookShelf shelf = new BookShelf();
        shelf.addBook(new Book("자바의 정석"));
        shelf.addBook(new Book("Effective Java"));

        Iterator it = shelf.iterator();
        while (it.hasNext()) {
            Book book = (Book) it.next();
            System.out.println(book.getTitle());
        }
    }
}
```

### ✅ 4. Python 예시 (Python은 기본적으로 지원)

```python
class Book:
    def __init__(self, title):
        self.title = title

class BookShelf:
    def __init__(self):
        self.books = []

    def add(self, book):
        self.books.append(book)

    def __iter__(self):
        return iter(self.books)

# 사용
shelf = BookShelf()
shelf.add(Book("Clean Code"))
shelf.add(Book("Design Patterns"))

for book in shelf:
    print(book.title)
```

### ✅ 5. 실무 활용 예

| 분야                    | 예시                                             |
| ----------------------- | ------------------------------------------------ |
| **Java Collection**     | `Iterator<E>` 인터페이스 (`next()`, `hasNext()`) |
| **Python for-loop**     | `__iter__()`와 `__next__()` 기반                 |
| **Cursor 기반 DB 탐색** | JDBC ResultSet, MongoDB Cursor                   |
| **파일/디렉터리 순회**  | Java `Files.walk()`, Python `os.walk()`          |

### ✅ 6. 장점

| 장점           | 설명                                     |
| -------------- | ---------------------------------------- |
| 캡슐화 유지    | 내부 구조를 노출하지 않고 순회           |
| 순회 방식 통일 | 다양한 컬렉션을 같은 방식으로 순회 가능  |
| 유연한 확장    | 역순, 필터링, 중첩 순회도 쉽게 구현 가능 |

### ❌ 단점

| 단점                                 | 설명                                            |
| ------------------------------------ | ----------------------------------------------- |
| 여러 이터레이터 동시 사용 시 주의    | 동일 컬렉션을 동시에 순회하면 충돌 가능         |
| 복잡한 순회 로직은 커스터마이징 필요 | 트리, 그래프 등은 일반 이터레이터로 처리 어려움 |

### ✅ 7. Iterator vs 다른 패턴

| 비교 대상     | 목적                  | 구조 차이                                |
| ------------- | --------------------- | ---------------------------------------- |
| **Iterator**  | 컬렉션 순회           | 컬렉션 구조 은닉                         |
| **Visitor**   | 구조 순회 + 기능 추가 | 방문 시점마다 행동 다르게                |
| **Composite** | 트리 구조 표현        | 트리와 순회 조합 시 이터레이터 사용 가능 |

### 🧠 마무리 요약

| 항목          | 내용                                                       |
| ------------- | ---------------------------------------------------------- |
| **정의**      | 컬렉션 요소를 **순차적으로 접근하는 방법을 제공**하는 패턴 |
| **핵심 요소** | `Iterator`, `Aggregate`                                    |
| **목적**      | 구조 은닉 + 순회 방식 통일                                 |
| **활용**      | for-loop, 컬렉션 순회, 데이터 커서                         |
| **장점**      | 일관된 순회, 구조 은닉, 확장 유연성                        |
| **단점**      | 순회 충돌, 비정형 자료구조에는 부적합                      |

## 3.5 Mediator (미디에이터)

- 객체 간 직접 통신 대신 **중재자(Mediator)**가 통제
- 예: 채팅방 관리

### ✅ Mediator 패턴이란?

> 객체 간 복잡한 **상호작용을 중재자(Mediator) 객체에 위임**하여,
>  객체들이 직접 서로를 참조하지 않고 **중앙 집중식 통신 구조**를 만드는 패턴

즉, **컴포넌트끼리 직접 통신하지 않고**
 **중간 관리자(Mediator)를 통해서만 상호작용**함.

### ✅ 1. 왜 사용하는가? (목적)

| 목적                             | 설명                                           |
| -------------------------------- | ---------------------------------------------- |
| 객체 간 의존도 감소              | 많은 객체가 서로 직접 참조하면 구조 복잡해짐   |
| 느슨한 결합                      | Mediator가 통제함으로써 객체 간 직접 연결 제거 |
| 복잡한 제어 흐름을 중앙에서 관리 | 변경, 확장, 테스트 용이                        |

### ✅ 2. 구조 (UML)

```
           ┌────────────┐
           │  Mediator  │◄────────────┐
           └─────┬──────┘             │
                 │                    │
        ┌────────▼────────┐   ┌───────▼────────┐
        │ ConcreteMediator │   │   Colleague    │
        └────────┬────────┘   └─────────────────┘
                 │                    ▲
        ┌────────▼──────┐     ┌───────┴────────┐
        │ ColleagueA    │     │  ColleagueB    │
        └───────────────┘     └────────────────┘
```

| 구성요소             | 설명                                  |
| -------------------- | ------------------------------------- |
| **Mediator**         | Colleague 간 상호작용을 정의          |
| **ConcreteMediator** | 구체적 중재 로직 구현                 |
| **Colleague**        | 참가자 객체, Mediator를 통해서만 통신 |

### ✅ 3. Java 예제: 채팅방 시스템

#### 🔸 Mediator 인터페이스

```java
public interface ChatRoomMediator {
    void showMessage(User user, String message);
}
```

#### 🔸 ConcreteMediator

```java
public class ChatRoom implements ChatRoomMediator {
    public void showMessage(User user, String message) {
        System.out.println(user.getName() + ": " + message);
    }
}
```

#### 🔸 Colleague 클래스

```java
public class User {
    private String name;
    private ChatRoomMediator mediator;

    public User(String name, ChatRoomMediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }

    public String getName() {
        return name;
    }

    public void send(String message) {
        mediator.showMessage(this, message);
    }
}
```

#### 🔸 클라이언트 코드

```java
public class Client {
    public static void main(String[] args) {
        ChatRoomMediator mediator = new ChatRoom();

        User alice = new User("Alice", mediator);
        User bob = new User("Bob", mediator);

        alice.send("안녕, Bob!");
        bob.send("안녕, Alice!");
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class ChatRoom:
    def show_message(self, user, message):
        print(f"{user.name}: {message}")

class User:
    def __init__(self, name, room):
        self.name = name
        self.room = room

    def send(self, message):
        self.room.show_message(self, message)

# 사용
room = ChatRoom()
alice = User("Alice", room)
bob = User("Bob", room)

alice.send("Hi Bob!")
bob.send("Hi Alice!")
```

### ✅ 5. 실무 활용 예

| 분야                      | 예시                                                         |
| ------------------------- | ------------------------------------------------------------ |
| **UI 컴포넌트**           | 버튼 클릭 → 텍스트 입력 → 리스트 갱신 등 이벤트 전달을 Mediator로 통제 |
| **항공관제 시스템**       | 항공기끼리 직접 통신 X, 관제탑(Mediator)이 중재              |
| **챗봇 구성 요소**        | Intent, NLP, 응답기 등 중간 허브로 분리                      |
| **Spring EventPublisher** | ApplicationEventPublisher가 중간 브로커 역할 수행            |

### ✅ 6. 장점

| 장점                | 설명                          |
| ------------------- | ----------------------------- |
| 객체 간 결합도 낮춤 | 변경 시 다른 객체 영향 최소화 |
| 로직 중앙 집중화    | 상호작용 흐름을 한곳에서 관리 |
| 테스트 용이         | 객체 단위 테스트가 쉬움       |

### ❌ 단점

| 단점                        | 설명                                                   |
| --------------------------- | ------------------------------------------------------ |
| Mediator 클래스 복잡도 증가 | 모든 상호작용이 한 곳에 집중되면 **God Object** 가능성 |
| 동적 관계가 많아지면 부담   | 구조 설계가 복잡한 경우 Mediator만으로 처리 어려움     |

### ✅ 7. Mediator vs Observer vs Facade

| 비교 대상    | 목적                | 주요 차이점                             |
| ------------ | ------------------- | --------------------------------------- |
| **Mediator** | 객체 간 통신 중재   | Colleague 간 직접 참조 제거             |
| **Observer** | 이벤트 브로드캐스트 | Publisher → N명에게 전달                |
| **Facade**   | 서브시스템 단순화   | 여러 클래스 묶어 단일 API 제공 (통신 X) |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 객체들 간의 통신을 **중재자에게 위임**하여, 직접 통신을 막고 **결합도를 낮추는 패턴** |
| **핵심 구성** | `Mediator ↔ Colleague`, 중앙에서 통신 제어                   |
| **사용 시점** | UI 이벤트 처리, 채팅, 항공관제, 이벤트 버스 등               |
| **장점**      | 결합도↓, 코드 변경 유연, 중앙 제어 가능                      |
| **단점**      | Mediator가 비대해질 수 있음 (God Object 우려)                |

## 3.6 Memento (메멘토)

- 객체 상태를 저장하고 복원
- 예: 게임 저장, Undo 기능

### ✅ Memento 패턴이란?

> 객체의 **내부 상태를 저장**해 두었다가,
>  나중에 **그 상태로 복원할 수 있게** 해주는 디자인 패턴.

즉, **“Ctrl+Z(Undo)” 기능을 객체화한 것**이라고 생각하면 됨.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                    | 설명                                                    |
| ----------------------- | ------------------------------------------------------- |
| 실행 취소 기능 구현     | 이전 상태로 되돌릴 수 있도록 스냅샷 저장                |
| 복잡한 객체의 상태 보존 | 객체 외부에서는 내부 상태를 알 수 없어도 상태 복원 가능 |
| 임시 상태 저장          | 작업 중 임시 저장/복원 시                               |

### ✅ 2. 구조 (UML)

```
 ┌─────────────┐
 │   Originator│────────────┐
 └─────┬───────┘            │
       │ createMemento()    │
       │ restore(memento)   │
       ▼                    │
 ┌─────────────┐            │
 │   Memento   │◄───────────┘ ← 상태를 보관하는 캡슐화 객체
 └─────────────┘
       ▲
       │
 ┌──────────────┐
 │ Caretaker    │ ← Memento를 보관하고, 요청 시 Originator에게 복원 요청
 └──────────────┘
```

| 구성요소       | 설명                                              |
| -------------- | ------------------------------------------------- |
| **Originator** | 상태를 가지며, Memento를 생성/복원할 수 있는 객체 |
| **Memento**    | 상태 저장 캡슐. 내부 구조는 외부에서 접근 불가    |
| **Caretaker**  | Memento를 저장하고 필요 시 Originator에게 전달    |

### ✅ 3. Java 예제: 텍스트 편집기 Undo

#### 🔸 Memento (불변 상태 캡슐)

```java
public class TextMemento {
    private final String state;

    public TextMemento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}
```

#### 🔸 Originator (문서 편집기)

```java
public class Editor {
    private String text = "";

    public void type(String words) {
        text += words;
    }

    public String getText() {
        return text;
    }

    public TextMemento save() {
        return new TextMemento(text);
    }

    public void restore(TextMemento memento) {
        this.text = memento.getState();
    }
}
```

#### 🔸 Caretaker (Undo 히스토리)

```java
import java.util.Stack;

public class EditorHistory {
    private Stack<TextMemento> history = new Stack<>();

    public void push(TextMemento m) {
        history.push(m);
    }

    public TextMemento pop() {
        return history.pop();
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        Editor editor = new Editor();
        EditorHistory history = new EditorHistory();

        editor.type("Hello ");
        history.push(editor.save());

        editor.type("World!");
        System.out.println(editor.getText()); // Hello World!

        editor.restore(history.pop());
        System.out.println(editor.getText()); // Hello
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Memento:
    def __init__(self, state): self._state = state
    def get_state(self): return self._state

class Editor:
    def __init__(self): self.text = ""
    def type(self, words): self.text += words
    def save(self): return Memento(self.text)
    def restore(self, memento): self.text = memento.get_state()

# 사용
editor = Editor()
history = []

editor.type("Hello ")
history.append(editor.save())

editor.type("World!")
print(editor.text)  # Hello World!

editor.restore(history.pop())
print(editor.text)  # Hello
```

### ✅ 5. 실무 활용 예

| 분야           | 예시                           |
| -------------- | ------------------------------ |
| 텍스트 편집기  | undo/redo 기능                 |
| 게임 상태 저장 | 저장 시점마다 스냅샷 보관      |
| 그래픽 툴      | 상태 복원, 이력 관리           |
| IDE            | 코드 리팩토링 시 상태 되돌리기 |

### ✅ 6. 장점

| 장점                | 설명                                |
| ------------------- | ----------------------------------- |
| 상태 보존           | 이전 상태로 완전하게 복원 가능      |
| 캡슐화 유지         | 내부 구현 숨기면서 상태만 전달 가능 |
| Undo/Redo 구현 쉬움 | 스택을 활용한 히스토리 저장         |

### ❌ 단점

| 단점                          | 설명                                   |
| ----------------------------- | -------------------------------------- |
| 메모리 부담                   | 상태가 클 경우 저장 비용 증가          |
| 많은 스냅샷 저장 시 성능 저하 | GC, 디스크 등 부하 고려 필요           |
| Caretaker 책임 증가           | Memento 관리, 스택 관리 등의 책임 집중 |

### ✅ 7. Memento vs Command vs Snapshot

| 패턴         | 목적            | 핵심 비교                            |
| ------------ | --------------- | ------------------------------------ |
| **Memento**  | 상태 저장/복원  | 상태 자체 저장, 외부는 접근 불가     |
| **Command**  | 실행 캡슐화     | 실행/되돌리기(undo) 포함             |
| **Snapshot** | DB 상태 보관 등 | 상태 덤프 저장, 범용적 개념 (패턴 X) |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 객체의 상태를 저장하고, 필요 시 그 상태로 복원할 수 있는 구조 |
| **핵심 구성** | `Originator`, `Memento`, `Caretaker`                         |
| **활용 사례** | 텍스트 편집기, 게임 저장, Undo 시스템                        |
| **장점**      | 캡슐화 유지, 복원 가능, 구조적 명확                          |
| **단점**      | 메모리 비용, 관리 책임 증가                                  |

## 3.7 Observer (옵저버)

- **한 객체의 상태 변화**를 **의존 객체에 자동 알림**
- 예: 이벤트 리스너, `@EventListener`

### ✅ Observer 패턴이란?

> **한 객체의 상태 변화**를
>  **의존하는 여러 객체에게 자동으로 통지**하도록 하는 패턴.
>  즉, **“발행-구독(Pub-Sub)” 구조를 객체화**한 것.

### ✅ 1. 언제 사용하는가? (목적)

| 목적           | 설명                                        |
| -------------- | ------------------------------------------- |
| 상태 변화 감지 | 객체의 상태 변경을 실시간으로 알림          |
| 느슨한 결합    | 주체(Subject)는 옵저버가 누구인지 몰라도 됨 |
| 실시간 반응    | 이벤트 기반 프로그래밍에 필수               |

### ✅ 2. 구조 (UML)

```
        ┌────────────┐
        │  Subject   │◄────────────────────────┐
        └─────┬──────┘                         │
              │                                │
     ┌────────▼─────────┐         ┌────────────▼────────────┐
     │ ConcreteSubject   │───────▶│       Observer           │
     └────────┬──────────┘         └────────────┬────────────┘
              │                                 ▼
              ▼                         ┌───────────────┐
     notifyObservers()                  │ConcreteObserver│
                                        └───────────────┘
```

| 구성 요소            | 설명                                          |
| -------------------- | --------------------------------------------- |
| **Subject**          | 옵저버 등록/해제/알림 인터페이스              |
| **ConcreteSubject**  | 실제 상태를 가지고, 변경 시 옵저버들에게 알림 |
| **Observer**         | 상태 변경을 통보받는 인터페이스               |
| **ConcreteObserver** | 통보를 받아 행동하는 실제 객체들              |

### ✅ 3. Java 예제: 뉴스 알림 시스템

#### 🔸 Observer 인터페이스

```java
public interface Subscriber {
    void update(String news);
}
```

#### 🔸 ConcreteObserver

```java
public class EmailSubscriber implements Subscriber {
    private String name;

    public EmailSubscriber(String name) {
        this.name = name;
    }

    public void update(String news) {
        System.out.println(name + "에게 이메일 발송: " + news);
    }
}
```

#### 🔸 Subject 인터페이스

```java
public interface NewsAgency {
    void subscribe(Subscriber s);
    void unsubscribe(Subscriber s);
    void notifySubscribers(String news);
}
```

#### 🔸 ConcreteSubject

```java
import java.util.*;

public class YTN implements NewsAgency {
    private List<Subscriber> list = new ArrayList<>();

    public void subscribe(Subscriber s) {
        list.add(s);
    }

    public void unsubscribe(Subscriber s) {
        list.remove(s);
    }

    public void notifySubscribers(String news) {
        for (Subscriber s : list) {
            s.update(news);
        }
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        NewsAgency ytn = new YTN();

        Subscriber s1 = new EmailSubscriber("철수");
        Subscriber s2 = new EmailSubscriber("영희");

        ytn.subscribe(s1);
        ytn.subscribe(s2);

        ytn.notifySubscribers("속보: 자바 패턴 시험 출제!");
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Observer:
    def update(self, msg): pass

class Subscriber(Observer):
    def __init__(self, name): self.name = name
    def update(self, msg): print(f"{self.name}에게 알림: {msg}")

class Publisher:
    def __init__(self): self.subscribers = []
    def subscribe(self, obs): self.subscribers.append(obs)
    def notify(self, msg):
        for obs in self.subscribers:
            obs.update(msg)

# 사용
pub = Publisher()
pub.subscribe(Subscriber("Alice"))
pub.subscribe(Subscriber("Bob"))

pub.notify("새 기사 올라옴!")
```

### ✅ 5. 실무 활용 예시

| 분야                 | 예시                                                         |
| -------------------- | ------------------------------------------------------------ |
| **UI/데이터 바인딩** | Model 변경 시 View 자동 반영 (MVVM, MVC)                     |
| **Event Bus**        | Spring `ApplicationEventPublisher`, Android `LiveData`, RxJava |
| **알림 시스템**      | 뉴스 알림, 주식 가격 변동, 상태 모니터링                     |
| **실시간 통신**      | WebSocket, MQTT 등에서 구독 구조 활용                        |

### ✅ 6. 장점

| 장점          | 설명                        |
| ------------- | --------------------------- |
| 느슨한 결합   | Subject와 Observer가 독립적 |
| 유연한 구조   | 구독자 추가/삭제가 쉬움     |
| 실시간 반응형 | 상태 변경 → 즉시 알림       |

### ❌ 단점

| 단점                  | 설명                                           |
| --------------------- | ---------------------------------------------- |
| 알림 순서/시점 불확실 | 비동기 알림 시 디버깅 어려움                   |
| 옵저버 관리 책임 필요 | 구독 해제 누락 시 메모리 누수 가능             |
| 무한 루프 발생 가능성 | 옵저버 내부에서 Subject 변경 시 재귀 발생 위험 |

### ✅ 7. Observer vs Mediator vs Event Bus

| 비교 대상     | 역할                    | 차이점                              |
| ------------- | ----------------------- | ----------------------------------- |
| **Observer**  | 다수에게 상태 변경 알림 | 1:N 전파 구조                       |
| **Mediator**  | 상호작용 중재           | 다대다 구조 제어                    |
| **Event Bus** | 비동기 브로드캐스트     | 등록자끼리 서로 모름 (pub-sub 분리) |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | **한 객체의 상태 변경**을 **여러 객체가 자동으로 통보받도록** 만드는 패턴 |
| **핵심 구조** | `Subject ↔ Observer` (1:N)                                   |
| **사용처**    | 데이터 변경 감지, 실시간 통신, UI 반응형 구조                |
| **장점**      | 느슨한 결합, 동적 연결, 반응형 시스템 구성 용이              |
| **단점**      | 순서 제어 어려움, 무한 루프 주의, 옵저버 정리 필요           |

## 3.8 State (상태)

- 객체 상태에 따라 행위를 변경 (if/else 제거)
- 예: 문서 상태(작성 → 승인 → 게시)

### ✅ State 패턴이란?

> **객체의 내부 상태에 따라 동작을 다르게** 하도록
>  **상태를 객체화**하여, 상태 전환 시 객체의 행동도 변경되도록 만드는 패턴

즉, **“if/else 상태 분기를 객체로 대체”**하는 구조

### ✅ 1. 언제 사용하는가? (목적)

| 목적                       | 설명                                         |
| -------------------------- | -------------------------------------------- |
| 상태 전환에 따른 행동 변화 | 상태에 따라 동작이 바뀌어야 할 때            |
| 조건문 제거                | if-else/switch 블록을 객체로 분리            |
| 실행 중 동적으로 상태 변경 | 런타임에서 행동이 자연스럽게 전환되도록 구성 |

### ✅ 2. 구조 (UML)

```
   ┌──────────────┐
   │   Context     │
   ├──────────────┤
   │ state: State  │──┐
   └──────┬────────┘  │
          ▼           ▼
      ┌──────────────┐
      │   State       │◄────────────┐
      └──────┬────────┘             │
             ▼                      │
    ┌──────────────────┐     ┌──────────────────┐
    │ ConcreteStateA    │     │ ConcreteStateB    │
    └──────────────────┘     └──────────────────┘
```

| 구성 요소         | 설명                                      |
| ----------------- | ----------------------------------------- |
| **Context**       | 상태를 가지고 있고, 상태에 따라 동작 위임 |
| **State**         | 상태 인터페이스 (행동 메서드 정의)        |
| **ConcreteState** | 각 상태에서의 구체적 행동 정의            |

### ✅ 3. Java 예제: 전자문서 결재 시스템

#### 🔸 State 인터페이스

```java
public interface DocumentState {
    void handle(Document doc);
}
```

#### 🔸 ConcreteState들

```java
public class DraftState implements DocumentState {
    public void handle(Document doc) {
        System.out.println("현재 상태: 초안 → 검토 중으로 변경");
        doc.setState(new ReviewState());
    }
}

public class ReviewState implements DocumentState {
    public void handle(Document doc) {
        System.out.println("현재 상태: 검토 → 승인 대기로 변경");
        doc.setState(new ApprovalState());
    }
}

public class ApprovalState implements DocumentState {
    public void handle(Document doc) {
        System.out.println("현재 상태: 승인 완료. 더 이상 상태 전이 없음.");
    }
}
```

#### 🔸 Context (상태를 가진 객체)

```java
public class Document {
    private DocumentState state;

    public Document() {
        this.state = new DraftState(); // 초기 상태
    }

    public void setState(DocumentState state) {
        this.state = state;
    }

    public void process() {
        state.handle(this); // 현재 상태에 따라 동작 위임
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        Document doc = new Document();

        doc.process(); // 초안 → 검토
        doc.process(); // 검토 → 승인
        doc.process(); // 승인 완료
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class State:
    def handle(self, context): pass

class Draft(State):
    def handle(self, context):
        print("초안 → 검토")
        context.state = Review()

class Review(State):
    def handle(self, context):
        print("검토 → 승인")
        context.state = Approval()

class Approval(State):
    def handle(self, context):
        print("승인 완료")

class Document:
    def __init__(self): self.state = Draft()
    def process(self): self.state.handle(self)

# 사용
doc = Document()
doc.process()
doc.process()
doc.process()
```

### ✅ 5. 실무 활용 예

| 분야                 | 예시                                     |
| -------------------- | ---------------------------------------- |
| **결제 상태 전이**   | 요청 → 결제 중 → 성공/실패               |
| **TCP 상태 관리**    | LISTEN → SYN_RECEIVED → ESTABLISHED 등   |
| **게임 캐릭터 상태** | 서기 / 걷기 / 점프 / 공격 등 상태별 동작 |
| **UI 컴포넌트 상태** | 활성화/비활성화/포커스/호버 등           |

### ✅ 6. 장점

| 장점             | 설명                                         |
| ---------------- | -------------------------------------------- |
| 조건문 제거      | 상태 전이에 따른 `if-else` 코드 제거         |
| 상태별 책임 분리 | 각 상태가 자체적으로 행동을 정의             |
| 확장성 ↑         | 새로운 상태 추가 시 기존 코드 수정 거의 없음 |

### ❌ 단점

| 단점           | 설명                                   |
| -------------- | -------------------------------------- |
| 클래스 수 증가 | 상태 수만큼 클래스 필요                |
| 복잡도 증가    | 단순 분기일 경우 과도한 구조일 수 있음 |

### ✅ 7. State vs Strategy vs Observer

| 패턴         | 목적                  | 차이점                                       |
| ------------ | --------------------- | -------------------------------------------- |
| **State**    | 상태에 따라 행동 변화 | 현재 객체 상태에 따라 내부적으로 동작이 바뀜 |
| **Strategy** | 알고리즘 선택         | 외부에서 전략을 주입함                       |
| **Observer** | 이벤트 알림           | 상태가 바뀌면 다른 객체에 통지               |

### 🧠 마무리 요약

| 항목          | 내용                                                       |
| ------------- | ---------------------------------------------------------- |
| **정의**      | 객체의 상태에 따라 동작을 변경하는 패턴. 상태를 클래스화함 |
| **핵심 구성** | `Context`, `State`, `ConcreteState`                        |
| **사용처**    | 결제 흐름, 상태 머신, 문서 처리, 게임 캐릭터               |
| **장점**      | if/switch 제거, 상태별 책임 분리, 확장 용이                |
| **단점**      | 클래스 수 증가, 단순한 로직에 과하면 오히려 복잡           |

## 3.9 Strategy (전략)

- **행위를 캡슐화하여** 동적으로 교체 가능
- 예: 정렬 방식 선택, 할인 정책 교체

### ✅ Strategy 패턴이란?

> **알고리즘(전략)을 객체로 캡슐화**하여,
>  런타임에 알고리즘을 **자유롭게 바꿀 수 있도록** 만드는 패턴

즉, **“행동을 클래스로 분리”**하고,
 **동적으로 선택 가능하도록 전략을 외부화**한 구조

### ✅ 1. 언제 사용하는가? (목적)

| 목적                 | 설명                                   |
| -------------------- | -------------------------------------- |
| 알고리즘 교체 유연화 | 동작 방식(전략)을 실행 중 바꿔야 할 때 |
| 코드 중복 제거       | 전략별 분기를 클래스화하여 중복 제거   |
| 조건문 제거          | if/switch 대신 전략 주입 방식으로 전환 |

### ✅ 2. 구조 (UML)

```
Client
    │
    ▼
  Context ─────────────→ Strategy (interface)
    │                         ▲
    ▼                         │
  doSomething()        ┌─────────────┐
                       │ConcreteStrategyA│
                       │ConcreteStrategyB│
                       └─────────────┘
```

| 구성 요소            | 설명                           |
| -------------------- | ------------------------------ |
| **Strategy**         | 알고리즘 인터페이스            |
| **ConcreteStrategy** | 구체적인 알고리즘 구현체       |
| **Context**          | 전략을 주입받고 실행하는 객체  |
| **Client**           | 전략을 선택해서 Context에 전달 |

### ✅ 3. Java 예제: 정렬 전략

#### 🔸 Strategy 인터페이스

```java
public interface SortStrategy {
    void sort(int[] arr);
}
```

#### 🔸 ConcreteStrategies

```java
import java.util.Arrays;

public class BubbleSort implements SortStrategy {
    public void sort(int[] arr) {
        System.out.println("버블 정렬 실행");
        // 실제 로직 생략
        Arrays.sort(arr); // 예시로 sort
    }
}

public class QuickSort implements SortStrategy {
    public void sort(int[] arr) {
        System.out.println("퀵 정렬 실행");
        Arrays.sort(arr); // 실제 로직 생략
    }
}
```

#### 🔸 Context

```java
public class Sorter {
    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void sort(int[] arr) {
        strategy.sort(arr);
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        int[] data = {5, 3, 1, 4};

        Sorter sorter = new Sorter();

        sorter.setStrategy(new BubbleSort());
        sorter.sort(data); // 버블 정렬 실행

        sorter.setStrategy(new QuickSort());
        sorter.sort(data); // 퀵 정렬 실행
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Strategy:
    def sort(self, data): pass

class BubbleSort(Strategy):
    def sort(self, data):
        print("버블 정렬:", sorted(data))

class QuickSort(Strategy):
    def sort(self, data):
        print("퀵 정렬:", sorted(data))

class Sorter:
    def __init__(self, strategy): self.strategy = strategy
    def set_strategy(self, strategy): self.strategy = strategy
    def sort(self, data): self.strategy.sort(data)

# 사용
data = [4, 2, 1, 3]
s = Sorter(BubbleSort())
s.sort(data)

s.set_strategy(QuickSort())
s.sort(data)
```

### ✅ 5. 실무 활용 예

| 분야                     | 예시                                                     |
| ------------------------ | -------------------------------------------------------- |
| **정렬 알고리즘 선택**   | `Collections.sort()`에 Comparator 전달                   |
| **AI 행위 결정**         | 캐릭터 전략(공격/회피/도망 등) 주입                      |
| **암호화/압축 알고리즘** | 전략 객체를 통해 압축 방식 교체                          |
| **스프링**               | `PaymentStrategy`, `AuthenticationStrategy` 등 DI와 결합 |

### ✅ 6. 장점

| 장점               | 설명                               |
| ------------------ | ---------------------------------- |
| 알고리즘 교체 유연 | 실행 중 전략 바꿔도 문제 없음      |
| 조건문 제거        | 분기 없이 전략 객체로 대체         |
| OCP 원칙 준수      | 기존 코드 변경 없이 전략 추가 가능 |

### ❌ 단점

| 단점                          | 설명                                  |
| ----------------------------- | ------------------------------------- |
| 클래스 수 증가                | 전략마다 별도 클래스 필요             |
| 클라이언트가 전략을 알아야 함 | 적절한 전략을 선택/전달하는 책임 필요 |

### ✅ 7. Strategy vs State vs Template Method

| 패턴                | 목적                         | 주체               | 실행 시점   |
| ------------------- | ---------------------------- | ------------------ | ----------- |
| **Strategy**        | 알고리즘 교체                | 외부 주입          | 런타임      |
| **State**           | 상태별 행동 변화             | 내부에서 전환      | 런타임      |
| **Template Method** | 공통 로직 정의 + 일부만 변경 | 상속으로 구조 고정 | 컴파일 타임 |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 알고리즘(전략)을 객체로 분리하여 동적으로 교체할 수 있는 구조 |
| **핵심 구성** | `Strategy` 인터페이스 + `ConcreteStrategy` + `Context`       |
| **적용 예시** | 정렬, 검색, 행동 결정, 압축, 인증 등                         |
| **장점**      | 전략 변경 유연, 코드 확장성↑, 조건문 제거                    |
| **단점**      | 전략 관리 책임, 클래스 증가                                  |

## 3.10 Template Method (템플릿 메서드)

- 알고리즘 구조는 고정하고, 세부 단계는 서브클래스에서 정의
- `execute()` 안에서 `doStep1()`, `doStep2()` 호출

### ✅ Template Method 패턴이란?

> **알고리즘의 뼈대(템플릿)를 상위 클래스에 정의하고**,
>  세부적인 처리는 하위 클래스에서 구현하도록 하는 디자인 패턴.

즉, **"공통 알고리즘은 고정하고, 일부 단계만 오버라이드"** 하도록 만드는 구조야.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                     | 설명                                                 |
| ------------------------ | ---------------------------------------------------- |
| 알고리즘의 구조를 재사용 | 전체 구조는 고정, 일부만 유연하게 오버라이딩         |
| 코드 중복 제거           | 반복되는 흐름은 부모 클래스에 두고, 변화 부분만 분리 |
| 후킹(hook) 제공          | 선택적으로 오버라이드 가능한 메서드 구조 제공        |

### ✅ 2. 구조 (UML)

```
         ┌────────────────────┐
         │  AbstractClass     │
         ├────────────────────┤
         │ templateMethod()   │ ← 고정된 알고리즘 순서
         │ + step1()          │
         │ + step2()          │
         └──────┬─────────────┘
                ▼
         ┌────────────────────┐
         │  ConcreteClass     │ ← 세부 단계 구현
         └────────────────────┘
```

| 구성요소          | 설명                                           |
| ----------------- | ---------------------------------------------- |
| **AbstractClass** | 알고리즘 뼈대(템플릿 메서드) 정의              |
| **ConcreteClass** | 실제 알고리즘 단계 구현                        |
| **hook method**   | 기본 구현을 제공하지만 필요 시 오버라이드 가능 |

### ✅ 3. Java 예제: 커피/차 만드는 과정

#### 🔸 AbstractClass

```java
public abstract class CaffeineBeverage {
    // 템플릿 메서드 (final로 고정)
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    abstract void brew();
    abstract void addCondiments();

    void boilWater() {
        System.out.println("물 끓이는 중");
    }

    void pourInCup() {
        System.out.println("컵에 따르는 중");
    }

    // Hook method (선택 구현)
    boolean customerWantsCondiments() {
        return true;
    }
}
```

#### 🔸 ConcreteClass

```java
public class Tea extends CaffeineBeverage {
    void brew() {
        System.out.println("찻잎을 우려내는 중");
    }

    void addCondiments() {
        System.out.println("레몬 추가");
    }
}

public class Coffee extends CaffeineBeverage {
    void brew() {
        System.out.println("커피를 내리는 중");
    }

    void addCondiments() {
        System.out.println("설탕과 우유 추가");
    }

    @Override
    boolean customerWantsCondiments() {
        return false; // 사용자 요청에 따라 생략
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        CaffeineBeverage tea = new Tea();
        tea.prepareRecipe();

        CaffeineBeverage coffee = new Coffee();
        coffee.prepareRecipe();
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class CaffeineBeverage:
    def prepare_recipe(self):
        self.boil_water()
        self.brew()
        self.pour_in_cup()
        if self.customer_wants_condiments():
            self.add_condiments()

    def boil_water(self):
        print("물 끓이는 중")

    def pour_in_cup(self):
        print("컵에 따르는 중")

    def customer_wants_condiments(self):
        return True  # hook method

    def brew(self): pass
    def add_condiments(self): pass

class Tea(CaffeineBeverage):
    def brew(self): print("찻잎 우림")
    def add_condiments(self): print("레몬 추가")

class Coffee(CaffeineBeverage):
    def brew(self): print("커피 추출")
    def add_condiments(self): print("설탕, 우유 추가")
    def customer_wants_condiments(self): return False

# 사용
Tea().prepare_recipe()
Coffee().prepare_recipe()
```

### ✅ 5. 실무 활용 예

| 분야                     | 예시                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **프레임워크 구조 제어** | Spring `AbstractController`, `JdbcTemplate`                  |
| **테스트 케이스**        | JUnit `setUp()`, `tearDown()`                                |
| **게임 루프 엔진**       | `initialize() → update() → render()` 구조 고정               |
| **빌더 템플릿**          | `buildHeader() → buildBody() → buildFooter()` 등 UI 구조 고정 |

### ✅ 6. 장점

| 장점                 | 설명                                |
| -------------------- | ----------------------------------- |
| 알고리즘 구조 재사용 | 코드 중복 최소화, 유지 보수 용이    |
| 확장성 ↑             | 서브클래스에서 원하는 부분만 재정의 |
| 후킹 기능            | 선택적 커스터마이징 가능            |

### ❌ 단점

| 단점                    | 설명                                            |
| ----------------------- | ----------------------------------------------- |
| 상속 강제               | 서브클래스 사용이 강제됨 (조합 불가능)          |
| 클래스 수 증가          | 변형이 많을 경우 클래스를 많이 만들어야 함      |
| 런타임 동적 변경 어려움 | 실행 중 전략을 바꾸려면 구조 자체를 변경해야 함 |

### ✅ 7. Template Method vs Strategy vs State

| 패턴                | 목적                               | 차이점                                     |
| ------------------- | ---------------------------------- | ------------------------------------------ |
| **Template Method** | 알고리즘의 구조 고정 + 단계만 변경 | **상속 기반**, 알고리즘 흐름 고정          |
| **Strategy**        | 알고리즘 교체                      | **조합(Composition)** 기반, 동적 변경 가능 |
| **State**           | 상태에 따라 행동 변화              | 상태 객체 내부에서 전환이 발생             |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 알고리즘의 전체 구조(템플릿)를 상위 클래스에 정의하고, 일부 단계만 서브클래스가 구현 |
| **핵심 구성** | `templateMethod()` + `abstract step()` + (선택적) `hook()`   |
| **적용 예시** | 프레임워크 설계, 게임 루프, 알고리즘 구조 재사용             |
| **장점**      | 중복 제거, 재사용 가능, 후킹 기능                            |
| **단점**      | 상속 강제, 전략 교체 어려움, 클래스 증가                     |

## 3.11 Visitor (방문자)

- **구조와 행위 분리**, 요소 구조는 그대로 두고 행위만 추가
- 예: 문서 검증기, HTML 렌더러

### ✅ Visitor 패턴이란?

> 객체 구조(예: 트리, 그래프 등)를 변경하지 않고도
>  **새로운 연산(기능)을 추가**할 수 있게 해주는 패턴.
>  즉, **연산(행동)을 객체에서 분리하여 방문자 객체에 위임**하는 방식.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                             | 설명                                             |
| -------------------------------- | ------------------------------------------------ |
| 구조는 고정, 행동만 유동         | 기존 클래스 수정 없이 새로운 기능을 추가         |
| 연산 분리                        | 자료 구조와 연산을 완전히 분리                   |
| 다중 분산 (Double Dispatch) 구현 | 객체 타입 + 방문자 타입 둘 다 기준으로 동작 선택 |

### ✅ 2. 구조 (UML)

```
             ┌────────────┐
             │  Visitor   │◄────────────┐
             └────┬───────┘             │
                  ▼                    ▼
       ┌────────────────┐     ┌────────────────────┐
       │ ConcreteVisitor │     │     Element         │
       └────────────────┘     └────────┬────────────┘
                                       ▼
                               ┌──────────────┐
                               │ConcreteElement│
                               └──────────────┘
```

| 구성 요소           | 설명                                          |
| ------------------- | --------------------------------------------- |
| **Visitor**         | 수행할 연산의 인터페이스 (visitXXX 메서드들)  |
| **ConcreteVisitor** | 실제 연산 구현                                |
| **Element**         | 방문자를 받아들이는 인터페이스 (`accept()`)   |
| **ConcreteElement** | 연산을 받아들이고, `visitor.visit(this)` 호출 |

### ✅ 3. Java 예제: 도형 렌더링 + 면적 계산

#### 🔸 Element 인터페이스

```java
public interface Shape {
    void accept(Visitor visitor);
}
```

#### 🔸 ConcreteElement 클래스들

```java
public class Circle implements Shape {
    public double radius = 3.0;

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

public class Rectangle implements Shape {
    public double width = 5.0;
    public double height = 2.0;

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```

#### 🔸 Visitor 인터페이스

```java
public interface Visitor {
    void visit(Circle c);
    void visit(Rectangle r);
}
```

#### 🔸 ConcreteVisitor 구현

```java
public class AreaCalculator implements Visitor {
    public void visit(Circle c) {
        System.out.println("원의 면적: " + (Math.PI * c.radius * c.radius));
    }

    public void visit(Rectangle r) {
        System.out.println("사각형 면적: " + (r.width * r.height));
    }
}

public class ShapeRenderer implements Visitor {
    public void visit(Circle c) {
        System.out.println("원을 그립니다.");
    }

    public void visit(Rectangle r) {
        System.out.println("사각형을 그립니다.");
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        Shape[] shapes = { new Circle(), new Rectangle() };

        Visitor areaVisitor = new AreaCalculator();
        Visitor renderVisitor = new ShapeRenderer();

        for (Shape s : shapes) {
            s.accept(areaVisitor);   // 면적 계산
            s.accept(renderVisitor); // 그리기
        }
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Visitor:
    def visit_circle(self, c): pass
    def visit_rectangle(self, r): pass

class Shape:
    def accept(self, visitor): pass

class Circle(Shape):
    def __init__(self): self.radius = 3
    def accept(self, visitor): visitor.visit_circle(self)

class Rectangle(Shape):
    def __init__(self): self.width = 5; self.height = 2
    def accept(self, visitor): visitor.visit_rectangle(self)

class AreaVisitor(Visitor):
    def visit_circle(self, c):
        print("원의 면적:", 3.14 * c.radius ** 2)

    def visit_rectangle(self, r):
        print("사각형 면적:", r.width * r.height)

shapes = [Circle(), Rectangle()]
for s in shapes:
    s.accept(AreaVisitor())
```

### ✅ 5. 실무 활용 예

| 분야            | 예시                                        |
| --------------- | ------------------------------------------- |
| **컴파일러**    | AST 노드를 방문하여 해석, 최적화, 코드 생성 |
| **파일 시스템** | 디렉터리/파일 구조 순회하며 동작 수행       |
| **UI 구성요소** | 각 컴포넌트를 방문하며 렌더링, 이벤트 적용  |
| **통계 수집기** | 객체를 방문하며 데이터 추출, 요약           |

### ✅ 6. 장점

| 장점                      | 설명                                                 |
| ------------------------- | ---------------------------------------------------- |
| 기능 추가 용이            | 기존 구조 변경 없이 새로운 연산 추가 가능 (OCP 만족) |
| 구조-행동 분리            | 데이터와 로직을 완전히 분리하여 관리                 |
| 복잡한 구조에도 적용 가능 | 트리, 그래프, 복합 구조에 유용                       |

### ❌ 단점

| 단점                                | 설명                                                      |
| ----------------------------------- | --------------------------------------------------------- |
| Element 수정 시 Visitor도 수정 필요 | 구조 변경이 생기면 모든 Visitor에 영향                    |
| 방문 메서드 폭발 가능성             | 각 Element마다 `visitXXX()`가 필요 → 인터페이스 증가      |
| 다형성 저하                         | 런타임 동적 다형성보다 타입 분기를 명시적으로 작성해야 함 |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 객체 구조는 그대로 두고, 새로운 연산을 **방문자 객체에 위임**하는 패턴 |
| **핵심 구성** | `Element.accept(Visitor)`, `Visitor.visit(Element)`          |
| **적용 사례** | AST 해석기, 도형 렌더링, 구조 순회 처리                      |
| **장점**      | 기능 확장 용이, 구조와 동작 분리, 유지보수성 ↑               |
| **단점**      | Element 변경 시 Visitor 전부 수정, 방문 메서드 과다 가능성   |

## 🧠 디자인 패턴 선택 기준 요약

| 목적              | 대표 패턴           | 설명                           |
| ----------------- | ------------------- | ------------------------------ |
| 객체 생성 제어    | Singleton, Factory  | 생성자 대신 팩토리 메서드 사용 |
| 인터페이스 호환성 | Adapter, Bridge     | 구조 다른 객체 연결            |
| 기능 확장         | Decorator, Strategy | 런타임 동적 기능 변경          |
| 상태 관리         | State, Memento      | 상태에 따른 행위 변경          |
| 통신 구조 최적화  | Mediator, Observer  | 객체 간 결합도 줄이기          |
| 반복 처리         | Iterator, Composite | 순차 접근, 계층 구조 처리      |

## ✅ 디자인 패턴은 설계 원칙과 함께 써야 의미가 있다!

| 설계 원칙 | 적용된 패턴 예                            |
| --------- | ----------------------------------------- |
| SRP       | Strategy, Template Method                 |
| OCP       | Decorator, Strategy, State                |
| DIP       | Command, Observer                         |
| LSP       | 모든 패턴은 이를 기본으로 전제            |
| ISP       | Visitor, Mediator 등 인터페이스 분리 기반 |

# 1-3. UI/UX 설계

# UI 개념 및 설계 지침

## ✅ UI(User Interface)란?

> UI는 **사용자와 시스템 간의 상호작용을 가능하게 하는 모든 수단**이야.
>  즉, 사용자가 소프트웨어를 "보고", "조작하고", "이해할 수 있게 만드는 매개체"라고 보면 돼.

## 🧩 UI의 구성 요소

| 구성 요소             | 설명                            | 예시                         |
| --------------------- | ------------------------------- | ---------------------------- |
| **입력 인터페이스**   | 사용자의 입력을 받아들이는 수단 | 버튼, 입력창, 스크롤바       |
| **출력 인터페이스**   | 시스템의 정보를 사용자에게 전달 | 알림창, 텍스트, 차트         |
| **행위(Interaction)** | 입력과 출력 간의 흐름 제어      | 클릭 → 결과 표시, 마우스오버 |

## 🔍 UI vs UX 비교

| 항목 | UI (User Interface)                         | UX (User Experience)                              |
| ---- | ------------------------------------------- | ------------------------------------------------- |
| 정의 | 사용자와 시스템 간의 **시각적/물리적 접점** | 사용자가 시스템을 이용하며 느끼는 **총체적 경험** |
| 목적 | 보이게 하고, 쓰게 만드는 것                 | 만족스럽게, 편리하게 만드는 것                    |
| 초점 | 디자인, 구성, 인터페이스 동작               | 효율성, 직관성, 감정, 사용 흐름                   |
| 예시 | 버튼의 색상/위치/크기                       | 버튼을 누를 때의 반응 속도, 만족도                |

## 🎯 UI 설계 지침 8가지 (국가표준 기반)

| 항목                    | 핵심 지침                      | 설명                                |
| ----------------------- | ------------------------------ | ----------------------------------- |
| 1. **사용자 중심**      | 사용자의 입장에서 설계         | 사용자가 누구인지 파악하고 맞춤화   |
| 2. **일관성**           | UI 요소를 통일성 있게 설계     | 동일한 위치, 색상, 명칭 유지        |
| 3. **단순성**           | 복잡함을 줄이고 직관적으로     | 필수 정보만 제공, 군더더기 제거     |
| 4. **가시성**           | 사용자가 현재 상태를 쉽게 인식 | 현재 페이지, 진행률, 선택 항목 강조 |
| 5. **응답성**           | 사용자 조작에 대한 피드백 제공 | 클릭 시 진동/음/로딩 표시           |
| 6. **오류 예방과 복구** | 실수 방지 및 쉽게 복구 가능    | 실시간 유효성 검사, Undo 기능       |
| 7. **유연성**           | 다양한 사용 방식 지원          | 키보드/터치/음성 모두 지원 가능     |
| 8. **접근성**           | 장애를 가진 사용자도 사용 가능 | 색약 고려, 스크린 리더 대응 등      |

## 📄 실무 UI 설계 절차 (UI 디자인 워크플로우)

```
1. 사용자 분석 → 2. 업무 흐름 파악 → 3. UI 요구사항 도출
→ 4. 정보 구조 설계(IA) → 5. 화면 설계 → 6. UI 설계서 작성
```

## 🧰 UI 설계서 주요 구성 요소

| 항목          | 설명                                |
| ------------- | ----------------------------------- |
| 화면 ID       | 화면을 고유하게 식별하는 코드       |
| 화면 이름     | 해당 UI의 명칭 (예: 로그인 화면)    |
| 입력 요소     | 버튼, 폼, 필드 등                   |
| 출력 요소     | 텍스트, 메시지, 테이블 등           |
| 인터랙션      | 사용자 조작과 그에 따른 시스템 반응 |
| 레이아웃 구조 | 와이어프레임 형태로 화면 배치       |

## 📐 좋은 UI를 위한 설계 원칙 (실전 정리)

| 원칙                  | 설명                                  | 예시                        |
| --------------------- | ------------------------------------- | --------------------------- |
| **Fitt's Law**        | 버튼이 클수록, 가까울수록 누르기 쉬움 | 모바일 하단 네비게이션      |
| **Hick’s Law**        | 선택지가 많을수록 결정이 느려짐       | 메뉴를 카테고리별로 묶기    |
| **Miller’s Law**      | 한 번에 7±2개 정보만 인식 가능        | 1 페이지당 요소 5~9개 유지  |
| **Gestalt Principle** | 인간은 정보를 묶어 인식함             | 그룹별 색상, 간격 조절      |
| **Consistency**       | 사용자가 익숙한 방식 고수             | 뒤로가기 = 왼쪽 상단 화살표 |

## ✨ UI 평가 기준 (사용성 평가 요소)

| 요소   | 정의                             | 측정 방법                   |
| ------ | -------------------------------- | --------------------------- |
| 효율성 | 얼마나 빠르고 정확하게 수행?     | 작업 시간 측정              |
| 학습성 | 얼마나 쉽게 배울 수 있는가?      | 처음 사용하는 사용자 수행률 |
| 기억성 | 한동안 안 써도 기억할 수 있는가? | 재사용 테스트               |
| 오류율 | 얼마나 적은 실수를 유도하는가?   | 실수 빈도 기록              |
| 만족도 | 사용자가 느끼는 주관적 만족감    | 설문, 인터뷰 등             |

## ✅ 정리 요약

| 구분             | 설명                              |
| ---------------- | --------------------------------- |
| **UI란?**        | 사용자와 시스템 간 인터페이스     |
| **UI 설계 지침** | 사용자 중심, 일관성, 단순성 등    |
| **UI 설계 문서** | 화면ID, 명칭, 인터랙션, 요소 배치 |
| **UI 평가 기준** | 효율성, 학습성, 오류율 등         |

# UX 설계 절차

## ✅ UX(User Experience)의 정의

> UX는 **사용자가 제품, 서비스, 시스템을 사용하며 느끼는 전반적인 경험**을 의미해.

즉, UI는 "표면"이라면
 UX는 "과정 전체", "느낌", "가치"까지 아우르는 개념이야.

## 📂 UX 설계 절차 6단계 (일반 표준 모델)

```
1. 사용자 조사
2. 요구사항 정의
3. 정보 구조 설계 (IA)
4. 인터랙션 설계
5. 프로토타입 제작
6. 사용성 테스트 및 개선
```

## 1️⃣ 사용자 조사 (User Research)

### ● 목적

- 사용자 특성, 행동, 목표, 환경, 불편 사항 등을 **정량·정성적 데이터**로 수집

### ● 방법

| 조사 방식                   | 설명                                          |
| --------------------------- | --------------------------------------------- |
| 인터뷰                      | 심층 인터뷰로 사용자 니즈 파악                |
| 설문조사                    | 다수 사용자로부터 통계 확보                   |
| 현장 관찰                   | 실제 업무 환경, 사용 흐름 관찰                |
| 페르소나                    | 대표 사용자의 가상 모델 설정                  |
| 사용자 여정 맵(Journey Map) | 사용자가 서비스를 사용하는 전체 흐름을 시각화 |

## 2️⃣ 요구사항 정의 (Requirements Definition)

### ● 목적

- 사용자 조사에서 나온 데이터를 기반으로 **무엇을 제공해야 하는지 명확히 정의**

### ● 핵심 활동

- 기능 요구 정의
- 비기능 요구 정리 (속도, 접근성 등)
- 사용자 목표 설정 (Task 기반 정의)
- 핵심 Use Case 도출

## 3️⃣ 정보 구조 설계 (IA: Information Architecture)

### ● 목적

- 정보들을 **사용자 관점에서 효율적으로 구조화**하여
   원하는 정보를 쉽게 찾고 이동할 수 있도록 구성

### ● 구성 요소

| 항목            | 설명                               |
| --------------- | ---------------------------------- |
| 내비게이션 구조 | 상단 메뉴, 사이드바 등             |
| 카테고리 분류   | 정보 그룹화                        |
| 계층 구조도     | 사이트맵, 계층적 구조 도식화       |
| 네이밍 정책     | 메뉴, 버튼 명칭 정리 (일관성 중요) |

## 4️⃣ 인터랙션 설계 (Interaction Design)

### ● 목적

- 사용자와 시스템 간의 **행위 흐름**과 **피드백 방식**을 정의함

### ● 설계 항목

| 항목      | 설명                                   |
| --------- | -------------------------------------- |
| 동작 흐름 | 사용자가 어떤 순서로 기능을 이용하는가 |
| 피드백    | 클릭 시 반응, 에러 메시지 등           |
| 상태 표시 | 진행 상황, 로딩, 성공/실패 표시        |
| 접근성    | 키보드/스크린리더 등 사용자 환경 지원  |

## 5️⃣ 프로토타입 제작 (Prototype)

### ● 목적

- 실제 개발 전 **화면 흐름, 동작 방식, 인터페이스**를
   빠르게 시각적으로 구현하고 **피드백** 받는 단계

### ● 종류

| 구분          | 설명                      | 도구 예시                   |
| ------------- | ------------------------- | --------------------------- |
| Low-Fidelity  | 종이 스케치, 와이어프레임 | Balsamiq, Figma, Lucidchart |
| High-Fidelity | 실제 동작 가능한 형태     | Figma, Adobe XD, HTML/CSS   |

## 6️⃣ 사용성 테스트 (Usability Test) 및 개선

### ● 목적

- 실제 사용자 또는 테스트 유저에게 제품/프로토타입을 사용하게 해보고
   **문제점, 개선 포인트**를 도출함

### ● 측정 항목

| 항목      | 설명                                       |
| --------- | ------------------------------------------ |
| 성공률    | 주어진 작업을 얼마나 성공적으로 수행했는가 |
| 오류율    | 클릭 미스, 길 잃음, 잘못된 동작 빈도       |
| 소요 시간 | 각 과제당 소요된 평균 시간                 |
| 만족도    | 정성적 피드백 (설문, 인터뷰)               |

## 🔁 UX 설계는 반복된다 (Iterative Design)

UX 설계는 **선형 진행이 아니라 반복 개선(Iteration)**이 핵심이야.
 → 조사 → 설계 → 테스트 → 개선 → 반복

> “완벽한 UX는 한 번에 나올 수 없다. 반드시 테스트와 수정을 거쳐야 한다.”

## 🧠 실무 예시: 온라인 쇼핑몰 UX 설계 흐름

| 단계           | 핵심 결과물                                  |
| -------------- | -------------------------------------------- |
| 사용자 조사    | 페르소나: 30대 직장인, 모바일 구매 비중↑     |
| 요구사항 정의  | 장바구니 저장, 최근 본 상품 강조             |
| 정보 구조 설계 | 메뉴: 홈 / 카테고리 / 마이페이지 / 검색      |
| 인터랙션 설계  | 상품 이미지 클릭 → 상세 보기 → 장바구니 담기 |
| 프로토타입     | 모바일 화면 와이어프레임 (Figma)             |
| 사용성 테스트  | 클릭 오류 ↓, 구매 흐름 직관적 ↑              |

## 📌 UX 설계 핵심 원칙 요약

| 원칙                  | 설명                                    |
| --------------------- | --------------------------------------- |
| 유용성(Usefulness)    | 사용자의 목적에 도움이 되는 기능        |
| 사용성(Usability)     | 쉽게 이해하고 사용할 수 있어야 함       |
| 만족도(Satisfaction)  | 감성적 만족감, 심리적 안정성            |
| 접근성(Accessibility) | 장애 유무, 디바이스 제한 없이 이용 가능 |
| 신뢰성(Reliability)   | 안정된 동작, 예측 가능한 흐름           |

# UI 프로토타입, 와이어프레임, 스토리보드 작성

## ✅ 이 세 가지 개념 먼저 확실히 구분해보자

| 항목             | 정의                                                         | 목적                      | 표현 수준                |
| ---------------- | ------------------------------------------------------------ | ------------------------- | ------------------------ |
| **와이어프레임** | 화면의 **기본 레이아웃**을 단순한 선과 도형으로 구성한 설계도 | 정보 구조, 기능 배치 결정 | **정적이고 단순**        |
| **스토리보드**   | 화면 전환 흐름 + 각 화면의 목적/설명을 포함한 시나리오형 설계 | 사용자 흐름 시뮬레이션    | **설명 중심**            |
| **프로토타입**   | 실제 동작처럼 인터랙션까지 표현한 시뮬레이션                 | 피드백, 테스트            | **동적이고 현실감 있음** |

## 1️⃣ **와이어프레임 (Wireframe)**

### ● 목적

- UI의 구조/레이아웃을 **단순화된 도형**으로 빠르게 설계함
- 색상/이미지 없이 구성 요소 위치와 흐름 중심으로 구성

### ● 구성 요소

| 요소        | 예시                         |
| ----------- | ---------------------------- |
| 헤더        | 로고, 메뉴                   |
| 콘텐츠 영역 | 제목, 입력폼, 버튼           |
| 푸터        | 저작권, 링크                 |
| 내비게이션  | 탭, 드롭다운, 햄버거 메뉴 등 |

### ● 작성 도구

- Figma (🟢 추천)
- Balsamiq
- Pencil, Lucidchart, Whimsical

### ● 예시 이미지 설명 (텍스트로 표현):

```less
[로그인 화면 와이어프레임 예시]
+-------------------------+
|      LOGO              |
|  [ 아이디 입력 ]        |
|  [ 비밀번호 입력 ]      |
|  (로그인 버튼)          |
|  [비밀번호 찾기]        |
+-------------------------+
```

## 2️⃣ **스토리보드 (Storyboard)**

### ● 목적

- **사용자의 화면 이동 흐름과 의도된 행동 시나리오**를 시간 순서대로 시각화
- 디자이너, 기획자, 개발자 간의 **의사소통 수단**

### ● 구성 요소

| 항목        | 내용                                |
| ----------- | ----------------------------------- |
| 화면 ID     | 고유 화면 식별 코드 (ex. LOGIN_01)  |
| 화면명      | 로그인, 상품 목록 등                |
| 주요 기능   | 입력, 버튼, 전환 동작 설명          |
| 유저 동작   | 버튼 클릭, 입력, 스크롤 등          |
| 시스템 반응 | API 호출, 화면 전환, 에러 메시지 등 |
| 연결 흐름   | 이전/다음 화면 설명                 |

### ● 템플릿 예시 (표 형태)

| 화면 ID  | 화면명      | 주요 내용                      | 연결 화면 |
| -------- | ----------- | ------------------------------ | --------- |
| LOGIN_01 | 로그인 화면 | ID/비밀번호 입력 → 로그인 버튼 | MAIN_01   |
| MAIN_01  | 메인 화면   | 메뉴 목록, 최근 활동 표시      | DETAIL_01 |

## 3️⃣ **프로토타입 (Prototype)**

### ● 목적

- 와이어프레임에 **동작(인터랙션)**을 추가하여
   마치 실제처럼 사용자 흐름을 체험 가능하게 만든다.

### ● 특징

| 항목   | 설명                                |
| ------ | ----------------------------------- |
| 동작   | 버튼 클릭 → 화면 전환, 모달 열기 등 |
| 피드백 | 클릭 시 로딩, 애니메이션 효과 등    |
| 테스트 | 실제 사용자 테스트 가능             |
| 공유   | URL 배포 가능, 팀 피드백 받기       |

### ● 제작 도구

- **Figma (인터랙션 연결 가능)**
- Adobe XD (애니메이션 포함)
- ProtoPie (고급 프로토타이핑)
- Axure, InVision

### ● 예시 시나리오

```markdown
[로그인 → 메인 화면 → 상품 상세]
1. 사용자가 ID/비번 입력 → 로그인 버튼 클릭
2. 메인 화면으로 이동 (메뉴, 추천 상품)
3. 상품 클릭 → 상세 페이지 이동
```

각 클릭 동작이 실제 화면 전환처럼 동작하고, 오류 메시지나 알림도 보여줄 수 있음.

## 🔁 세 가지의 흐름 관계

```
[정보 구조도] → [와이어프레임] → [스토리보드] → [프로토타입]
```

* 와이어프레임은 “정적인 뼈대”

* 스토리보드는 “스크립트”

* 프로토타입은 “애니메이션 + 동작하는 시뮬레이션”

## 📂 실무 적용 시 팁

| 상황                | 추천 방식                 |
| ------------------- | ------------------------- |
| 빠른 초기 구상      | 종이 스케치, 와이어프레임 |
| 기획 회의, 리뷰용   | 스토리보드 문서 + 흐름도  |
| 고객 피드백, 테스트 | 프로토타입 (URL 배포)     |

## ✨ 예제: 로그인 흐름 설계 (3단계)

1. **와이어프레임**
    → 로그인 화면에 입력칸, 버튼만 구성
2. **스토리보드**
    → ID/PW 입력 후 로그인 시 → 홈 화면으로 전환
    → 로그인 실패 시 → 에러 메시지 출력
3. **프로토타입**
    → 실제 버튼 클릭 시 페이지 전환 애니메이션, 경고창 팝업 구현

# 1-4. 데이터 설계

# 개체-관계 모델 (ERD)

## ✅ 개체-관계 모델(ER 모델, ERD)이란?

> **Entity-Relationship Model (개체-관계 모델)**은
>  시스템에 필요한 **데이터와 데이터 간의 관계를 시각적으로 표현**한 모델이야.

여기서 ‘ERD’는 **Entity-Relationship Diagram**의 약자로,
 이 모델을 **도식화한 다이어그램**을 말해.

## 📂 ERD의 구성 요소 3대장

| 요소                    | 의미                          | 표기     |
| ----------------------- | ----------------------------- | -------- |
| **Entity (개체)**       | 데이터로 저장할 대상 (명사형) | □ 사각형 |
| **Attribute (속성)**    | 개체의 성질, 값               | ○ 타원형 |
| **Relationship (관계)** | 개체 간의 연관성 (동사형)     | ◆ 마름모 |

## 1️⃣ **Entity (개체)**

### ● 정의

데이터베이스에 **저장할 수 있는 독립적인 객체**

### ● 종류

| 종류              | 설명                               | 예시                        |
| ----------------- | ---------------------------------- | --------------------------- |
| **Strong Entity** | 고유 식별자(ID)를 가지는 일반 개체 | 학생, 도서, 주문 등         |
| **Weak Entity**   | ID 없이 다른 개체에 의존           | 주문 상세, 사원 부양가족 등 |

### ● 예시

- `학생(Student)`
- `상품(Product)`
- `게시글(Post)`

## 2️⃣ **Attribute (속성)**

### ● 정의

Entity의 **특징을 설명하는 속성값**

### ● 속성의 종류

| 종류            | 설명                    | 예시                       |
| --------------- | ----------------------- | -------------------------- |
| **기본 속성**   | 고유 정보               | 이름, 생년월일             |
| **식별자(ID)**  | Entity를 구분           | 학번, 주민번호             |
| **복합 속성**   | 여러 속성의 조합        | 주소 = 시+구+도로명        |
| **다중값 속성** | 여러 값을 가질 수 있음  | 전화번호 (복수 가능)       |
| **파생 속성**   | 다른 속성으로 계산 가능 | 나이 = 현재연도 - 생년월일 |

## 3️⃣ **Relationship (관계)**

### ● 정의

개체 간의 **논리적 연결**을 표현하는 요소

### ● 관계 차수(Cardinality)

| 관계    | 설명                                     | 예시 |
| ------- | ---------------------------------------- | ---- |
| **1:1** | 학생 - 사물함 (1명당 1개)                |      |
| **1:N** | 교수 - 수업 (1명 교수 여러 수업)         |      |
| **M:N** | 학생 - 과목 (여러 학생이 여러 과목 수강) |      |

※ `M:N` 관계는 **별도의 교차 엔터티(Entity)**로 바꿔야 실제 DB 설계 가능

## 🔁 ERD 작성 순서 (실무 기준)

```
1. 개체 도출 → 2. 속성 정리 → 3. 관계 정의 → 4. 키 설정 → 5. 정규화
```

## 📐 ERD 표기법 요약 (Crow’s Foot Notation 기준)

| 기호 | 의미                       |
| ---- | -------------------------- |
| —    | 일대일 (One-to-One) 관계   |
| <—   | 일대다 (One-to-Many) 관계  |
| <—>  | 다대다 (Many-to-Many) 관계 |
| PK   | Primary Key (기본키)       |
| FK   | Foreign Key (외래키)       |

## ✨ ERD 예시 (텍스트 기반)

```
[학생] -------< 수강 >-------- [과목]

학생(Student)
---------------------
PK 학번 (student_id)
이름
학년

과목(Course)
---------------------
PK 과목코드 (course_id)
과목명
학점

수강(Enrollment)
---------------------
PK student_id
PK course_id
수강년도
성적
```

→ 이 구조는 학생과 과목이 **N:M 관계**이므로
 → 중간 테이블인 `수강`을 만들어 `1:N + N:1`로 분리함

## 🧠 ERD 설계 팁

| 팁                           | 설명                                      |
| ---------------------------- | ----------------------------------------- |
| 명사는 Entity, 동사는 관계로 | ex. 고객 “구매” 상품                      |
| 속성은 항상 단일값           | ex. 전화번호 2개 → 별도 테이블 분리       |
| 관계는 가능하면 1:N으로 정리 | M:N은 교차 테이블로 풀어야 구현 가능      |
| 이름은 일관성 있게           | 테이블명은 단수형 추천 (User, Product 등) |

## ✅ 실전 ERD 작성 도구

| 도구                                       | 특징                    |
| ------------------------------------------ | ----------------------- |
| **ERDCloud (무료)**                        | 웹 기반, 협업 가능      |
| **dbdiagram.io**                           | 간편한 텍스트 기반 생성 |
| **Lucidchart / Draw.io**                   | 범용 도식 도구, 직관적  |
| **MySQL Workbench / Oracle SQL Developer** | 실제 DB 설계 연동 가능  |

## 📄 ERD는 실제 SQL 테이블 설계의 뼈대가 된다

> ERD → 정규화 → 스키마 작성 → SQL 구현

예를 들어:

```sql
CREATE TABLE Student (
  student_id VARCHAR(10) PRIMARY KEY,
  name VARCHAR(20),
  year INT
);
```

→ 위 코드는 ERD에서 나온 "학생" 엔터티를 SQL로 구현한 예야.

# 정규화 / 반정규화

## ✅ 정규화(Normalization)란?

> 정규화는 **데이터 중복을 제거하고 이상(Anomaly)을 방지하기 위해 테이블을 논리적으로 분해**하는 과정이야.
>  즉, **일관성 있고, 중복 없는 데이터 구조를 만드는 과정**이라고 보면 돼.

## 📂 정규화의 목적

| 목적                 | 설명                               |
| -------------------- | ---------------------------------- |
| ✅ 중복 제거          | 동일한 데이터의 반복 저장 방지     |
| ✅ 이상 방지          | 삽입, 수정, 삭제 시 오류 발생 제거 |
| ✅ 데이터 무결성 확보 | 데이터 구조가 명확하게 정의됨      |
| ✅ 유지보수 용이      | 데이터 변경 시 한 곳만 고치면 됨   |

## 📈 정규화 단계별 정리 (1NF ~ 3NF + BCNF)

### 1️⃣ 제1정규형 (1NF: First Normal Form)

#### ● 조건

- **원자값(Atomic Value)**만 허용 → 하나의 셀에 하나의 값만

#### ● 위반 예시

| 학번 | 이름   | 전화번호           |
| ---- | ------ | ------------------ |
| 1001 | 홍길동 | 010-1111, 010-2222 |

→ 전화번호가 **여러 개** 저장됨 → 원자값 아님

#### ● 해결

| 학번 | 이름   | 전화번호 |
| ---- | ------ | -------- |
| 1001 | 홍길동 | 010-1111 |
| 1001 | 홍길동 | 010-2222 |

### 2️⃣ 제2정규형 (2NF: Second Normal Form)

#### ● 조건

- 1NF 만족 + **기본키의 부분 종속 제거**

#### ● 예시

| 학번 | 과목명 | 교수명 |
| ---- | ------ | ------ |
| 1001 | DB     | 김교수 |
| 1001 | OS     | 이교수 |

→ ‘과목명 → 교수명’은 학번과 **무관**한 정보 → **부분 함수 종속**

#### ● 해결

- `학생-과목` 테이블
- `과목-교수` 테이블

### 3️⃣ 제3정규형 (3NF: Third Normal Form)

#### ● 조건

- 2NF 만족 + **이행적 함수 종속 제거**

#### ● 예시

| 학번 | 학과코드 | 학과이름     |
| ---- | -------- | ------------ |
| 1001 | D01      | 컴퓨터공학과 |

→ ‘학번 → 학과코드 → 학과이름’은 **이행 종속**

#### ● 해결

- `학생(학번, 학과코드)`
- `학과(학과코드, 학과이름)`

### 🧠 추가 정규형

#### ● BCNF (Boyce-Codd Normal Form)

- 3NF보다 엄격한 형태
- 모든 결정자가 후보키가 되어야 함

## 💣 이상 현상(Anomalies)이란?

| 종류          | 설명                                        | 예시                                 |
| ------------- | ------------------------------------------- | ------------------------------------ |
| **삽입 이상** | 일부 속성 때문에 데이터 삽입 불가           | 과목 없이 교수 정보를 저장할 수 없음 |
| **삭제 이상** | 일부 데이터만 지웠는데 관련 정보까지 삭제됨 | 수강 취소 시 교수 정보도 삭제됨      |
| **갱신 이상** | 중복 데이터로 인해 모든 곳을 수정해야 함    | 교수 이름이 여러 행에 반복           |

→ 정규화로 이런 이상을 방지할 수 있음

## 🔁 반정규화(Denormalization)란?

> 반정규화는 정규화된 테이블을 **성능 향상 목적**으로 다시 일부 병합하거나 **중복을 허용**하는 것

## 📂 반정규화의 목적

| 목적               | 설명                                     |
| ------------------ | ---------------------------------------- |
| ⚡ 조회 성능 향상   | JOIN 없이도 원하는 데이터 바로 조회 가능 |
| 🛠️ 시스템 부하 감소 | 불필요한 테이블 연결 제거                |
| 📉 복잡도 감소      | 테이블 수 줄이기, 쿼리 단순화            |

## 🔧 반정규화 기법

| 기법        | 설명                                    |
| ----------- | --------------------------------------- |
| 테이블 병합 | 자주 JOIN 되는 테이블을 하나로 합침     |
| 컬럼 중복   | 자주 쓰는 값을 여러 테이블에 중복 저장  |
| 요약 테이블 | 집계 결과를 미리 계산해 저장            |
| 속성 분할   | 자주 조회되는 컬럼을 분리하여 속도 향상 |

## 🔁 정규화 vs 반정규화 비교

| 항목        | 정규화                | 반정규화                    |
| ----------- | --------------------- | --------------------------- |
| 목적        | 데이터 일관성, 무결성 | 성능, 응답속도 향상         |
| 테이블 수   | 증가                  | 감소 가능                   |
| 데이터 중복 | 최소화                | 일부 중복 허용              |
| JOIN 연산   | 증가                  | 감소                        |
| 사용 시점   | 설계 초기             | 성능 튜닝, 실무 최적화 시점 |

## 📌 실무 적용 예시

| 상황                 | 설계                              |
| -------------------- | --------------------------------- |
| 기획 초기, 구조 설계 | 정규화: 데이터 이상 방지 우선     |
| 대용량 트래픽 처리   | 반정규화: 쿼리 속도, 병목 제거    |
| 읽기 위주 시스템     | 반정규화가 유리 (ex. 검색 시스템) |
| 잦은 업데이트 시스템 | 정규화가 유리 (ex. 금융 거래 DB)  |

## ✅ 요약 정리

| 개념           | 핵심                                     |
| -------------- | ---------------------------------------- |
| **정규화**     | 중복 제거, 이상 방지, 데이터 무결성 유지 |
| **반정규화**   | 성능 향상, 일부 중복 허용                |
| 언제 정규화?   | 설계 초기, 유지보수 중점 시스템          |
| 언제 반정규화? | 성능 병목 발생 시, 대용량 트래픽 처리    |

# 트랜잭션 설계

## ✅ 트랜잭션(Transaction)이란?

> **하나의 논리적 작업을 구성하는 일련의 데이터베이스 연산의 집합**
>  트랜잭션은 전부 실행되거나, 전부 실행되지 않아야 한다.

### ● 예시

- 은행 이체:
   A → B 계좌로 이체할 때
   `A 계좌 차감 → B 계좌 증가`가 한 덩어리로 처리되어야 함
   (중간에 멈추면 데이터 불일치 발생)

## 🧩 트랜잭션의 4대 특성 (ACID)

| 특성                         | 설명                                              | 중요도           |
| ---------------------------- | ------------------------------------------------- | ---------------- |
| **A - Atomicity (원자성)**   | 전부 실행되거나 전부 취소되어야 함                | 실패 시 롤백     |
| **C - Consistency (일관성)** | 트랜잭션 실행 전후 상태가 항상 유효한 상태여야 함 | 무결성 유지      |
| **I - Isolation (격리성)**   | 동시에 실행되는 트랜잭션이 서로 간섭하지 않도록   | 동시성 문제 해결 |
| **D - Durability (지속성)**  | 성공한 트랜잭션의 결과는 영구 반영되어야 함       | 전원 꺼져도 유지 |

## 📂 트랜잭션 설계 흐름 (개발자 시점)

```
1. 트랜잭션 범위 정의
→ 2. 롤백 포인트 고려
→ 3. 동시성 처리 고려
→ 4. 커밋 타이밍 명확화
→ 5. 장애 시 복구 전략 수립
```

## 1️⃣ 트랜잭션 범위 정의

### ● 의미

- 어디부터 어디까지가 **하나의 논리 작업 단위인지 결정**

### ● 예시

```sql
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 1000 WHERE id = 'A';
UPDATE accounts SET balance = balance + 1000 WHERE id = 'B';

COMMIT;
```

→ 이 전체 블록이 **1개의 트랜잭션**

## 2️⃣ 롤백 포인트 설계 (SAVEPOINT)

- 트랜잭션 내에서 **중간 상태를 저장**하고, 필요 시 해당 시점까지 되돌릴 수 있도록 설계

```sql
BEGIN;
UPDATE ...;
SAVEPOINT step1;
UPDATE ...;
ROLLBACK TO step1;
COMMIT;
```

→ 전체 취소는 아니고, 특정 지점까지만 되돌릴 수 있음

## 3️⃣ 동시성 제어 (Concurrency Control)

### ● 트랜잭션 간 충돌 방지 필요

| 문제                    | 설명                        | 예시                           |
| ----------------------- | --------------------------- | ------------------------------ |
| **Dirty Read**          | 커밋되지 않은 데이터를 읽음 | 다른 트랜잭션의 임시 변경 읽음 |
| **Non-repeatable Read** | 같은 쿼리인데 결과가 다름   | 중간에 다른 트랜잭션이 값 변경 |
| **Phantom Read**        | 조건 쿼리 결과가 달라짐     | 중간에 새로운 행이 추가됨      |

### ● 해결 방법: 격리 수준(Isolation Level)

| 수준             | 설명                      | 허용하는 문제                  |
| ---------------- | ------------------------- | ------------------------------ |
| READ UNCOMMITTED | 커밋되지 않은 것도 읽음   | Dirty Read 발생 가능           |
| READ COMMITTED   | 커밋된 데이터만 읽음      | Non-repeatable Read 가능       |
| REPEATABLE READ  | 동일한 행은 동일하게 읽힘 | Phantom Read 가능              |
| SERIALIZABLE     | 완전 격리                 | 가장 안전하지만 성능 저하 가능 |

## 4️⃣ 커밋/롤백 타이밍

- **트랜잭션이 언제 끝날지**를 명확히 설계해야 함

| 상황      | 처리 방식                    |
| --------- | ---------------------------- |
| 정상 종료 | COMMIT 수행                  |
| 오류 발생 | ROLLBACK 수행                |
| 중간 오류 | SAVEPOINT + ROLLBACK TO 사용 |

## 5️⃣ 장애 및 복구 전략

| 기술                      | 설명                                   |
| ------------------------- | -------------------------------------- |
| WAL (Write Ahead Logging) | 변경 로그를 먼저 기록하여 복구에 활용  |
| REDO / UNDO               | 트랜잭션 로그를 통해 재적용/취소       |
| Crash Recovery            | 장애 발생 시 마지막 커밋까지 복원 보장 |

## 🧠 실무 설계 팁

| 설계 포인트                  | 설명                                |
| ---------------------------- | ----------------------------------- |
| 짧고 명확한 범위로 묶기      | 트랜잭션 길어지면 락 지속됨         |
| 상태값 기반 롤백 설계        | 처리 단계별 체크포인트              |
| 자동 커밋 주의               | 일부 DB에서는 DML 후 자동 커밋 발생 |
| 복수 트랜잭션 간 종속성 제거 | A가 B 기다리는 구조 지양            |

## ✅ 트랜잭션 설계 실습 예시

```sql
-- 1. 예금 이체 처리 예시
BEGIN;

UPDATE account SET balance = balance - 50000 WHERE id = 'A';
UPDATE account SET balance = balance + 50000 WHERE id = 'B';

COMMIT;
```

```sql
-- 2. 중간 실패 시 롤백 처리
BEGIN;

UPDATE inventory SET quantity = quantity - 1 WHERE product_id = 1001;
SAVEPOINT before_order;
INSERT INTO orders VALUES (...);
-- 예: 오류 발생
ROLLBACK TO before_order;

COMMIT;
```

## 📌 요약 정리

| 항목      | 설명                                     |
| --------- | ---------------------------------------- |
| 트랜잭션  | 데이터 일관성 유지를 위한 논리 작업 단위 |
| ACID      | 원자성, 일관성, 격리성, 지속성           |
| 격리 수준 | 충돌 방지 전략, 성능과 안전성의 균형     |
| 설계 팁   | 범위 명확히, 롤백 전략 포함, 동시성 고려 |

# 무결성 제약조건

## ✅ 무결성 제약조건(Integrity Constraint)이란?

> 데이터베이스에 **저장되는 데이터가 올바르고 일관된 상태를 유지하도록 보장하는 규칙**이야.

쉽게 말하면,
 **"이상한 값이 들어오지 못하게 막는 데이터베이스의 안전 장치"**라고 보면 돼.

## 📂 무결성 제약조건의 종류 총정리

| 제약조건        | 설명                                | 예시                              |
| --------------- | ----------------------------------- | --------------------------------- |
| **NOT NULL**    | 반드시 값이 있어야 함 (NULL 금지)   | 이름, 이메일                      |
| **UNIQUE**      | 중복된 값을 허용하지 않음           | 주민번호, 이메일                  |
| **PRIMARY KEY** | 테이블의 식별자 (UNIQUE + NOT NULL) | 사용자 ID                         |
| **FOREIGN KEY** | 다른 테이블의 키를 참조             | 주문의 고객 ID → 고객 테이블 참조 |
| **CHECK**       | 특정 조건을 만족해야 함             | 나이 ≥ 0, 점수 ≤ 100              |
| **DEFAULT**     | 값이 없을 경우 기본값 지정          | 가입일 = 현재날짜                 |

## 1️⃣ NOT NULL 제약

> 특정 컬럼은 **반드시 값이 있어야 함**

```sql
CREATE TABLE user (
  id INT,
  name VARCHAR(20) NOT NULL
);
```

→ `name`에 NULL 넣으면 오류 발생

## 2️⃣ UNIQUE 제약

> **중복 값 불허**. 단, NULL은 허용

```sql
CREATE TABLE user (
  email VARCHAR(100) UNIQUE
);
```

→ 같은 이메일 2번 삽입 시 오류
 → 단, NULL 값은 여러 번 가능 (DBMS마다 다름)

## 3️⃣ PRIMARY KEY 제약

> **UNIQUE + NOT NULL**을 동시에 만족
>  하나의 테이블에 **오직 하나만** 존재 가능

```sql
CREATE TABLE user (
  user_id INT PRIMARY KEY,
  name VARCHAR(20)
);
```

→ 이 테이블에서 `user_id`가 중복되거나 NULL이면 에러

## 4️⃣ FOREIGN KEY 제약 (참조 무결성)

> 다른 테이블의 **기본키(또는 고유키)를 참조**
>  관계형 데이터베이스의 핵심!

```sql
CREATE TABLE order (
  order_id INT PRIMARY KEY,
  user_id INT,
  FOREIGN KEY (user_id) REFERENCES user(user_id)
);
```

→ `order.user_id` 값은 반드시 `user` 테이블의 `user_id` 중 하나여야 함

### ● 삭제/수정 연계 옵션

| 옵션                 | 설명                            |
| -------------------- | ------------------------------- |
| `ON DELETE CASCADE`  | 부모 삭제 시 자식도 삭제        |
| `ON DELETE SET NULL` | 부모 삭제 시 자식 값 NULL       |
| `ON DELETE RESTRICT` | 부모 삭제 시 자식 존재하면 오류 |

## 5️⃣ CHECK 제약

> 입력되는 값이 **특정 조건을 만족해야 함**

```sql
CREATE TABLE student (
  id INT,
  score INT CHECK (score >= 0 AND score <= 100)
);
```

→ `score` 값이 0~100 범위 벗어나면 오류 발생

## 6️⃣ DEFAULT 제약

> 값을 입력하지 않으면 **기본값으로 자동 설정**

```sql
CREATE TABLE board (
  id INT,
  created_at DATE DEFAULT CURRENT_DATE
);
```

→ `created_at`을 생략하면 자동으로 오늘 날짜 삽입

## 📄 제약조건 종합 예시

```sql
CREATE TABLE employee (
  emp_id INT PRIMARY KEY,
  name VARCHAR(30) NOT NULL,
  email VARCHAR(100) UNIQUE,
  dept_id INT,
  salary INT CHECK (salary > 0),
  hired_at DATE DEFAULT CURRENT_DATE,
  FOREIGN KEY (dept_id) REFERENCES department(dept_id)
);
```

## ⚠️ 무결성 제약 위반 시 예외 처리

| 상황             | 예시                      | 오류 메시지 |
| ---------------- | ------------------------- | ----------- |
| NOT NULL 위반    | name에 NULL 삽입          | `ORA-01400` |
| UNIQUE 위반      | 중복 이메일               | `ORA-00001` |
| FOREIGN KEY 위반 | 존재하지 않는 사용자 참조 | `ORA-02291` |
| CHECK 위반       | 점수 -10 삽입             | `ORA-02290` |

## ✅ 무결성 설계 시 주의사항

| 항목                  | 설명                                            |
| --------------------- | ----------------------------------------------- |
| PK는 반드시 지정하자  | 실무에서는 모든 테이블에 기본키 필요            |
| FK는 성능 이슈 고려   | 외래키 많으면 삽입/삭제 느려짐                  |
| CHECK는 간단하게      | 복잡한 조건은 트리거나 애플리케이션 쪽에서 처리 |
| DEFAULT는 일관성 있게 | 날짜, 상태값 등에 자주 사용됨                   |

## ✅ 요약 정리

| 제약조건        | 핵심 요약                |
| --------------- | ------------------------ |
| **NOT NULL**    | 값이 반드시 존재해야 함  |
| **UNIQUE**      | 중복 불가                |
| **PRIMARY KEY** | 행의 식별자, 반드시 존재 |
| **FOREIGN KEY** | 참조 관계 유지           |
| **CHECK**       | 조건 만족 필요           |
| **DEFAULT**     | 기본값 자동 설정         |

# 2. **소프트웨어 개발**

# 2-1. 프로그래밍 언어 기초

# 절차지향 vs 객체지향

## ✅ 정의 비교

| 구분      | 절차지향 (Procedural)        | 객체지향 (Object-Oriented)  |
| --------- | ---------------------------- | --------------------------- |
| 핵심 개념 | **순차적인 절차(명령)** 중심 | **객체와 메시지** 중심      |
| 단위      | 함수, 루틴                   | 객체(Object), 클래스(Class) |
| 사고 방식 | "무엇을 먼저 할까?"          | "누가 무엇을 할까?"         |
| 대표 언어 | C, Pascal                    | Java, Python, C++, Kotlin   |

## 🧠 핵심 차이 요약

| 항목      | 절차지향                     | 객체지향                         |
| --------- | ---------------------------- | -------------------------------- |
| 구조      | 기능(함수) 중심              | 데이터 + 기능 묶음 (클래스)      |
| 설계 방식 | **Top-down (위에서 아래로)** | **Bottom-up (조각 → 전체 구성)** |
| 재사용성  | 낮음 (코드 복사 중심)        | 높음 (클래스, 상속, 다형성)      |
| 유지보수  | 복잡도 증가 시 어려움        | 캡슐화로 비교적 쉬움             |
| 예시 질문 | "어떤 함수부터 실행할까?"    | "어떤 객체가 일을 담당하지?"     |

## 📂 구조적 예시 비교

### ✅ 절차지향 예시 (C 스타일)

```c
int balance = 1000;

void withdraw(int amount) {
    balance -= amount;
}

void deposit(int amount) {
    balance += amount;
}
```

* 전역 변수와 함수가 분리되어 있음 → 상태 추적이 어려움

### ✅ 객체지향 예시 (Java 스타일)

```java
class BankAccount {
    private int balance = 1000;

    public void withdraw(int amount) {
        balance -= amount;
    }

    public void deposit(int amount) {
        balance += amount;
    }
}

```

* 상태(`balance`)와 기능(`withdraw`, `deposit`)이 **같은 객체 안에 존재**

* 유지보수, 재사용, 확장성에서 유리

## 📦 주요 객체지향 개념 (4대 특성)

| 특성       | 설명                                   | 예시                            |
| ---------- | -------------------------------------- | ------------------------------- |
| **캡슐화** | 데이터와 기능을 클래스 내부로 감추기   | `private` 변수, `public` 메서드 |
| **상속**   | 기존 클래스 기능을 물려받기            | `class Student extends Person`  |
| **다형성** | 동일한 이름으로 다양한 동작            | `draw()`가 도형마다 다르게 동작 |
| **추상화** | 핵심만 드러내고 불필요한 정보는 숨기기 | 인터페이스, 추상 클래스         |

## 📈 프로그래밍 스타일 차이

| 항목        | 절차지향               | 객체지향                           |
| ----------- | ---------------------- | ---------------------------------- |
| 데이터 처리 | 데이터와 함수 분리     | 데이터와 기능 함께                 |
| 데이터 보호 | 불가능 (전역변수 위험) | 가능 (`private`, `protected`)      |
| 코드 확장   | 어려움                 | 인터페이스, 상속으로 유연함        |
| 설계 도구   | 플로우차트, 순서도     | UML 다이어그램 (클래스, 시퀀스 등) |

## 🔁 혼합형도 존재한다

| 언어       | 설명                                |
| ---------- | ----------------------------------- |
| Python     | 객체지향 지원하지만 절차지향도 가능 |
| JavaScript | 함수형 + 객체지향 혼합 사용         |
| C++        | 절차 + 객체지향 혼합 구조           |
| C          | 순수 절차지향 언어 (구조체만 있음)  |

## 📌 실무 적용 팁

| 상황                    | 추천 방식 | 이유                      |
| ----------------------- | --------- | ------------------------- |
| 간단한 알고리즘 처리    | 절차지향  | 빠르고 직관적             |
| 대규모 시스템 설계      | 객체지향  | 유지보수성과 확장성 유리  |
| 하드웨어 제어           | 절차지향  | 구조가 단순, 성능 우위    |
| 도메인 설계 중심 시스템 | 객체지향  | 비즈니스 모델 반영에 적합 |

## ✅ 요약 정리

| 구분      | 절차지향         | 객체지향                   |
| --------- | ---------------- | -------------------------- |
| 중심      | 기능             | 객체                       |
| 접근 방식 | 순서, 흐름       | 객체 간 메시지             |
| 대표 언어 | C, Pascal        | Java, C++, Python          |
| 구조      | 전역 변수 + 함수 | 클래스 + 메서드            |
| 강점      | 속도, 단순성     | 재사용성, 확장성, 유지보수 |

# C언어, Java, Python 기본 문법

## ✅ 언어별 특징 비교

| 항목        | C                          | Java                | Python                    |
| ----------- | -------------------------- | ------------------- | ------------------------- |
| 언어 유형   | 절차지향                   | 객체지향            | 인터프리터, 객체지향      |
| 실행 방식   | 컴파일                     | 컴파일 + JVM 실행   | 인터프리터 (즉시 실행)    |
| 메모리 관리 | 수동 (포인터, malloc/free) | 자동 (GC)           | 자동 (GC)                 |
| 문법 스타일 | 엄격, 세미콜론 필수        | 엄격, 세미콜론 필수 | 유연, 들여쓰기 기반       |
| 주요 용도   | 시스템, 임베디드           | 엔터프라이즈, 앱    | 웹, 데이터, AI, 자동화 등 |

## 📂 문법 비교 총정리

### 1️⃣ Hello, World 출력

```c
// C
#include <stdio.h>
int main() {
    printf("Hello, World\n");
    return 0;
}
```

```java
// Java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, World");
    }
}
```

```python
# Python
print("Hello, World")
```

### 2️⃣ 변수 선언과 자료형

| 항목   | C                    | Java                 | Python       |
| ------ | -------------------- | -------------------- | ------------ |
| 정수   | `int a = 10;`        | `int a = 10;`        | `a = 10`     |
| 실수   | `float f = 3.14f;`   | `float f = 3.14f;`   | `f = 3.14`   |
| 문자   | `char c = 'A';`      | `char c = 'A';`      | `c = 'A'`    |
| 문자열 | `char str[] = "Hi";` | `String str = "Hi";` | `str = "Hi"` |

### 3️⃣ 조건문

```c
if (a > 10) {
    printf("크다\n");
} else {
    printf("작거나 같다\n");
}
```

```java
if (a > 10) {
    System.out.println("크다");
} else {
    System.out.println("작거나 같다");
}
```

```python
if a > 10:
    print("크다")
else:
    print("작거나 같다")
```

### 4️⃣ 반복문 (for)

```c
for (int i = 0; i < 5; i++) {
    printf("%d\n", i);
}
```

```java
for (int i = 0; i < 5; i++) {
    System.out.println(i);
}
```

```python
for i in range(5):
    print(i)
```

### 5️⃣ 함수 (메서드)

```c
int add(int x, int y) {
    return x + y;
}
```

```java
public static int add(int x, int y) {
    return x + y;
}
```

```python
def add(x, y):
    return x + y
```

### 6️⃣ 배열 / 리스트

```c
int arr[3] = {1, 2, 3};
```

```java
int[] arr = {1, 2, 3};
```

```python
arr = [1, 2, 3]
```

### 7️⃣ 클래스 정의

```java
public class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }

    public void sayHi() {
        System.out.println("Hi, " + name);
    }
}
```

```python
class Person:
    def __init__(self, name):
        self.name = name

    def say_hi(self):
        print("Hi,", self.name)
```

> C는 클래스 개념이 없지만, `struct`로 유사하게 데이터 구조는 정의 가능

## ✅ 정리 표: 자주 쓰는 문법 비교

| 기능     | C                       | Java                   | Python               |
| -------- | ----------------------- | ---------------------- | -------------------- |
| 출력     | `printf()`              | `System.out.println()` | `print()`            |
| 입력     | `scanf()`               | `Scanner.next()`       | `input()`            |
| 문자열   | `char[]`, `string.h`    | `String` 객체          | 기본 문자열          |
| 반복문   | `for`, `while`          | `for`, `while`         | `for`, `while`       |
| 조건문   | `if`, `else if`, `else` | 동일                   | `if`, `elif`, `else` |
| 배열     | 정적 크기               | 객체형                 | 리스트               |
| 포인터   | 사용함                  | 없음                   | 없음                 |
| 클래스   | 없음 (`struct`)         | 기본                   | 기본                 |
| 예외처리 | 없음                    | `try-catch`            | `try-except`         |

## ✨ 결론: 언제 어떤 언어?

| 상황                    | 추천 언어                 |
| ----------------------- | ------------------------- |
| 시스템/임베디드         | C                         |
| 대규모 백엔드           | Java                      |
| 데이터 분석, 웹, 자동화 | Python                    |
| 입문 학습               | Python → Java → C 순 추천 |

# 자료형, 연산자, 제어문

## ✅ 1. 자료형(Data Types)

| 분류   | C                      | Java              | Python                                   |
| ------ | ---------------------- | ----------------- | ---------------------------------------- |
| 정수   | `int`, `short`, `long` | `int`, `long`     | `int` (자동 확장)                        |
| 실수   | `float`, `double`      | `float`, `double` | `float` (Python의 float은 double 정밀도) |
| 문자   | `char`                 | `char`            | `str` (문자열 하나도 문자열 취급)        |
| 문자열 | `char[]`, `string.h`   | `String` 클래스   | `str` 객체                               |
| 불리언 | 없음 (`0/1` 사용)      | `boolean`         | `bool` (`True`, `False`)                 |
| 기타   | 포인터 (`int*`)        | 참조 타입         | 리스트, 튜플, 딕셔너리 등                |

> 📌 Python은 변수 선언 시 자료형 지정이 필요 없음 (동적 타이핑)

## ✅ 2. 연산자(Operators)

### 📌 기본 연산자 비교

| 분류 | C                  | Java       | Python                 |
| ---- | ------------------ | ---------- | ---------------------- |
| 산술 | `+ - * / %`        | 동일       | 동일                   |
| 증감 | `++`, `--`         | 사용 가능  | ❌ 없음 (직접 `i += 1`) |
| 비교 | `== != > < >= <=`  | 동일       | 동일                   |
| 논리 | `&&`, `            |            | `, `!`                 |
| 대입 | `= += -= *= /=`    | 동일       | 동일                   |
| 비트 | `&                 | ^ ~ << >>` | 동일                   |
| 삼항 | `조건 ? 참 : 거짓` | 동일       | `a if 조건 else b`     |

### ✅ 예시: 산술 연산

```c
int a = 5 + 2;     // 7
int b = 10 % 3;    // 1
```

```java
int a = 5 + 2;
int b = 10 % 3;
```

```python
a = 5 + 2
b = 10 % 3
```

## ✅ 3. 제어문(Control Statements)

### 🔁 조건문 (if)

```c
if (x > 10) {
    printf("크다\n");
} else {
    printf("작다\n");
}
```

```java
if (x > 10) {
    System.out.println("크다");
} else {
    System.out.println("작다");
}
```

```python
if x > 10:
    print("크다")
else:
    print("작다")
```

### 🔁 switch 문 (Java, C만)

```c
switch (x) {
    case 1: printf("1\n"); break;
    case 2: printf("2\n"); break;
    default: printf("기타\n");
}
```

```java
switch (x) {
    case 1 -> System.out.println("1");
    case 2 -> System.out.println("2");
    default -> System.out.println("기타");
}
```

```python
# Python은 switch 없음 → if-elif-else로 대체
if x == 1:
    print("1")
elif x == 2:
    print("2")
else:
    print("기타")
```

### 🔁 반복문 (for, while)

#### ✅ for문

```c
for (int i = 0; i < 5; i++) {
    printf("%d\n", i);
}
```

```java
for (int i = 0; i < 5; i++) {
    System.out.println(i);
}
```

```python
for i in range(5):
    print(i)
```

#### ✅ while문

```c
int i = 0;
while (i < 5) {
    printf("%d\n", i);
    i++;
}
```

```java
int i = 0;
while (i < 5) {
    System.out.println(i);
    i++;
}
```

```python
i = 0
while i < 5:
    print(i)
    i += 1
```

### ✅ break / continue

| 키워드     | 설명                                    |
| ---------- | --------------------------------------- |
| `break`    | 반복문 **즉시 종료**                    |
| `continue` | **이번 루프만 건너뛰고** 다음 반복 진행 |

→ C, Java, Python **모두 동일하게 사용 가능**

## 🧠 정리 요약표

| 항목          | C               | Java  | Python             |
| ------------- | --------------- | ----- | ------------------ |
| 자료형 선언   | 강제            | 강제  | 자동               |
| 세미콜론 필수 | ✅               | ✅     | ❌                  |
| 들여쓰기      | 선택            | 선택  | **필수 (문법임)**  |
| 증감연산자    | `++`, `--` 있음 | 있음  | ❌ 없음             |
| switch 문     | 사용            | 사용  | ❌ 없음             |
| 삼항 연산     | `? :`           | `? :` | `a if cond else b` |

# 2-2. 객체지향 프로그래밍

# 클래스, 객체, 상속, 다형성

## ✅ 1. 클래스(Class)란?

> 클래스는 **객체(Object)를 만들기 위한 설계도**야.
>  변수(속성) + 함수(메서드)를 묶어 하나의 “타입”으로 정의한 것.

### 📘 Java 예제

```java
public class Person {
    String name;
    int age;

    public void greet() {
        System.out.println("Hello, " + name);
    }
}
```

### 🐍 Python 예제

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        print("Hello,", self.name)
```

### ⚙️ C언어는 클래스가 없음

→ 대신 `struct`와 함수 조합으로 비슷한 기능 구현 가능:

```c
typedef struct {
    char name[20];
    int age;
} Person;

void greet(Person* p) {
    printf("Hello, %s\n", p->name);
}

```

## ✅ 2. 객체(Object)란?

> 클래스는 "설계도"고, 객체는 그 설계도로 만든 **실제 인스턴스**

### Java

```java
Person p1 = new Person();
p1.name = "John";
p1.age = 30;
p1.greet();
```

### Python

```python
p1 = Person("John", 30)
p1.greet()
```

### C (구조체 기반)

```c
Person p1 = {"John", 30};
greet(&p1);
```

## ✅ 3. 상속(Inheritance)

> 상속은 기존 클래스를 확장하여 **새로운 클래스를 만드는 기능**
>  코드 재사용성, 계층적 설계에 매우 유리함

### Java

```java
class Animal {
    void sound() {
        System.out.println("소리");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("멍멍");
    }
}
```

### Python

```python
class Animal:
    def sound(self):
        print("소리")

class Dog(Animal):
    def sound(self):
        print("멍멍")

```

### C에서는 상속 불가

→ 대신 `struct` 중첩과 함수 포인터로 유사한 구조 구현 가능 (복잡함)

## ✅ 4. 다형성(Polymorphism)

> 다형성은 **동일한 이름의 메서드가 다른 클래스에서 다르게 동작**하는 것을 의미해
>  즉, 하나의 인터페이스로 다양한 동작을 가능하게 하는 것

### Java 예제

```java
Animal a = new Dog();  // 부모 타입으로 자식 객체 참조
a.sound();             // 멍멍 출력 (오버라이딩된 메서드 실행)
```

### Python 예제

```python
def make_sound(animal):
    animal.sound()

make_sound(Dog())      # 멍멍
make_sound(Cat())      # 야옹
```

→ Python은 **인터페이스 없이도 자동으로 다형성** 지원 (덕 타이핑)

### 오버라이딩 vs 오버로딩

| 개념       | 설명                                      | 예시                                                     |
| ---------- | ----------------------------------------- | -------------------------------------------------------- |
| 오버라이딩 | 부모 클래스의 메서드를 **재정의**         | `Dog.sound()`                                            |
| 오버로딩   | 메서드 이름은 같지만, **매개변수가 다름** | `add(int a, int b)` / `add(double a, double b)` (Java만) |

> Python은 오버로딩을 직접 지원하지 않음 → 디폴트 인자, *args 사용

## 🧠 정리 요약표

| 개념   | 설명        | Java              | Python         | C                |
| ------ | ----------- | ----------------- | -------------- | ---------------- |
| 클래스 | 설계도      | `class`           | `class`        | `struct`(유사)   |
| 객체   | 인스턴스    | `new`             | 직접 호출      | `struct` 변수    |
| 상속   | 클래스 확장 | `extends`         | `(Parent)`     | 직접 구현 어려움 |
| 다형성 | 동적 바인딩 | 메서드 오버라이딩 | 자동 덕 타이핑 | 직접 구현 복잡   |

# 추상화, 캡슐화

## ✅ 실무 적용 팁

| 개념   | 실무에서의 역할                  |
| ------ | -------------------------------- |
| 클래스 | 비즈니스 로직 구조화             |
| 객체   | 데이터 인스턴스 표현             |
| 상속   | 공통 로직 묶기, 중복 제거        |
| 다형성 | 인터페이스/전략 패턴 구현에 필수 |

# UML 다이어그램 (클래스, 시퀀스, 상태 등)

# 2-3. 알고리즘 및 자료구조

# 정렬, 탐색, 분할 정복, 그리디, DP

## ✅ 1. 정렬(Sorting)

> **데이터를 크기나 순서대로 재배열**하는 알고리즘

### ● 종류별 특징

| 알고리즘      | 시간복잡도      | 방식                    | 특징                  |
| ------------- | --------------- | ----------------------- | --------------------- |
| 선택 정렬     | O(n²)           | 비교 후 최소값 선택     | 가장 단순             |
| 버블 정렬     | O(n²)           | 인접 교환 반복          | 구현 쉬움             |
| 삽입 정렬     | O(n²)           | 앞에서 정렬된 곳에 삽입 | 거의 정렬된 경우 빠름 |
| **퀵 정렬**   | 평균 O(n log n) | 분할 정복 기반          | 빠르지만 최악 O(n²)   |
| **병합 정렬** | O(n log n)      | 분할 정복, 안정정렬     | 메모리 사용 ↑         |
| 힙 정렬       | O(n log n)      | 완전 이진 트리 기반     | 우선순위 큐 구현      |

### ● 예시 코드 (Python - 퀵 정렬)

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[0]
    left = [x for x in arr[1:] if x <= pivot]
    right = [x for x in arr[1:] if x > pivot]
    return quick_sort(left) + [pivot] + quick_sort(right)

```

## ✅ 2. 탐색(Searching)

> **특정 데이터를 찾는 알고리즘**

### ● 대표 기법

| 알고리즘  | 시간복잡도 | 조건        | 설명                  |
| --------- | ---------- | ----------- | --------------------- |
| 선형 탐색 | O(n)       | 무조건 가능 | 순차적으로 전부 탐색  |
| 이진 탐색 | O(log n)   | 정렬된 배열 | 중간값 기준 분할      |
| DFS       | O(V+E)     | 그래프 기반 | 깊이 우선 (재귀/스택) |
| BFS       | O(V+E)     | 그래프 기반 | 너비 우선 (큐 사용)   |

### ● 이진 탐색 예시 (Python)

```python
def binary_search(arr, target):
    left, right = 0, len(arr)-1
    while left <= right:
        mid = (left + right)//2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

```

## ✅ 3. 분할 정복(Divide and Conquer)

> 문제를 작게 나누고, 해결한 뒤 **결합하는 방식**

### ● 특징

- **재귀(recursion)** 기반
- 큰 문제 → 작은 문제로 나눠 해결

### ● 대표 예시

- **병합 정렬**
- **퀵 정렬**
- **이진 탐색**
- **행렬 제곱, 큰 수 곱셈**

### ● 구조 예시

```python
def divide_conquer(problem):
    if problem is 작을 때:
        return 정답
    left = divide_conquer(왼쪽 문제)
    right = divide_conquer(오른쪽 문제)
    return 결합(left, right)

```

## ✅ 4. 그리디(Greedy Algorithm)

> **매 순간 최선의 선택**을 해서 전체 최적을 찾는 전략

### ● 조건

- **탐욕 선택 속성(Greedy Choice Property)**
- **최적 부분 구조(Optimal Substructure)**

### ● 예시

- 동전 거스름돈 문제
- 회의실 배정
- 배낭 문제(단, 일부는 DP)
- Kruskal 알고리즘 (최소 신장 트리)

### ● 회의실 배정 예시 (Python)

```python
# 회의 시간 기준 정렬 후, 빨리 끝나는 회의부터 선택
meetings = sorted(meetings, key=lambda x: x[1])  # 종료 시간 기준 정렬
end = 0
count = 0
for s, e in meetings:
    if s >= end:
        count += 1
        end = e

```

## ✅ 5. 동적 계획법(DP: Dynamic Programming)

> **작은 문제의 정답을 저장해가며 큰 문제를 푸는 전략**
>  → “**중복되는 부분 문제**”가 존재할 때 사용

### ● 조건

- **최적 부분 구조**: 전체 최적이 부분 최적의 조합
- **중복 부분 문제**: 동일한 계산 반복됨

### ● 방식

| 방식      | 설명                   |
| --------- | ---------------------- |
| Top-Down  | 재귀 + 메모이제이션    |
| Bottom-Up | 반복문 + 테이블 채우기 |

### ● 피보나치 예시

```python
# Top-down (재귀 + 캐시)
memo = {}
def fib(n):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib(n-1) + fib(n-2)
    return memo[n]

```

```python
# Bottom-up (반복문)
def fib(n):
    dp = [0, 1]
    for i in range(2, n+1):
        dp.append(dp[i-1] + dp[i-2])
    return dp[n]

```

## 🔁 알고리즘 전략 비교

| 전략      | 핵심 아이디어  | 대표 문제           | 성격                 |
| --------- | -------------- | ------------------- | -------------------- |
| 정렬      | 순서대로 정렬  | 퀵, 병합, 힙 등     | 전처리 or 핵심 과정  |
| 탐색      | 원하는 값 찾기 | 이진 탐색, BFS/DFS  | 결정 문제            |
| 분할 정복 | 나누고 정복    | 병합정렬, 이진탐색  | 재귀적, 정렬 기반    |
| 그리디    | 순간 최적 선택 | 동전, 회의실, MST   | 빠르고 단순          |
| DP        | 작은 문제 저장 | 피보나치, 배낭, LIS | 중복 문제 해결, 느림 |

# 스택, 큐, 연결리스트, 트리, 그래프

## ✅ 1. 스택(Stack)

> **후입선출(LIFO)** 구조. 마지막에 넣은 것이 가장 먼저 나옴.

### ● 주요 연산

| 연산        | 설명                           |
| ----------- | ------------------------------ |
| `push(x)`   | 데이터 삽입                    |
| `pop()`     | 마지막 데이터 제거 및 반환     |
| `peek()`    | 최상단 값 확인 (제거하지 않음) |
| `isEmpty()` | 스택이 비었는지 확인           |

### ● 구조

```
TOP → [5] → [3] → [1] → (bottom)
```

### ● 예시 코드 (Python)

```python
stack = []
stack.append(1)      # push
stack.append(2)
x = stack.pop()      # 2
```

### ● 활용

- 괄호 검사
- DFS
- 웹 브라우저 뒤로 가기
- 재귀 함수 스택 프레임

## ✅ 2. 큐(Queue)

> **선입선출(FIFO)** 구조. 먼저 넣은 것이 먼저 나옴.

### ● 주요 연산

| 연산         | 설명              |
| ------------ | ----------------- |
| `enqueue(x)` | 데이터 삽입       |
| `dequeue()`  | 맨 앞 데이터 제거 |
| `peek()`     | 첫 값 확인        |
| `isEmpty()`  | 비었는지 확인     |

### ● 구조

```
Front → [1] [2] [3] → Rear
```

### ● 예시 코드 (Python - deque 사용)

```python
from collections import deque
q = deque()
q.append(1)     # enqueue
q.append(2)
x = q.popleft() # dequeue → 1

```

### ● 활용

- BFS
- CPU 작업 스케줄러
- 프린터 대기열

## ✅ 3. 연결리스트(Linked List)

> 노드들이 **포인터로 연결**된 리스트
>  삽입/삭제가 빠름, 인덱스 접근은 느림

### ● 종류

| 종류            | 설명                        |
| --------------- | --------------------------- |
| 단일 연결리스트 | `head → node → node → null` |
| 이중 연결리스트 | `prev ↔ node ↔ next`        |
| 원형 연결리스트 | 마지막 노드가 head를 가리킴 |

### ● 기본 구조

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

```

### ● 활용

- 구현 중심 문제
- 트리, 그래프의 내부 구조
- 음악 재생 리스트 등

## ✅ 4. 트리(Tree)

> 계층 구조를 표현하는 자료구조
>  **루트에서 시작**, 각 노드는 **0개 이상의 자식 노드**를 가짐

### ● 용어 정리

| 용어         | 설명                      |
| ------------ | ------------------------- |
| 루트 노드    | 가장 위의 시작 노드       |
| 리프 노드    | 자식 없는 노드            |
| 깊이(Depth)  | 루트로부터 거리           |
| 높이(Height) | 가장 깊은 노드까지의 거리 |

### ● 이진 트리 / 이진 탐색 트리(BST)

- 왼쪽 자식 < 부모 < 오른쪽 자식
- 평균 검색 시간: O(log n)

### ● 순회 방식

| 종류     | 설명                  |
| -------- | --------------------- |
| 전위순회 | Root → Left → Right   |
| 중위순회 | Left → Root → Right   |
| 후위순회 | Left → Right → Root   |
| 레벨순회 | BFS 방식 (Queue 사용) |

### ● 활용

- 이진 탐색
- 힙(Heap), 우선순위 큐
- 파서(parser), 디렉터리 구조

## ✅ 5. 그래프(Graph)

> 노드(정점) + 간선(연결)으로 이루어진 구조
>  현실 세계의 복잡한 관계를 모델링함

### ● 종류

| 구분                        | 예시                             |
| --------------------------- | -------------------------------- |
| 방향 그래프                 | (A → B)                          |
| 무방향 그래프               | A — B                            |
| 가중치 그래프               | (A → B, cost=5)                  |
| 연결 그래프 / 비연결 그래프 | 모든 정점이 연결되어 있음 / 아님 |

### ● 표현 방식

```python
# 인접 리스트
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D']
}

# 인접 행렬
matrix = [
    [0, 1, 1],
    [1, 0, 1],
    [1, 1, 0]
]
```

### ● 그래프 탐색

| 방식 | 설명           | 사용 자료구조 |
| ---- | -------------- | ------------- |
| DFS  | 깊이 우선 탐색 | 스택 (재귀)   |
| BFS  | 너비 우선 탐색 | 큐            |

## 📌 요약 정리표

| 자료구조       | 핵심 특징     | 시간 복잡도               | 활용                      |
| -------------- | ------------- | ------------------------- | ------------------------- |
| **스택**       | LIFO          | push/pop O(1)             | 재귀, DFS                 |
| **큐**         | FIFO          | enqueue/dequeue O(1)      | BFS, 대기열               |
| **연결리스트** | 포인터로 연결 | 삽입/삭제 O(1), 탐색 O(n) | 유동적 구조               |
| **트리**       | 계층적        | 탐색 O(log n, 평균)       | 검색, 정렬, 힙            |
| **그래프**     | 복잡한 관계   | V+E 기반                  | 경로 탐색, 지도, 네트워크 |

# 시간복잡도, 공간복잡도

## ✅ 시간복잡도(Time Complexity)

> 입력 크기 $n$에 따라 **연산 횟수가 얼마나 증가하는지**를 분석하는 것
>  → 알고리즘의 **속도**를 정량적으로 평가

### 🔢 대표 시간복잡도 종류

| 표기          | 의미                       | 예시                   |
| ------------- | -------------------------- | ---------------------- |
| $O(1)$        | 상수 시간 (입력 크기 무관) | 변수 1개 출력          |
| $O(\log n)$   | 로그 시간                  | 이진 탐색              |
| $O(n)$        | 선형 시간                  | 선형 탐색              |
| $O(n \log n)$ | 선형로그                   | 병합정렬, 퀵정렬(평균) |
| $O(n^2)$      | 이차 시간                  | 이중 반복문            |
| $O(2^n)$      | 지수 시간                  | 모든 부분집합 탐색     |
| $O(n!)$       | 팩토리얼                   | 순열, 완전탐색         |

### ✅ 빅오(Big-O) 표기법

> **최악의 경우**를 기준으로 성능 분석
>  → 입력이 커질수록 어느 정도로 **느려지는지** 평가

```python
# O(n)
for i in range(n):
    print(i)

# O(n^2)
for i in range(n):
    for j in range(n):
        print(i, j)

```

### 🧠 실전 예시: 리스트 검색

```python
def find(x, arr):  # O(n)
    for i in arr:
        if i == x:
            return True
    return False

```

## ✅ 공간복잡도(Space Complexity)

> 입력 크기 $n$에 따라 **얼마나 많은 메모리를 사용하는지** 분석
>  → 알고리즘이 **얼마나 공간 효율적인지** 측정

### 구성 요소

| 항목      | 설명                                     |
| --------- | ---------------------------------------- |
| 고정 공간 | 변수, 상수 등 → O(1)                     |
| 입력 공간 | 입력 자체 저장에 필요한 메모리           |
| 추가 공간 | 리스트, 스택, 재귀 호출 등 임시 자료구조 |

### 예시 비교

```python
# 공간복잡도 O(1)
def sum(arr):
    total = 0
    for x in arr:
        total += x
    return total

```

```python
# 공간복잡도 O(n)
def copy(arr):
    return arr[:]  # 전체 복사 → 입력 크기만큼 메모리 추가

```

## 🔁 시간복잡도 vs 공간복잡도 비교

| 항목   | 시간복잡도       | 공간복잡도            |
| ------ | ---------------- | --------------------- |
| 의미   | 실행 시간 증가율 | 메모리 사용 증가율    |
| 단위   | 연산 횟수        | 메모리 크기           |
| 중요도 | 속도 최적화 중심 | 메모리 제한 문제 해결 |
| 예시   | 정렬, 탐색 등    | DP 테이블, 캐시 등    |

## ⚠️ 시간복잡도 계산 팁

1. **중첩 반복문**: 반복 횟수 곱하기
    → `for i in range(n): for j in range(n):` → $O(n^2)$
2. **재귀 호출**: 호출 횟수 × 호출당 연산
    → 피보나치 재귀: $O(2^n)$
3. **정렬 포함 알고리즘**: 최소 $O(n \log n)$
4. **여러 단계가 합쳐진 경우**: 가장 큰 항만 고려
    → $O(n^2 + n) = O(n^2)$

## 📌 알고리즘별 복잡도 예시

| 알고리즘       | 시간복잡도                  | 공간복잡도                |
| -------------- | --------------------------- | ------------------------- |
| 선형 탐색      | O(n)                        | O(1)                      |
| 이진 탐색      | O(log n)                    | O(1)                      |
| 퀵 정렬        | O(n log n) 평균, O(n²) 최악 | O(log n)                  |
| 병합 정렬      | O(n log n)                  | O(n)                      |
| DFS / BFS      | O(V + E)                    | O(V) (방문 배열, 큐/스택) |
| DP (배낭 문제) | O(nW)                       | O(nW) (테이블 크기)       |

## ✅ 요약 정리

| 구분       | 설명               | 예시                  |
| ---------- | ------------------ | --------------------- |
| 시간복잡도 | 실행 시간 측정     | O(n), O(n²), O(log n) |
| 공간복잡도 | 메모리 사용량 측정 | O(1), O(n)            |
| 계산 기준  | 입력 크기 증가     | 반복 횟수, 배열 크기  |
| 목표       | 성능 향상          | 메모리 절약           |

# 2-4. 소프트웨어 테스트

# 테스트 레벨 (단위, 통합, 시스템)

## ✅ 테스트 레벨(Test Levels)이란?

> 소프트웨어 개발 생명주기(SDLC)의 각 단계에 따라
>  **테스트를 수행하는 범위와 관점**이 달라지는 것을 말해.
>
> 개발자가 작성한 코드에서 시작해,
>  모듈 조합 → 전체 시스템 → 사용자 환경까지 순차적으로 검증하게 돼.

## 📂 테스트 레벨 종류 정리표

| 테스트 레벨       | 테스트 대상          | 수행 주체       | 목적                 |
| ----------------- | -------------------- | --------------- | -------------------- |
| **단위 테스트**   | 클래스, 함수, 메서드 | 개발자          | 코드 논리 검증       |
| **통합 테스트**   | 모듈 간 연결         | 개발자 / 테스터 | 인터페이스 오류 탐지 |
| **시스템 테스트** | 전체 시스템          | 독립 QA 팀      | 요구사항 전체 검증   |

## 1️⃣ 단위 테스트 (Unit Test)

### ● 정의

- **하나의 함수/클래스/메서드**가 올바르게 동작하는지를 테스트
- 가장 작은 코드 조각 수준의 테스트

### ● 목적

- 로직, 알고리즘, 조건 분기 등의 **정확한 동작 검증**
- 조기 오류 발견 → 유지보수 비용 절감

### ● 특징

| 항목               | 설명                |
| ------------------ | ------------------- |
| 빠름               | 코드 한 조각만 검증 |
| 자동화 용이        | JUnit, pytest 등    |
| 모킹(Mocking) 활용 | 외부 의존성 제거    |

### ● 도구

- Java: JUnit, TestNG
- Python: pytest, unittest
- JavaScript: Jest, Mocha

### ● 예시 (Python - pytest)

```python
def add(a, b):
    return a + b

def test_add():
    assert add(2, 3) == 5

```

## 2️⃣ 통합 테스트 (Integration Test)

### ● 정의

- **모듈/클래스/컴포넌트 간의 상호작용**을 검증하는 테스트
- 단위 테스트가 끝난 모듈을 **조합하여 데이터 흐름, API 호출, DB 연동 등을 검증**

### ● 목적

- **모듈 간 인터페이스 오류, 의존성 문제** 사전 발견
- 네트워크, DB, 외부 API 연동 검증

### ● 전략

| 방식        | 설명                                           |
| ----------- | ---------------------------------------------- |
| 빅뱅 방식   | 모든 모듈을 한 번에 결합 → 위험 ↑              |
| 점증적 방식 | 하나씩 연결하며 점진적 테스트 (상향/하향/혼합) |
| 하향식      | 상위 모듈부터, 스텁 사용                       |
| 상향식      | 하위 모듈부터, 드라이버 사용                   |

### ● 도구

- Java: Spring @WebMvcTest, Mockito
- Python: requests + unittest
- Postman (API 통합 테스트)

### ● 예시 시나리오

- 로그인 모듈 → 사용자 DB → 인증 서버 간 흐름 검증
- 주문 → 결제 모듈 → 알림 시스템

## 3️⃣ 시스템 테스트 (System Test)

### ● 정의

- 개발이 완료된 **전체 시스템을 실제 환경에서 테스트**
- 기능, 성능, 보안 등 모든 요구사항을 통합적으로 검증

### ● 목적

- 요구사항 명세서 기반으로 **시스템이 전체적으로 잘 작동하는지** 확인
- 제품 출시 전 품질 보장

### ● 테스트 종류 (시스템 레벨에서 수행)

| 항목          | 설명                                       |
| ------------- | ------------------------------------------ |
| 기능 테스트   | 버튼, 입력, 출력 등 요구된 기능 검증       |
| 비기능 테스트 | 성능, 부하, 보안, 접근성 등                |
| 회귀 테스트   | 변경 사항이 기존 기능에 영향 미치는지 확인 |

### ● 도구

- Selenium (UI 자동화)
- JMeter (성능)
- OWASP ZAP (보안)
- Robot Framework (통합 시나리오)

### ● 예시

- 사용자가 상품을 장바구니에 담고, 결제 후 이메일 수신까지 전 과정 검증
- 모바일 앱에서 화면 전환, 로딩 시간, 알림 수신 테스트

## 🧠 정리 요약표

| 구분   | 단위(Unit)        | 통합(Integration) | 시스템(System)            |
| ------ | ----------------- | ----------------- | ------------------------- |
| 범위   | 함수/클래스       | 모듈/서브시스템   | 전체 제품                 |
| 주체   | 개발자            | 개발자, 테스터    | QA 팀                     |
| 목적   | 내부 로직 정확성  | 모듈 연결성 검증  | 요구사항 충족 여부        |
| 예시   | 함수 add() 테스트 | 로그인 + DB 연동  | 로그인 → 결제 → 알림 흐름 |
| 자동화 | 쉬움              | 중간              | 도구 다양                 |

### ✅ 실무 테스트 순서

```
1. 단위 테스트 (TDD)
→ 2. 통합 테스트 (모듈 결합)
→ 3. 시스템 테스트 (전체 품질 검증)
→ (4. 인수 테스트: 고객 관점)
```

# 테스트 기법 (명세 기반, 구조 기반)

## ✅ 테스트 기법(Test Techniques)이란?

> 테스트 설계 시, **어떤 기준과 방식으로 테스트 케이스를 만들지 정하는 방법**이야.

## 📂 테스트 기법의 대분류

| 분류               | 설명                   | 기준                        |
| ------------------ | ---------------------- | --------------------------- |
| **명세 기반 기법** | 입력/출력 중심 테스트  | 기능 명세서 (요구사항)      |
| **구조 기반 기법** | 코드 구조 중심 테스트  | 실제 코드 (분기, 루프 등)   |
| **경험 기반 기법** | 경험, 직감 기반 테스트 | 오류 추정, 탐색적 테스트 등 |

이번엔 **명세 기반 기법과 구조 기반 기법**을 집중적으로 볼게.

## 1️⃣ 명세 기반 테스트 기법 (Specification-based)

> **기능 명세서**를 기반으로
>  "입력값이 주어졌을 때, 올바른 출력이 나오는지" 검증하는 **블랙박스 테스트** 방식이야.
>  내부 코드는 보지 않고 **입력과 출력만**으로 검증하는 것이 특징.

### 📌 대표 기법 정리

| 기법                                      | 설명                                     | 예시                                           |
| ----------------------------------------- | ---------------------------------------- | ---------------------------------------------- |
| **동등 분할 (Equivalence Partitioning)**  | 입력 값을 그룹으로 나눠 대표 값만 테스트 | 1~~100 입력 → [<1], [1~~100], [>100] 중 각 1개 |
| **경계값 분석 (Boundary Value Analysis)** | 경계 근처 값을 집중 테스트               | 0, 1, 100, 101 등                              |
| **결정 테이블 (Decision Table)**          | 조건과 행동을 표로 정리하여 조합 테스트  | A and B → 결과 X                               |
| **상태 전이 (State Transition)**          | 상태 변화에 따라 동작을 테스트           | 로그인 상태 → 로그아웃 상태                    |
| **유스케이스 기반**                       | 사용 시나리오에 따라 테스트              | 장바구니 → 결제 흐름                           |

### ✅ 동등 분할 + 경계값 분석 예시

**요구사항:**
 "1~100 사이 숫자만 입력 가능"

- 동등 분할
  - 유효: 50
  - 무효: 0, 101
- 경계값 분석
  - 1, 100, 0, 101

## 2️⃣ 구조 기반 테스트 기법 (Structure-based)

> **코드의 내부 논리, 흐름, 제어구조**를 기반으로 하는 **화이트박스 테스트**
>  내부 로직이 테스트 범위에 **충분히 포함되었는지** 확인할 수 있음

### 📌 대표 기법 정리

| 기법                    | 설명                                         | 목표                      |
| ----------------------- | -------------------------------------------- | ------------------------- |
| **문장(구문) 커버리지** | 모든 문장 실행                               | if, for 등 포함           |
| **분기 커버리지**       | 모든 조건 분기 실행                          | 참/거짓 각각 실행         |
| **조건 커버리지**       | 조건식의 각각의 피연산자에 대해 참/거짓 실행 | `A && B` 에서 A, B 각각   |
| **경로 커버리지**       | 가능한 모든 실행 경로 테스트                 | 가장 강력하지만 매우 복잡 |
| **루프 테스트**         | 반복문을 0회, 1회, N회 실행                  | 반복 관련 오류 검출       |

### ✅ 예시 코드

```python
def max(a, b):
    if a > b:
        return a
    else:
        return b

```

| 커버리지 종류 | 조건              | 만족 여부                  |
| ------------- | ----------------- | -------------------------- |
| 문장 커버리지 | 모든 줄 실행      | `a > b` 참/거짓 각각 한 번 |
| 분기 커버리지 | if 조건의 두 방향 | `a > b` 참/거짓 수행       |

## 🧠 명세 기반 vs 구조 기반 비교표

| 항목        | 명세 기반                | 구조 기반                    |
| ----------- | ------------------------ | ---------------------------- |
| 접근 방식   | **외부 명세 기준**       | **내부 코드 기준**           |
| 시점        | 개발 전 or 요구사항 기반 | 개발 후 (코드 분석)          |
| 테스트 시점 | 주로 시스템/통합 테스트  | 주로 단위 테스트             |
| 도구 의존성 | 명세서 기반 (적음)       | 커버리지 도구 활용           |
| 테스트 대상 | 기능, 입력/출력          | 분기, 조건, 루프             |
| 기법 예시   | 동등 분할, 상태 전이     | 조건 커버리지, 경로 커버리지 |

## ✅ 실무 적용 전략

| 테스트 레벨   | 적용 기법                   |
| ------------- | --------------------------- |
| 단위 테스트   | 구조 기반 (분기/조건/경로)  |
| 통합 테스트   | 구조 + 명세 혼합            |
| 시스템 테스트 | 명세 기반 (사용자 시나리오) |

## 🔁 보완 관계

> 명세 기반은 "**해야 할 것**을 잘했는가?"
>  구조 기반은 "코드의 **모든 부분을 충분히 테스트했는가**?"

→ 실제 현업에서는 두 기법을 **동시에 사용**하는 게 일반적이야.

# 테스트 자동화 도구

## ✅ 테스트 자동화 도구란?

> 반복적으로 실행되는 테스트를 **스크립트나 툴을 통해 자동화**하여
>  **시간을 절약하고, 정확도와 품질을 높이기 위한 도구**

## 📂 자동화 도구 분류 총정리

| 유형                       | 설명                             | 대표 도구                          |
| -------------------------- | -------------------------------- | ---------------------------------- |
| ✅ **단위 테스트(Unit)**    | 함수/클래스 테스트 자동화        | JUnit, pytest, unittest            |
| ✅ **UI 테스트**            | 실제 브라우저 상 동작 테스트     | Selenium, Cypress, Playwright      |
| ✅ **API 테스트**           | REST, GraphQL 등 HTTP API 테스트 | Postman, REST Assured, Karate      |
| ✅ **통합/시나리오 테스트** | 사용자 흐름 통합 테스트          | Robot Framework, TestNG            |
| ✅ **성능 테스트**          | 부하, 처리량, 응답시간 측정      | JMeter, Gatling, Locust            |
| ✅ **보안 테스트**          | 취약점 자동 스캔                 | OWASP ZAP, Burp Suite, SonarQube   |
| ✅ **CI/CD 테스트 통합**    | 빌드, 배포 자동화와 연동         | Jenkins, GitHub Actions, GitLab CI |

## 1️⃣ 단위 테스트 자동화 도구

| 도구            | 언어   | 특징                                    |
| --------------- | ------ | --------------------------------------- |
| **JUnit**       | Java   | 대표적인 자바 단위 테스트 프레임워크    |
| **pytest**      | Python | 간결하고 확장성 높은 파이썬 테스트 도구 |
| **unittest**    | Python | Python 내장 테스트 프레임워크           |
| **Google Test** | C/C++  | 크로스 플랫폼 C++ 테스트 프레임워크     |

## 2️⃣ UI 자동화 테스트 도구

| 도구           | 언어               | 특징                                           |
| -------------- | ------------------ | ---------------------------------------------- |
| **Selenium**   | Java, Python 등    | 웹 브라우저 자동 제어, 널리 사용됨             |
| **Cypress**    | JavaScript         | 최신 프론트엔드 프레임워크 대응, 빠른 실행     |
| **Playwright** | JavaScript, Python | 멀티 브라우저 지원 (Chromium, Firefox, WebKit) |

## 3️⃣ API 테스트 도구

| 도구             | 방식           | 특징                                  |
| ---------------- | -------------- | ------------------------------------- |
| **Postman**      | GUI            | 직관적인 API 호출 및 테스트           |
| **REST Assured** | Java 코드 기반 | API 테스트를 코드로 작성              |
| **Karate**       | DSL 기반       | BDD 스타일로 API 시나리오 테스트 가능 |

## 4️⃣ 통합 테스트 / 시나리오 도구

| 도구                  | 특징                                                  |
| --------------------- | ----------------------------------------------------- |
| **Robot Framework**   | 키워드 기반 시나리오 테스트 (UI + API + DB 통합 가능) |
| **TestNG**            | Java 기반 테스트 프레임워크, JUnit 확장               |
| **Behave / Cucumber** | BDD 기반 테스트 작성 (`Given-When-Then`)              |

## 5️⃣ 성능 테스트 도구

| 도구        | 특징                                 |
| ----------- | ------------------------------------ |
| **JMeter**  | 다수 사용자 부하 시뮬레이션, UI 기반 |
| **Gatling** | 코드 기반 부하 테스트, Scala 기반    |
| **Locust**  | Python 기반 분산 로드 테스트 도구    |

## 6️⃣ 보안/정적 분석 도구

| 도구           | 대상      | 특징                                  |
| -------------- | --------- | ------------------------------------- |
| **OWASP ZAP**  | 웹 보안   | 오픈소스 웹 취약점 스캐너             |
| **Burp Suite** | 웹 보안   | 전문 보안팀 사용 도구, 유료 버전 존재 |
| **SonarQube**  | 코드 품질 | 정적 분석 + 보안 취약점 탐지          |

## 7️⃣ CI/CD 연동 테스트 도구

| 도구                     | 특징                            |
| ------------------------ | ------------------------------- |
| **Jenkins**              | 가장 널리 쓰이는 자동화 서버    |
| **GitHub Actions**       | GitHub 기반 빌드/테스트 자동화  |
| **GitLab CI**            | GitLab 내장 CI/CD 도구          |
| **CircleCI / Travis CI** | 클라우드 기반 테스트 파이프라인 |

## 🧠 실전 예시: 웹 서비스 테스트 구성

```
text코드 복사[단위 테스트]       JUnit, pytest  
→ [API 테스트]     REST Assured, Postman  
→ [UI 테스트]      Selenium, Cypress  
→ [성능 테스트]    JMeter  
→ [보안 점검]      OWASP ZAP  
→ [CI/CD 자동화]   Jenkins + GitHub Actions
```

## ✅ 자동화 도구 도입 팁

| 조건                   | 추천 도구               |
| ---------------------- | ----------------------- |
| 백엔드 API 테스트 위주 | REST Assured + Postman  |
| 프론트엔드 + 반응형 UI | Cypress 또는 Playwright |
| 통합 + 시나리오 테스트 | Robot Framework         |
| 협업 + 문서 자동화     | Cucumber, Allure Report |
| DevOps 파이프라인      | Jenkins, GitHub Actions |

# 3. **데이터베이스 구축**

# 3-1. 데이터 모델링

# 개념/논리/물리 모델링

## ✅ 데이터 모델링이란?

> 사용자의 요구사항을 기반으로 **데이터 구조, 관계, 제약조건** 등을 설계하는 것.
>  데이터를 **현실 세계 → 논리 구조 → 구현 가능한 스키마**로 점차 발전시키는 과정이야.

## 📂 3단계 모델링 요약표

| 단계            | 목적                          | 주요 도구/표현                        | 대상자                |
| --------------- | ----------------------------- | ------------------------------------- | --------------------- |
| **개념 모델링** | 사용자/업무 중심 개념 정리    | ERD (Entity-Relationship Diagram)     | 도메인 전문가, 분석가 |
| **논리 모델링** | DBMS에 독립적인 논리적 구조화 | 정규화된 관계형 구조 (PK, FK 정의)    | 데이터 설계자         |
| **물리 모델링** | 실제 DBMS 기반 구현           | 스키마 정의, 인덱스, 파티션, 제약조건 | DBA, 개발자           |

## 1️⃣ 개념 모델링 (Conceptual Modeling)

> 현실 세계의 개념을 추상화하여 **업무 중심의 데이터 구조를 시각화**
>  주로 **ERD**로 작성하며, **비전문가도 이해 가능한 수준**에서 모델링함

### ● 특징

- 기술 독립적 (DBMS와 무관)
- 엔터티, 속성, 관계만 정의
- 정규화 전 상태 가능

### ● 구성 요소

| 구성                   | 설명                              |
| ---------------------- | --------------------------------- |
| **Entity(개체)**       | 데이터화할 대상 (ex. 고객, 주문)  |
| **Attribute(속성)**    | 개체의 특징 (이름, 나이 등)       |
| **Relationship(관계)** | 개체 간 연결 (고객은 주문을 한다) |

### ● 예시

```
[고객] -------- 주문 -------- [상품]

고객: 고객ID, 이름, 이메일
상품: 상품ID, 이름, 가격
주문: 주문ID, 주문일, 수량

```

→ 이 단계는 주로 분석가와 기획자도 함께 참여

## 2️⃣ 논리 모델링 (Logical Modeling)

> 개념 모델을 **관계형 DB 구조**로 바꾸는 단계
>  DBMS는 아직 고려하지 않지만, **관계형 구조에 맞는 형태로 변환**돼

### ● 특징

- 정규화 진행 (1NF~3NF)
- 기본키(PK), 외래키(FK), 도메인 정의
- M:N 관계는 중간 테이블로 분해

### ● 주요 작업

| 작업      | 설명                   |
| --------- | ---------------------- |
| 정규화    | 중복 제거 및 이상 방지 |
| 관계 정의 | 1:N, N:M 관계 명확화   |
| 키 설계   | PK, FK 설정            |

### ● 예시

```css
테이블: 고객 (고객ID(PK), 이름, 이메일)
테이블: 상품 (상품ID(PK), 이름, 가격)
테이블: 주문 (주문ID(PK), 고객ID(FK), 상품ID(FK), 주문일, 수량)

```

## 3️⃣ 물리 모델링 (Physical Modeling)

> 논리 모델을 실제 **DBMS에서 구현 가능한 스키마로 구체화**
>  성능, 저장공간, 제약조건 등을 고려하여 설계됨

### ● 특징

- DBMS 의존적 (MySQL, Oracle, PostgreSQL 등)
- 타입, 제약조건, 인덱스 등 구체적 정의
- 성능 최적화 고려 (파티셔닝, 인덱스 등)

### ● 주요 작업

| 요소            | 설명                        |
| --------------- | --------------------------- |
| 데이터 타입     | VARCHAR, INT, DATE 등       |
| 제약 조건       | NOT NULL, UNIQUE, CHECK 등  |
| 인덱스          | 검색 성능 향상용            |
| 파티션          | 대용량 테이블 분할 저장     |
| 물리적 저장옵션 | 테이블스페이스, 클러스터 등 |

### ● 예시 (MySQL)

```sql
CREATE TABLE 주문 (
  주문ID INT PRIMARY KEY AUTO_INCREMENT,
  고객ID INT NOT NULL,
  상품ID INT NOT NULL,
  주문일 DATE,
  수량 INT,
  FOREIGN KEY (고객ID) REFERENCES 고객(고객ID),
  FOREIGN KEY (상품ID) REFERENCES 상품(상품ID)
);

```

## 🧠 3단계 비교 요약표

| 구분   | 개념 모델      | 논리 모델       | 물리 모델   |
| ------ | -------------- | --------------- | ----------- |
| 대상   | 업무 개념      | 관계형 구조     | DBMS 스키마 |
| 표현   | ERD            | 정규화된 테이블 | SQL DDL     |
| 사용자 | 분석가, 기획자 | 설계자, 개발자  | DBA, 백엔드 |
| 목적   | 개념 이해      | 구조적 설계     | 실제 구축   |
| 의존성 | 없음           | DB 논리 기반    | DBMS 종속   |

## ✅ 실무 모델링 흐름

```
text코드 복사요구사항 분석
→ 개념 모델 (ERD)
→ 논리 모델 (정규화, 테이블 설계)
→ 물리 모델 (DDL, 인덱스, 성능 설계)
→ DB 구축
```

# 정규화 단계 (1NF~BCNF)

## ✅ 정규화란?

> 데이터의 **중복을 제거하고 이상(Anomaly)을 방지하기 위해**
>  테이블을 구조적으로 분해하는 과정이야.

정규화는 다음과 같은 이상(Anomaly)을 방지하는 게 목적이야:

- **삽입 이상**: 일부 속성 때문에 데이터를 삽입하지 못함
- **삭제 이상**: 불필요한 정보까지 같이 사라짐
- **갱신 이상**: 중복 정보로 인해 일부만 바뀌는 오류

## 📂 정규화 단계 요약표

| 단계 | 이름               | 해결하는 문제                        |
| ---- | ------------------ | ------------------------------------ |
| 1NF  | 제1정규형          | 반복 속성 제거, 원자값 유지          |
| 2NF  | 제2정규형          | 부분 함수 종속 제거                  |
| 3NF  | 제3정규형          | 이행적 함수 종속 제거                |
| BCNF | 보이스-코드 정규형 | 결정자이지만 후보키가 아닌 속성 제거 |

## 1️⃣ 제1정규형 (1NF: First Normal Form)

### ● 조건

- **모든 속성의 값은 원자값(Atomic Value)**이어야 한다.

### ● 위반 예시

| 학번 | 이름   | 전화번호           |
| ---- | ------ | ------------------ |
| 101  | 홍길동 | 010-1234, 010-5678 |

→ `전화번호`에 **두 개의 값이 들어 있음** → 비정규형

### ● 정규화

| 학번 | 이름   | 전화번호 |
| ---- | ------ | -------- |
| 101  | 홍길동 | 010-1234 |
| 101  | 홍길동 | 010-5678 |

## 2️⃣ 제2정규형 (2NF: Second Normal Form)

### ● 조건

- 1NF 만족 + **기본키의 부분집합에 종속된 속성이 없어야 함**

→ 즉, **부분 함수 종속 제거**

### ● 위반 예시

| 학번 | 과목명 | 교수명 |
| ---- | ------ | ------ |
| 101  | DB     | 김교수 |
| 101  | OS     | 이교수 |

→ 기본키가 `(학번, 과목명)`인데
 → `교수명`은 **과목명에만 종속** → 부분 함수 종속

### ● 정규화

- 과목 테이블: (과목명, 교수명)
- 수강 테이블: (학번, 과목명)

## 3️⃣ 제3정규형 (3NF: Third Normal Form)

### ● 조건

- 2NF 만족 + **이행적 함수 종속 제거**

→ 즉, **키가 아닌 속성 → 다른 키가 아닌 속성** 관계 제거

### ● 위반 예시

| 학번 | 학과코드 | 학과명       |
| ---- | -------- | ------------ |
| 101  | C01      | 컴퓨터공학과 |

→ `학과명`은 `학번`이 아닌 `학과코드`에 종속 → 이행적 종속

### ● 정규화

- 학과 테이블: (학과코드, 학과명)
- 학생 테이블: (학번, 학과코드)

## 4️⃣ BCNF (Boyce-Codd Normal Form)

### ● 조건

- 3NF 만족 + **모든 결정자가 후보키**

→ 3NF보다 조금 더 엄격한 조건

### ● 위반 예시

| 과목명 | 담당자 | 교재명 |
| ------ | ------ | ------ |
| DB     | 김교수 | DB책1  |
| DB     | 이교수 | DB책2  |

→ 과목 하나에 여러 담당자가 있고, 교재는 담당자에 따라 결정됨
 → `담당자 → 교재명`인데 `담당자`는 **후보키가 아님** → BCNF 위반

### ● 정규화

- 교재 테이블: (담당자, 교재명)
- 과목담당 테이블: (과목명, 담당자)

## ✅ 정규화 단계별 비교 정리표

| 단계 | 제거 대상        | 예시 문제                          |
| ---- | ---------------- | ---------------------------------- |
| 1NF  | 반복, 다중값     | 전화번호 2개 이상                  |
| 2NF  | 부분 종속        | 기본키 일부에만 종속               |
| 3NF  | 이행 종속        | 비키 속성이 또 다른 비키 속성 결정 |
| BCNF | 결정자 조건 위반 | 후보키가 아닌 결정자 존재          |

## 🔁 참고: 그 외 고급 정규형

| 단계 | 의미                                                 |
| ---- | ---------------------------------------------------- |
| 4NF  | 다치 종속 제거                                       |
| 5NF  | 조인 종속 제거                                       |
| 6NF  | 모든 조인 종속을 분리한 정규형 (실무에선 거의 안 씀) |

## 🧠 실무 설계 팁

| 상황                 | 전략                                         |
| -------------------- | -------------------------------------------- |
| 설계 초기            | 1NF → 3NF 까지는 기본 적용                   |
| 성능이 중요한 시스템 | 3NF 이후 일부 반정규화 적용                  |
| 다대다 관계          | 중간 테이블로 분리 (정규화 핵심)             |
| 보고서 시스템        | 일부 정규화 생략 가능 (집계용은 반정규화 OK) |

# 식별자, 관계, 속성, 카디널리티

## ✅ 1. 식별자 (Identifier)

> **개체(Entity)를 고유하게 식별할 수 있는 속성 또는 속성의 조합**

### ● 종류

| 식별자 유형                         | 설명                                 | 예시                 |
| ----------------------------------- | ------------------------------------ | -------------------- |
| **기본 식별자(Primary Identifier)** | 테이블의 기본키(PK)가 되는 유일 속성 | 주민번호, 사번, 학번 |
| **대리 식별자(Surrogate Key)**      | 시스템이 임의 생성한 PK (의미 없음)  | Auto-increment ID    |
| **복합 식별자(Composite)**          | 여러 속성의 조합이 식별자            | (학생ID, 과목코드)   |
| **후보 식별자(Candidate)**          | 유일값을 가질 수 있는 후보키들       | 주민번호, 이메일 등  |

### ● ERD 표기

```
코드 복사
고객(고객ID(PK), 이름, 전화번호)
```

## ✅ 2. 속성 (Attribute)

> **개체(Entity)가 가지는 특성, 정보를 나타내는 항목**

### ● 종류

| 속성 구분       | 설명                                 | 예시                          |
| --------------- | ------------------------------------ | ----------------------------- |
| **기본 속성**   | 일반적인 정보                        | 이름, 전화번호                |
| **식별 속성**   | 기본키가 되는 속성                   | 고객ID                        |
| **복합 속성**   | 하위 속성을 가짐                     | 주소 → (시, 도로명, 우편번호) |
| **다중값 속성** | 하나의 속성이 여러 값을 가질 수 있음 | 이메일, 전화번호 여러 개      |
| **파생 속성**   | 다른 속성으로부터 계산됨             | 나이 = 현재년도 - 생년        |

### ● ERD 표기

```
학생(학번, 이름, 생년월일, 주소)
```

## ✅ 3. 관계 (Relationship)

> **두 개 이상의 개체 사이의 의미 있는 연결**

### ● 종류

| 관계 유형 | 설명                                              | 예시          |
| --------- | ------------------------------------------------- | ------------- |
| **1:1**   | 하나의 엔터티가 하나와만 연결                     | 사원 ↔ 사물함 |
| **1:N**   | 하나는 여러 개와 연결 가능                        | 고객 ↔ 주문   |
| **M:N**   | 서로 여러 개와 연결 (→ 정규화로 중간 테이블 필요) | 학생 ↔ 과목   |

### ● 관계 강도

| 종류                              | 설명                                            |
| --------------------------------- | ----------------------------------------------- |
| **식별 관계 (Identifying)**       | 자식 엔터티의 PK에 부모 PK가 포함됨 (강한 연결) |
| **비식별 관계 (Non-identifying)** | 자식 엔터티의 FK가 PK에는 포함되지 않음         |

## ✅ 4. 카디널리티 (Cardinality, 수량 제약)

> **두 개체 간 관계에서 발생할 수 있는 인스턴스 수의 범위**

### ● 표기 방식 (ERD 기준)

| 표기  | 의미                                |
| ----- | ----------------------------------- |
| (1,1) | 반드시 1개 (필수 관계)              |
| (0,1) | 있어도 되고, 최대 1개 (선택적 관계) |
| (0,N) | 없어도 되고, 여러 개 (다수 관계)    |
| (1,N) | 반드시 1개 이상 존재해야 함         |

## 🧠 예시 시나리오: 고객과 주문

```
text코드 복사고객(고객ID, 이름, 전화번호)  
주문(주문ID, 주문일, 고객ID)

관계: 고객 1명은 여러 건의 주문 가능 (1:N)
→ 고객ID는 주문 테이블의 외래키 (FK)
→ 고객ID → 주문의 카디널리티는 (1,N)
```

## 📌 ERD 표기 요약

| 요소       | 기호         | 설명          |
| ---------- | ------------ | ------------- |
| 엔터티     | □ 사각형     | 고객, 상품    |
| 속성       | ○ 타원형     | 이름, 이메일  |
| 식별자     | 밑줄         | 기본키 표시   |
| 관계       | ◆ 마름모     | 주문, 작성 등 |
| 카디널리티 | (1,1), (0,N) | 수량 제약     |

## ✅ 정리 요약

| 개념           | 설명                            | 예시            |
| -------------- | ------------------------------- | --------------- |
| **식별자**     | 엔터티를 고유하게 식별하는 속성 | 학번, 주민번호  |
| **속성**       | 엔터티의 특성 정보              | 이름, 생년월일  |
| **관계**       | 엔터티 간 의미 있는 연결        | 고객 ↔ 주문     |
| **카디널리티** | 관계에서 인스턴스 수 제약       | (1:N), (0,N) 등 |

# 3-2. SQL

# DDL, DML, DCL, TCL

## ✅ SQL 명령어 4대 분류 요약표

| 분류    | 이름                         | 목적                 | 키워드                                 |
| ------- | ---------------------------- | -------------------- | -------------------------------------- |
| **DDL** | Data Definition Language     | **데이터 구조 정의** | `CREATE`, `ALTER`, `DROP`, `TRUNCATE`  |
| **DML** | Data Manipulation Language   | **데이터 조작**      | `SELECT`, `INSERT`, `UPDATE`, `DELETE` |
| **DCL** | Data Control Language        | **권한/보안 관리**   | `GRANT`, `REVOKE`                      |
| **TCL** | Transaction Control Language | **트랜잭션 제어**    | `COMMIT`, `ROLLBACK`, `SAVEPOINT`      |

## 1️⃣ DDL – 데이터 정의어

> 데이터베이스의 **구조를 생성/수정/삭제**하는 명령어

| 명령어     | 설명                                     |
| ---------- | ---------------------------------------- |
| `CREATE`   | 테이블, 뷰, 인덱스 등 객체 생성          |
| `ALTER`    | 테이블 구조 변경 (컬럼 추가/삭제 등)     |
| `DROP`     | 객체 삭제                                |
| `TRUNCATE` | 테이블 비우기 (데이터만 삭제, 구조 유지) |

### 예시

```sql
CREATE TABLE student (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  age INT
);

ALTER TABLE student ADD COLUMN email VARCHAR(100);
DROP TABLE student;

```

> 📌 DDL은 **자동 COMMIT**을 수행함 → 취소 불가

## 2️⃣ DML – 데이터 조작어

> 테이블 안의 **데이터를 조회, 삽입, 수정, 삭제**하는 명령어

| 명령어   | 설명        |
| -------- | ----------- |
| `SELECT` | 데이터 조회 |
| `INSERT` | 데이터 삽입 |
| `UPDATE` | 데이터 수정 |
| `DELETE` | 데이터 삭제 |

### 예시

```sql
SELECT * FROM student;

INSERT INTO student (id, name, age) VALUES (1, '홍길동', 20);

UPDATE student SET age = 21 WHERE id = 1;

DELETE FROM student WHERE id = 1;

```

> 📌 DML은 트랜잭션 안에서 사용됨 → `COMMIT` 전까진 실제 반영되지 않음

## 3️⃣ DCL – 데이터 제어어

> **사용자 권한 부여 및 회수**를 제어하는 명령어

| 명령어   | 설명      |
| -------- | --------- |
| `GRANT`  | 권한 부여 |
| `REVOKE` | 권한 회수 |

### 예시

```sql
GRANT SELECT, INSERT ON student TO user1;

REVOKE INSERT ON student FROM user1;

```

> 📌 DB 보안 및 접근 권한 관리를 위한 핵심 도구

## 4️⃣ TCL – 트랜잭션 제어어

> DML 작업의 **일괄 처리 및 취소/저장**을 위한 명령어

| 명령어        | 설명                       |
| ------------- | -------------------------- |
| `COMMIT`      | 모든 변경사항 저장         |
| `ROLLBACK`    | 트랜잭션 내 변경 사항 취소 |
| `SAVEPOINT`   | 중간 저장점 설정           |
| `ROLLBACK TO` | 특정 저장점까지 되돌림     |

### 예시

```sql
BEGIN;

UPDATE student SET age = 25 WHERE id = 1;
SAVEPOINT before_age;

UPDATE student SET name = '이몽룡' WHERE id = 1;

ROLLBACK TO before_age; -- 이름 변경 취소, 나이 변경 유지

COMMIT; -- 최종 반영

```

> 📌 TCL은 **DML과 함께 사용**되며, **DDL 이후에는 사용 불가**

## 🧠 명령어 분류 암기 팁

```
코드 복사🍴 DDL = 식탁(구조) 만들기
🍛 DML = 식사(데이터) 조작
🔐 DCL = 누가 먹을 수 있나? (권한)
🧼 TCL = 먹은 거 되돌리기/확정하기
```

## ✅ 전체 요약표

| 분류 | 목적          | 주요 명령어      | 트랜잭션             |
| ---- | ------------- | ---------------- | -------------------- |
| DDL  | 구조 정의     | CREATE, DROP     | ❌ 자동 COMMIT        |
| DML  | 데이터 조작   | SELECT, INSERT   | ✅ COMMIT 필요        |
| DCL  | 권한 관리     | GRANT, REVOKE    | ✅ COMMIT 필요        |
| TCL  | 트랜잭션 제어 | COMMIT, ROLLBACK | 🔄 트랜잭션 자체 조작 |

# SELECT, JOIN, GROUP BY, 서브쿼리

## ✅ 1. SELECT

> 데이터베이스에서 **원하는 데이터를 조회하는 기본 명령어**

### ● 기본 문법

```sql
SELECT 컬럼명1, 컬럼명2, ...
FROM 테이블명
WHERE 조건
ORDER BY 정렬기준 [ASC | DESC]
LIMIT 개수; -- MySQL

```

### ● 예시

```sql
SELECT name, age
FROM student
WHERE age >= 20
ORDER BY age DESC;

```

## ✅ 2. JOIN

> **두 개 이상의 테이블을 연결**하여 관련 데이터를 함께 조회하는 기능

### ● JOIN 종류 정리표

| 종류                | 설명                                       | 조인 조건 필요 |
| ------------------- | ------------------------------------------ | -------------- |
| **INNER JOIN**      | 공통된 값이 있는 행만 조회                 | ✅              |
| **LEFT JOIN**       | 왼쪽 테이블은 모두, 오른쪽은 일치하는 행만 | ✅              |
| **RIGHT JOIN**      | 오른쪽 테이블은 모두, 왼쪽은 일치하는 행만 | ✅              |
| **FULL OUTER JOIN** | 양쪽 모두 포함 (MySQL은 X)                 | ✅              |
| **SELF JOIN**       | 자기 자신과 조인                           | ✅              |
| **CROSS JOIN**      | 곱집합                                     | ❌              |

### ● INNER JOIN 예시

```sql
SELECT s.name, o.order_date
FROM student s
INNER JOIN orders o ON s.id = o.student_id;

```

### ● LEFT JOIN 예시

```sql
SELECT s.name, o.order_date
FROM student s
LEFT JOIN orders o ON s.id = o.student_id;
```

→ 주문 내역이 없는 학생도 포함됨 (NULL로 표시)

## ✅ 3. GROUP BY

> **같은 값을 가진 행끼리 그룹화하고, 집계 함수로 요약**하는 데 사용

### ● 주요 집계 함수

| 함수      | 설명      |
| --------- | --------- |
| `COUNT()` | 개수 세기 |
| `SUM()`   | 총합 계산 |
| `AVG()`   | 평균      |
| `MAX()`   | 최댓값    |
| `MIN()`   | 최솟값    |

### ● 기본 문법

```sql
SELECT 그룹기준컬럼, 집계함수
FROM 테이블
GROUP BY 그룹기준컬럼
[HAVING 조건];  -- 그룹 결과 조건

```

### ● 예시: 학생별 평균 점수

```sql
SELECT student_id, AVG(score) AS 평균점수
FROM grade
GROUP BY student_id
HAVING AVG(score) >= 80;

```

> 📌 `HAVING`은 `GROUP BY` 이후의 결과에 조건을 걸 때 사용

## ✅ 4. 서브쿼리(Subquery)

> 쿼리 안에 **또 다른 SELECT 문을 포함하는 쿼리**
>  주로 WHERE, FROM, SELECT 절에서 사용

### ● 분류

| 종류                 | 위치                           | 예시                                   |
| -------------------- | ------------------------------ | -------------------------------------- |
| **스칼라 서브쿼리**  | SELECT 절                      | `SELECT (SELECT MAX(salary) FROM emp)` |
| **단일 행 서브쿼리** | WHERE 절                       | `WHERE id = (SELECT MAX(id) ...)`      |
| **다중 행 서브쿼리** | `IN`, `ANY`, `ALL`과 함께 사용 | `WHERE id IN (SELECT ...)`             |
| **인라인 뷰**        | FROM 절                        | `FROM (SELECT ...) AS sub`             |
| **상관 서브쿼리**    | 외부 쿼리와 연관된 서브쿼리    | `WHERE EXISTS (...)`                   |

### ● 단일행 서브쿼리 예시

```sql
SELECT name
FROM student
WHERE score = (SELECT MAX(score) FROM student);

```

### ● 다중행 서브쿼리 예시

```sql
SELECT name
FROM student
WHERE id IN (SELECT student_id FROM orders);

```

### ● 상관 서브쿼리 예시

```sql
SELECT name
FROM student s
WHERE EXISTS (
  SELECT 1 FROM orders o WHERE o.student_id = s.id
);

```

> 외부 쿼리와 연결된 조건이 서브쿼리 내부에 존재

### ✅ 통합 실전 예시

```sql
-- 주문한 학생의 이름과 총 주문 금액
SELECT s.name, SUM(o.amount) AS 총액
FROM student s
JOIN orders o ON s.id = o.student_id
GROUP BY s.name
HAVING SUM(o.amount) > 10000
ORDER BY 총액 DESC;

```

## 🧠 정리 요약

| 개념       | 역할               | 핵심 키워드                         |
| ---------- | ------------------ | ----------------------------------- |
| `SELECT`   | 원하는 데이터 조회 | `WHERE`, `ORDER BY`, `LIMIT`        |
| `JOIN`     | 테이블 간 연결     | `INNER`, `LEFT`, `RIGHT`, `ON`      |
| `GROUP BY` | 집계 및 요약       | `COUNT`, `SUM`, `HAVING`            |
| `서브쿼리` | 쿼리 안의 쿼리     | `IN`, `EXISTS`, `FROM (SELECT ...)` |

# 인덱스, 뷰, 시퀀스, 트리거, 프로시저

## ✅ 1. 인덱스 (INDEX)

> 테이블의 **조회 성능을 향상시키기 위한 자료구조**
>  책의 목차처럼, 원하는 데이터를 빠르게 찾을 수 있게 도와줌

### ● 특징

| 항목      | 설명                                            |
| --------- | ----------------------------------------------- |
| 목적      | 검색 속도 향상 (읽기 ↑)                         |
| 단점      | **INSERT/UPDATE 성능 저하**, 저장공간 추가 필요 |
| 사용 시점 | WHERE 조건, JOIN, ORDER BY, GROUP BY 등         |

### ● 문법

```sql
-- 단일 인덱스
CREATE INDEX idx_student_name ON student(name);

-- 복합 인덱스
CREATE INDEX idx_name_age ON student(name, age);

```

> 📌 인덱스는 자주 조회하지만 수정이 적은 컬럼에 적합

## ✅ 2. 뷰 (VIEW)

> **SELECT 결과를 가상의 테이블처럼 재사용**하는 객체
>  실시간으로 원본 테이블을 반영하며, 보안성과 편의성 ↑

### ● 특징

| 항목           | 설명                                   |
| -------------- | -------------------------------------- |
| 물리적 저장 X  | 데이터는 없고 쿼리 구조만 존재         |
| 읽기 전용 가능 | 복잡한 조인 결과를 단순화              |
| 보안 관리      | 민감 컬럼 제외한 가상 테이블 제공 가능 |

### ● 문법

```sql
CREATE VIEW student_summary AS
SELECT name, age, AVG(score) AS avg_score
FROM student
GROUP BY name, age;

```

```sql
SELECT * FROM student_summary;

```

## ✅ 3. 시퀀스 (SEQUENCE)

> **자동으로 증가하는 숫자(고유 번호)**를 생성하는 객체
>  보통 PK 값 자동 부여에 사용

### ● 특징

| 항목            | 설명                        |
| --------------- | --------------------------- |
| 고유 값 보장    | 중복되지 않는 일련번호 생성 |
| 테이블과 독립적 | 여러 테이블에서 사용 가능   |
| 캐시 사용 가능  | 성능 향상 옵션 (Oracle 등)  |

### ● 문법 (Oracle 기준)

```sql
CREATE SEQUENCE seq_student
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

```

```sql
-- 사용
INSERT INTO student(id, name) VALUES (seq_student.NEXTVAL, '홍길동');

```

## ✅ 4. 트리거 (TRIGGER)

> **특정 이벤트(INSERT, UPDATE, DELETE)가 발생할 때 자동 실행되는 코드 블록**
>  데이터 무결성 유지, 자동 로그 기록 등에 사용됨

### ● 특징

| 항목                | 설명                                 |
| ------------------- | ------------------------------------ |
| 자동 실행           | 명시적 호출 없이 이벤트 발생 시 실행 |
| BEFORE/AFTER        | 작업 전/후 동작 가능                 |
| 행 단위 / 문장 단위 | `FOR EACH ROW` 옵션으로 제어         |

### ● 문법 (Oracle 기준)

```sql
CREATE OR REPLACE TRIGGER trg_student_log
AFTER INSERT ON student
FOR EACH ROW
BEGIN
  INSERT INTO log_table (log_msg) VALUES ('학생 등록: ' || :NEW.name);
END;

```

📌 `:NEW`, `:OLD`는 트리거 내에서 변경 전후 데이터에 접근하는 키워드

## ✅ 5. 프로시저 (PROCEDURE)

> 여러 SQL 문장을 하나로 묶어, **미리 저장하고 호출할 수 있는 실행 블록**
>  비즈니스 로직을 DB 내부에 구현할 때 사용

### ● 특징

| 항목               | 설명                       |
| ------------------ | -------------------------- |
| 반복 로직 캡슐화   | 여러 SQL 수행을 일괄 처리  |
| 성능 향상          | 네트워크 왕복 줄임         |
| 입력/출력 매개변수 | `IN`, `OUT`, `IN OUT` 가능 |

### ● 문법 (Oracle 기준)

```sql
CREATE OR REPLACE PROCEDURE add_student (
  p_name IN VARCHAR2,
  p_age IN NUMBER
) AS
BEGIN
  INSERT INTO student(name, age) VALUES (p_name, p_age);
END;

```

```sql
-- 실행
EXEC add_student('홍길동', 20);

```

## 🧠 실무 정리 요약표

| 객체          | 목적           | 실무 활용              | 주의사항                      |
| ------------- | -------------- | ---------------------- | ----------------------------- |
| **INDEX**     | 검색 속도 ↑    | WHERE, JOIN 최적화     | 너무 많으면 오히려 느려짐     |
| **VIEW**      | 가상 테이블    | 복잡 쿼리 재사용, 보안 | 쓰기 제한 (JOIN 포함 시)      |
| **SEQUENCE**  | 자동 증가 번호 | PK 자동 생성           | 중복 방지, 동시성 보장        |
| **TRIGGER**   | 자동 동작      | 변경 로그, 감시        | 디버깅 어려움, 과다 사용 주의 |
| **PROCEDURE** | SQL 묶음 실행  | 트랜잭션, 배치처리     | 로직 복잡성 ↑, 버전관리 필요  |

# 3-3. 트랜잭션 & 동시성 제어

# ACID 특성

## ✅ ACID란?

> **트랜잭션(Transaction)**이 갖추어야 할 **4가지 필수 특성**
>  데이터베이스에서 **정확성, 일관성, 복구 가능성**을 보장하는 핵심 원칙이야.

ACID는 다음 네 가지의 앞글자를 따온 용어야:

```scss
A - Atomicity (원자성)  
C - Consistency (일관성)  
I - Isolation (격리성)  
D - Durability (지속성)

```

## 1️⃣ A - 원자성 (Atomicity)

> **트랜잭션 내 작업은 모두 수행되거나, 전혀 수행되지 않아야 한다.**

- 트랜잭션은 **"더 이상 나눌 수 없는 단위"**로 취급됨
- 중간 실패 시 전체를 **롤백(Rollback)**하여 무효화

### ● 예시

은행 계좌 이체

```
1. A 계좌에서 1000원 인출  
2. B 계좌에 1000원 입금  
→ 둘 다 성공하거나, 둘 다 실패해야 함

```

## 2️⃣ C - 일관성 (Consistency)

> 트랜잭션 수행 전후에 **데이터베이스의 제약조건과 규칙이 항상 만족되어야 함**

- 무결성 제약조건(예: PK, FK, CHECK 등)을 위반하지 않아야 함
- 트랜잭션 전후 상태가 **논리적으로 타당**해야 함

### ● 예시

- 학생 수가 30명이어야 한다는 조건이 있을 때
   트랜잭션 수행 후에도 그 규칙은 **반드시 유지**되어야 함

## 3️⃣ I - 격리성 (Isolation)

> 동시에 실행되는 트랜잭션은 **서로 영향을 주지 않아야 한다.**

- 트랜잭션은 **자기만 데이터베이스를 사용하는 것처럼 보여야 함**
- 격리 수준(Isolation Level)에 따라 동시성 문제를 조절

### ● 예시 문제

| 문제                | 설명                             |
| ------------------- | -------------------------------- |
| Dirty Read          | 아직 커밋되지 않은 데이터를 읽음 |
| Non-repeatable Read | 같은 SELECT인데 결과가 다름      |
| Phantom Read        | 조건에 맞는 행 개수가 달라짐     |

→ 해결: `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 등 격리 수준 조정

## 4️⃣ D - 지속성 (Durability)

> 한 번 커밋된 트랜잭션의 결과는 **영구적으로 보존**되어야 한다.

- 장애가 발생해도, 전원 꺼져도 데이터는 **손실되지 않아야 함**
- 디스크에 영구 저장 → **WAL(Write-Ahead Logging)** 등 활용

### ● 예시

- 주문 완료 후 COMMIT 되면, 갑자기 전원이 나가도 주문 기록은 **유지**

## 📌 요약 정리표

| 특성            | 의미                    | 보장              |
| --------------- | ----------------------- | ----------------- |
| **Atomicity**   | 전부 성공 or 전부 실패  | 롤백 가능         |
| **Consistency** | 규칙과 무결성 유지      | 정합성 유지       |
| **Isolation**   | 다른 트랜잭션과 독립    | 동시성 제어       |
| **Durability**  | 장애 이후에도 영구 저장 | 로그 및 복구 보장 |

## 🧠 실무 적용 예시

| 상황                | 관련 ACID 특성                         |
| ------------------- | -------------------------------------- |
| 은행 이체 도중 중단 | **A (원자성)** → 롤백으로 무결성 보장  |
| PK 중복 삽입 오류   | **C (일관성)** → 무결성 제약 위반 방지 |
| 동시에 상품 구매    | **I (격리성)** → 오버셀링 방지         |
| 결제 후 장애 발생   | **D (지속성)** → 결제 내역 보존        |

## ✅ 마무리 암기 팁

```mathematica
✔ A - All-or-nothing (원자성)  
✔ C - Consistent rules always (일관성)  
✔ I - Invisible to others (격리성)  
✔ D - Don't lose it! (지속성)

```

# Lock, Deadlock, Isolation Level

## ✅ 1. Lock (잠금)

> 동시에 여러 트랜잭션이 같은 데이터를 **동시에 수정하거나 읽지 못하게 막는 메커니즘**

### ● 목적

- 데이터의 **무결성 보장**
- 동시성 제어 → **Dirty Read, Lost Update 방지**

### ● 종류

| 분류                             | 설명                     | 예시                                 |
| -------------------------------- | ------------------------ | ------------------------------------ |
| **공유 잠금(Shared Lock, S)**    | 읽기 허용, 쓰기 금지     | `SELECT` 중 다른 `UPDATE` 방지       |
| **배타 잠금(Exclusive Lock, X)** | 읽기/쓰기 모두 차단      | `UPDATE`, `DELETE` 시 다른 접근 차단 |
| **의도 잠금(Intent Lock)**       | 상위 객체 잠금 의도 표시 | 인덱스, 테이블 단위 조율             |
| **행 잠금(Row Lock)**            | 특정 행만 잠금           | `WHERE id=1` 대상                    |
| **테이블 잠금(Table Lock)**      | 테이블 전체 잠금         | 대량 수정 작업                       |

### ● 실무 예시 (MySQL)

```sql
SELECT * FROM student WHERE id = 1 FOR UPDATE;  -- 배타 잠금
SELECT * FROM student WHERE id = 1 LOCK IN SHARE MODE;  -- 공유 잠금

```

## ✅ 2. Deadlock (교착 상태)

> **두 개 이상의 트랜잭션이 서로가 가진 잠금을 기다리며 무한 대기**하는 상태

### ● 발생 조건 (4대 조건: Coffman)

| 조건        | 설명                                 |
| ----------- | ------------------------------------ |
| 상호 배제   | 자원을 한 번에 하나만 사용할 수 있음 |
| 점유와 대기 | 잠금 보유 중 다른 자원 요청          |
| 비선점      | 잠금 중인 자원을 강제로 뺏을 수 없음 |
| 환형 대기   | 트랜잭션들이 서로를 기다림 (순환)    |

### ● 예시

```
Tx1: A → B → COMMIT  
Tx2: B → A → COMMIT  
→ 서로가 가진 자원 요청하며 대기 = Deadlock 발생

```

### ● 해결 방법

| 전략               | 설명                                  |
| ------------------ | ------------------------------------- |
| 타임아웃           | 일정 시간 기다린 후 강제 실패         |
| 트랜잭션 순서 고정 | 항상 A → B 순으로 락 획득             |
| 교착 회피          | 트랜잭션 실행 전 자원 점검            |
| 교착 회복          | 발생 후 피해 최소 트랜잭션을 ROLLBACK |

> 📌 대부분의 RDBMS는 **자동 감지 + 강제 ROLLBACK** 전략 사용

## ✅ 3. Isolation Level (격리 수준)

> **동시 실행되는 트랜잭션 간 데이터 간섭을 방지하는 수준**
>  높은 수준일수록 정확하지만 성능은 낮아짐

### ● ANSI SQL 격리 수준 표

| 수준                 | 설명                         | 방지 가능                  |
| -------------------- | ---------------------------- | -------------------------- |
| **READ UNCOMMITTED** | 커밋 안 된 데이터도 읽음     | ❌ Dirty Read               |
| **READ COMMITTED**   | 커밋된 데이터만 읽음         | ✅ Dirty Read               |
| **REPEATABLE READ**  | 읽은 행은 항상 동일하게 유지 | ✅ Non-repeatable Read      |
| **SERIALIZABLE**     | 모든 트랜잭션을 순차 실행    | ✅ Phantom Read (최고 수준) |

### ● 동시성 문제 요약표

| 문제                    | 설명                         | 발생 위치        |
| ----------------------- | ---------------------------- | ---------------- |
| **Dirty Read**          | 커밋 안 된 데이터를 읽음     | READ UNCOMMITTED |
| **Non-repeatable Read** | 같은 SELECT 결과가 달라짐    | READ COMMITTED   |
| **Phantom Read**        | 조건 만족하는 행의 수가 바뀜 | REPEATABLE READ  |

### ● 실무 격리 수준 설정 (MySQL, Oracle)

```sql
-- MySQL: 트랜잭션 시작 전
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- Oracle은 기본이 READ COMMITTED

```

## 🧠 정리 요약표

| 항목                | 목적           | 특징                | 실무 포인트                                     |
| ------------------- | -------------- | ------------------- | ----------------------------------------------- |
| **Lock**            | 자원 보호      | 공유/배타/행/테이블 | 너무 많은 락 = 성능 저하                        |
| **Deadlock**        | 무한 대기 방지 | 순환 대기           | 트랜잭션 순서 고정이 핵심                       |
| **Isolation Level** | 동시성 보장    | 4단계 기준          | REPEATABLE READ ~ SERIALIZABLE 추천 (성능 고려) |

# 3-4. DBMS 구조 및 성능

# 데이터 저장구조 (Tablespace, Segment)

## ✅ 데이터 저장구조 개요

RDBMS에서 데이터는 단순히 "테이블"에 저장되는 것이 아니라,
 **물리적 저장 단위 → 논리적 저장 구조**의 **계층 구조**로 관리돼.

```
[논리 구조]         [물리 구조]
──────────────────────────────────────
Tablespace  ──┬── Segment      ──┬── Extent ──┬── Block
              │                │             │
        (테이블, 인덱스 등)   (할당 단위)   (기본 저장 단위)

```

## ✅ 1. Tablespace (테이블스페이스)

> **데이터베이스 전체 저장 공간의 논리적 단위**
>  여러 데이터파일을 포함하며, 다양한 세그먼트가 저장되는 영역이야.

### ● 특징

| 항목 | 설명                                              |
| ---- | ------------------------------------------------- |
| 역할 | **논리적 저장소의 최상위 단위**                   |
| 구성 | 하나 이상의 데이터파일                            |
| 구분 | SYSTEM, USERS, TEMP 등 여러 개 가능               |
| 사용 | 테이블, 인덱스 등의 Segment가 Tablespace에 저장됨 |

### ● 예시

```sql
-- Oracle 기준
CREATE TABLESPACE my_data
DATAFILE '/oradata/mydata01.dbf' SIZE 100M;

```

## ✅ 2. Segment (세그먼트)

> 테이블, 인덱스, 뷰 등의 **논리적 객체가 실제 데이터를 저장하는 단위**

### ● 종류

| Segment 종류          | 설명                            |
| --------------------- | ------------------------------- |
| **Data Segment**      | 테이블의 실제 데이터 저장       |
| **Index Segment**     | 인덱스 정보 저장                |
| **Rollback Segment**  | 트랜잭션 롤백 정보 저장         |
| **Temporary Segment** | 정렬, 해시 등 임시 작업 시 사용 |

### ● 특징

- 하나의 Segment는 하나 이상의 **Extent**로 구성됨
- 테이블 1개 = Data Segment 1개 (기본)

## ✅ 3. Extent (익스텐트)

> Segment 내의 **연속된 데이터 블록 묶음 단위**

### ● 특징

| 항목      | 설명                                  |
| --------- | ------------------------------------- |
| 크기      | 보통 수십 KB ~ 수 MB                  |
| 할당 방식 | 고정 크기로 할당됨 (Auto-extend 가능) |
| 역할      | Segment의 **공간 증가 단위**          |

> 📌 성능 이슈가 있는 DB는 **Fragmentation(파편화)**을 방지하기 위해 Extent 단위 튜닝 필요

## ✅ 4. Block (데이터 블록)

> 실제 **데이터가 저장되는 가장 작은 단위**

### ● 특징

| 항목        | 설명                                  |
| ----------- | ------------------------------------- |
| 크기        | Oracle: 기본 8KB (4KB~32KB 설정 가능) |
| 내부 구조   | 헤더 + 데이터 레코드                  |
| 입출력 단위 | 디스크 I/O의 최소 단위                |
| 캐싱        | 버퍼 캐시에 로딩됨                    |

## ✅ 관계 정리 구조도

```
Tablespace
└── Datafile(s)
    └── Segment (Table, Index 등)
        └── Extents (여러 개)
            └── Blocks (여러 개)
```

→ 실제 INSERT 되는 데이터는 Block에 저장되며,
 그 Block은 Extent 안에 있고,
 Extent는 Segment 단위로 관리되고,
 Segment는 특정 Tablespace에 속한다.

## 🧠 실무 정리 요약표

| 구조           | 설명                      | 비고                           |
| -------------- | ------------------------- | ------------------------------ |
| **Tablespace** | 데이터베이스 저장 영역    | 논리적 단위, 여러 Segment 포함 |
| **Segment**    | 하나의 테이블/인덱스 객체 | Data/Index/Temp 등             |
| **Extent**     | Segment 공간 증가 단위    | 연속된 Block 묶음              |
| **Block**      | 실제 데이터 저장 단위     | 최소 I/O 단위 (8KB 등)         |

## ✅ 실무 적용 팁

| 상황                | 전략                                           |
| ------------------- | ---------------------------------------------- |
| 대용량 테이블 삽입  | Extent/Block 사이즈 조정                       |
| I/O 튜닝            | Block 크기와 DB 버퍼 캐시 최적화               |
| 테이블스페이스 설계 | 테이블과 인덱스를 다른 TS에 분리하여 병렬 처리 |
| 파편화 방지         | AUTOEXTEND/UNIFORM Extent 조정                 |

# 인덱스 구조 (B-Tree, Bitmap)

## ✅ 인덱스(Index)란?

> 테이블에서 **검색을 빠르게 하기 위해 사용하는 보조 자료구조**
>  책의 "목차"처럼, 전체 테이블을 스캔하지 않고 원하는 행으로 **빠르게 이동 가능**

## ✅ 1. B-Tree 인덱스 (Balanced Tree Index)

### ● 개념

> **균형 이진 트리 구조 기반 인덱스**
>  대부분의 RDBMS (Oracle, MySQL, PostgreSQL)에서 **기본 인덱스**로 사용

### ● 구조

- 균형 잡힌 트리 구조 (높이 일정)
- **루트 노드 → 브랜치 노드 → 리프 노드**
- 리프 노드에는 **실제 데이터의 주소(ROWID)**가 저장됨

```css
         [40]
       /     \
    [20]     [60]
   /   \     /   \
[10] [30] [50] [70]

```

→ 검색, 삽입, 삭제 모두 **O(log n)** 시간복잡도

### ● 특징

| 항목      | 설명                                     |
| --------- | ---------------------------------------- |
| 사용 빈도 | 가장 일반적, 기본 인덱스                 |
| 성능      | 대부분 상황에서 뛰어남                   |
| 정렬      | 자동 정렬됨 (ORDER BY 최적화 가능)       |
| 지원      | 범위 검색(>, <, BETWEEN), LIKE ‘A%’ 가능 |

### ● 예시

```sql
CREATE INDEX idx_name ON student(name);

```

### ● 사용 적합한 경우

- **고유한 값이 많을 때** (고유/기본키, 고객ID 등)
- **범위 조건 검색**이 자주 발생할 때
- 정렬, LIKE '문자%' 조건 자주 사용

## ✅ 2. Bitmap 인덱스

### ● 개념

> **각 컬럼 값에 대해 비트맵(bit array)을 생성**하여
>  **비교, 조합, 필터링을 빠르게 수행**하는 구조

### ● 구조

| 성별 | ROWID 비트맵 |
| ---- | ------------ |
| M    | 1 0 0 1 0 1  |
| F    | 0 1 1 0 1 0  |

- 값이 **적은 수의 고정된 카테고리일 때 유리**
- 각 비트는 행의 존재 유무를 나타냄 (압축 효율 높음)

### ● 특징

| 항목      | 설명                                         |
| --------- | -------------------------------------------- |
| 사용 제한 | **중복도가 높은 컬럼** (성별, 지역, 등급 등) |
| 읽기 성능 | 조합 조건 매우 빠름 (AND/OR/NOT)             |
| 쓰기 성능 | 느림 (INSERT/UPDATE 비용 ↑)                  |
| 저장 공간 | B-Tree보다 작음 (압축 효율 ↑)                |

### ● 예시 (Oracle 전용)

```sql
CREATE BITMAP INDEX idx_gender ON student(gender);

```

### ● 사용 적합한 경우

- **성별, 지역, 등급처럼 중복이 많은 컬럼**
- **조합 조건이 많은 통계성 조회** (WHERE gender = 'M' AND region = '서울')
- **OLAP, DW 시스템**에서 많이 활용

## 🧠 B-Tree vs Bitmap 인덱스 비교표

| 항목        | B-Tree          | Bitmap                       |
| ----------- | --------------- | ---------------------------- |
| 용도        | 일반 검색       | 통계, 분석                   |
| 적합 데이터 | 고유값, 범위값  | 중복값 많음 (카테고리)       |
| 성능        | 검색/정렬 빠름  | 조합 조건 빠름               |
| 쓰기 성능   | 빠름            | 느림                         |
| 업데이트    | 자주해도 괜찮음 | 자주 변경 시 비효율          |
| 저장공간    | 보통            | 작음 (압축)                  |
| 대표 DB     | 모든 DBMS       | Oracle 중심 (MySQL은 미지원) |

## ✅ 인덱스 선택 기준 요약

| 상황                    | 추천 인덱스 |
| ----------------------- | ----------- |
| 고객 ID, 주문번호       | B-Tree      |
| 이름 LIKE '김%'         | B-Tree      |
| 성별, 지역, 상태값      | Bitmap      |
| 복합 조건 WHERE A AND B | Bitmap      |
| 실시간 쓰기 많은 시스템 | B-Tree      |
| 보고서/통계 전용 DW     | Bitmap      |

# 분산 DB / 병렬 처리

## ✅ 1. 분산 데이터베이스 (Distributed Database)

> **물리적으로 분리된 여러 서버에 데이터를 분산 저장**하지만,
>  사용자는 **하나의 통합된 DB처럼 사용하는 시스템**

### ● 핵심 특징

| 항목                         | 설명                                              |
| ---------------------------- | ------------------------------------------------- |
| **물리적 분산, 논리적 통합** | 데이터는 여러 노드에 있지만, 쿼리는 하나처럼      |
| **네트워크 통신 기반**       | DB 간 통신은 네트워크를 통해 이루어짐             |
| **투명성 보장**              | 분산 위치, 중복, 장애 등이 사용자에게 보이지 않음 |

### ● 분산 투명성 종류

| 종류          | 설명                                      |
| ------------- | ----------------------------------------- |
| 위치 투명성   | 데이터가 어디 있는지 몰라도 조회 가능     |
| 복제 투명성   | 복제된 데이터가 있어도 사용자는 몰라도 됨 |
| 병행성 투명성 | 여러 노드에서 동시에 작업해도 일관성 유지 |
| 장애 투명성   | 일부 노드 오류 시에도 전체는 정상 작동    |

### ● 분산 DB 구성 방식

| 방식              | 설명                                  |
| ----------------- | ------------------------------------- |
| **Fragmentation** | 테이블을 분할해 저장 (수평/수직 분할) |
| **Replication**   | 데이터를 여러 곳에 복제               |
| **Hybrid**        | 분할 + 복제를 함께 사용               |

### ● 예시 시스템

- **Google Spanner**
- **CockroachDB**
- **Amazon Aurora / DynamoDB**
- **PostgreSQL + Citus (확장형 분산)**

## ✅ 2. 병렬 처리 (Parallel Processing)

> **하나의 작업을 여러 처리 단위로 나눠 동시에 수행**하여
>  처리 속도를 극대화하는 기술

### ● 병렬 처리의 목표

- 처리 속도 향상 (Throughput ↑)
- 대용량 데이터 계산 최적화
- 클러스터/멀티코어 자원 활용

### ● 병렬 처리 유형

| 유형                     | 설명                                    |
| ------------------------ | --------------------------------------- |
| **Task Parallelism**     | 작업 단위를 나눔 (예: 쿼리 병렬 수행)   |
| **Data Parallelism**     | 데이터를 나눠 처리 (예: 데이터 셋 분할) |
| **Pipeline Parallelism** | 작업을 단계별로 나눠 동시에 처리        |

### ● 병렬 처리 예시 (RDBMS)

| 시스템     | 병렬 처리 방식                     |
| ---------- | ---------------------------------- |
| Oracle     | Parallel Query (PQ), Parallel DML  |
| PostgreSQL | Parallel Seq Scan, Gather          |
| MySQL      | 병렬은 약하지만 InnoDB Thread 활용 |

```sql
-- Oracle 병렬 쿼리 예시
SELECT /*+ parallel(4) */ * FROM sales;

```

## 🧠 분산 DB vs 병렬 처리 비교

| 항목        | 분산 DB                        | 병렬 처리                         |
| ----------- | ------------------------------ | --------------------------------- |
| 목적        | **데이터를 분산** 저장         | **작업을 병렬** 처리              |
| 물리적 구성 | 다수의 서버 (노드)             | 1대 or 다수 서버의 CPU/코어       |
| 초점        | **확장성과 무결성**            | **속도와 처리량**                 |
| 특징        | 위치/복제/병행/장애 투명성     | 병렬성, 처리 단위 쪼개기          |
| 관련 기술   | 샤딩, 복제, CAP, 분산 트랜잭션 | 멀티 스레드, 병렬 쿼리, MapReduce |

## ✅ 실무 적용 예시

| 상황                    | 적용 기술                        |
| ----------------------- | -------------------------------- |
| 지역별 데이터 분산 저장 | **수평 샤딩 + 분산 DB**          |
| 대용량 분석 보고서      | **병렬 쿼리 처리 + 병렬 조인**   |
| 실시간 통계 처리        | **분산 메모리 캐시 + 병렬 연산** |
| 장애 복구, HA 구성      | **복제형 분산 DB (ex. Aurora)**  |

## ✅ 정리 요약표

| 개념          | 핵심 설명                    | 장점                 | 단점                    |
| ------------- | ---------------------------- | -------------------- | ----------------------- |
| **분산 DB**   | 여러 노드에 데이터 분산 저장 | 확장성, 장애 대응    | 복잡한 트랜잭션 처리    |
| **병렬 처리** | 작업을 나눠 동시에 수행      | 성능 향상, 시간 단축 | 동기화/데이터 병합 이슈 |

# 4. **프로그래밍 언어 활용**

# 4-1. 언어별 활용 (실습)

# Java: 클래스/인터페이스, 예외처리, 입출력, Thread

## ✅ 1. 클래스(Class) / 인터페이스(Interface)

### 🔷 클래스 (Class)

> **객체를 생성하기 위한 설계도**
>  필드(속성), 메서드(동작), 생성자 등을 포함함

### ● 기본 구조

```java
public class Person {
    String name;
    int age;

    public void greet() {
        System.out.println("Hi, I'm " + name);
    }
}

```

### ● 객체 생성

```java
Person p = new Person();
p.name = "John";
p.greet();

```

### 🔷 인터페이스 (Interface)

> **추상적인 동작 규약**만 정의.
>  실제 구현은 클래스에서 **implements**로 처리

### ● 기본 구조

```java
interface Animal {
    void sound(); // 추상 메서드
}

class Dog implements Animal {
    public void sound() {
        System.out.println("멍멍");
    }
}
```

### 🧠 실무 포인트

| 비교 항목   | 클래스                                       | 인터페이스       |
| ----------- | -------------------------------------------- | ---------------- |
| 다중 구현   | 불가 (단일 상속)                             | 가능 (다중 구현) |
| 목적        | 상태 + 동작 구현                             | 동작 규약 정의   |
| Java 8 이후 | 인터페이스도 `default`, `static` 메서드 가능 |                  |

## ✅ 2. 예외 처리 (Exception Handling)

### ● 기본 개념

> 프로그램 실행 중 발생할 수 있는 **오류를 잡아내고 처리**하여
>  시스템이 중단되지 않도록 하는 구조

### ● 기본 문법

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다.");
} finally {
    System.out.println("무조건 실행됨");
}

```

### ● 사용자 정의 예외

```java
class MyException extends Exception {
    public MyException(String message) {
        super(message);
    }
}

```

### 🧠 실무 포인트

| 키워드    | 설명                          |
| --------- | ----------------------------- |
| `try`     | 예외 발생 가능 코드 감쌈      |
| `catch`   | 예외 종류별 처리              |
| `finally` | 예외 발생 여부 관계 없이 실행 |
| `throws`  | 예외를 호출자에게 넘김        |
| `throw`   | 예외 객체 직접 발생           |

## ✅ 3. 입출력 (IO)

### ● IO 종류

| 유형              | 클래스                             | 설명                          |
| ----------------- | ---------------------------------- | ----------------------------- |
| **바이트 스트림** | `InputStream`, `OutputStream`      | 이진 데이터 (파일, 이미지 등) |
| **문자 스트림**   | `Reader`, `Writer`                 | 문자 처리 전용                |
| **고급 스트림**   | `BufferedReader`, `PrintWriter` 등 | 성능 향상, 편의 기능          |

### ● 파일 읽기 예시

```java
BufferedReader br = new BufferedReader(new FileReader("data.txt"));
String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}
br.close();

```

### ● 파일 쓰기 예시

```java
PrintWriter pw = new PrintWriter(new FileWriter("output.txt"));
pw.println("Hello, File!");
pw.close();

```

### 🧠 실무 포인트

- 자원 누수 방지를 위해 **try-with-resources** 사용 권장

```java
try (BufferedReader br = new BufferedReader(new FileReader("a.txt"))) {
    ...
}

```

* 큰 파일 처리 시에는 `Buffered` 계열 추천

* 문자 인코딩 주의 (UTF-8 vs MS949 등)

## ✅ 4. 쓰레드 (Thread)

### ● 개념

> Java에서는 `Thread` 클래스를 이용해 **동시에 여러 작업**을 실행할 수 있음
>  자바는 JVM 레벨에서 **멀티스레딩**을 지원함

### ● 쓰레드 생성 방식

#### ✅ 1) `Thread` 클래스 상속

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread 실행 중");
    }
}

```

#### ✅ 2) `Runnable` 인터페이스 구현

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable 실행 중");
    }
}

```

```java
Thread t = new Thread(new MyRunnable());
t.start();

```

### ● 실행 흐름 제어

| 메서드        | 설명                           |
| ------------- | ------------------------------ |
| `start()`     | 스레드 시작                    |
| `run()`       | 스레드 실행 코드 (직접 호출 X) |
| `sleep(ms)`   | 잠시 중단                      |
| `join()`      | 다른 스레드 종료까지 대기      |
| `interrupt()` | 강제 종료 요청                 |

### ● 동기화 (synchronized)

> 스레드 간 공유 자원에 동시 접근할 경우 **데이터 불일치 방지**

```java
public synchronized void increase() {
    count++;
}

```

### 🧠 실무 포인트

- 병렬 작업이 필요할 때만 사용 (불필요한 쓰레드는 성능 하락)
- 데이터 공유 시 `synchronized`, `ReentrantLock`, `volatile` 등 사용
- Java 5부터는 `ExecutorService`로 쓰레드풀 관리 권장

## ✅ 전체 요약 정리표

| 항목                | 핵심 설명              | 예시                             |
| ------------------- | ---------------------- | -------------------------------- |
| 클래스 / 인터페이스 | 객체 설계, 다형성 구현 | `class`, `implements`            |
| 예외 처리           | 오류 방지, 안정적 실행 | `try-catch-finally`, `throw`     |
| 입출력              | 파일/콘솔 입출력 처리  | `FileReader`, `BufferedWriter`   |
| 쓰레드              | 병렬 작업 실행         | `Thread`, `Runnable`, `Executor` |

# Python: 자료구조, 함수, 모듈, Pandas/Numpy 기초

## ✅ 1. 자료구조 (Data Structures)

### 📦 기본 내장 자료구조

| 자료형  | 기호 | 설명              |
| ------- | ---- | ----------------- |
| `list`  | `[]` | 순서 O, 변경 O    |
| `tuple` | `()` | 순서 O, 변경 X    |
| `dict`  | `{}` | 키-값 쌍          |
| `set`   | `{}` | 중복 제거, 순서 X |

### 🔹 리스트

```python
fruits = ["apple", "banana", "cherry"]
fruits.append("grape")
print(fruits[0])  # apple

```

### 🔹 딕셔너리

```python
person = {"name": "John", "age": 30}
person["age"] = 31

```

### 🔹 집합

```python
s = set([1, 2, 2, 3])
print(s)  # {1, 2, 3}

```

### 🧠 실무 팁

- **리스트 vs 튜플**: 리스트는 변경 가능 / 튜플은 고정 불변
- **딕셔너리**는 JSON 구조, API 응답 파싱 등에 자주 활용
- **set**은 중복 제거, 교집합 등 집합 연산에 유리

## ✅ 2. 함수 (Function)

> **코드를 재사용 가능한 블록**으로 정의

### 🔹 기본 구조

```python
def greet(name):
    return f"Hello, {name}"

print(greet("Alice"))  # Hello, Alice

```

### 🔹 매개변수 종류

| 종류            | 예시                |
| --------------- | ------------------- |
| 기본값 매개변수 | `def f(x=10)`       |
| 위치 인자       | `f(1, 2)`           |
| 키워드 인자     | `f(x=1, y=2)`       |
| 가변 인자       | `*args`, `**kwargs` |

### 🔹 람다 함수

```python
square = lambda x: x ** 2
print(square(3))  # 9
```

### 🧠 실무 팁

- `*args`, `**kwargs`는 유연한 API 설계에 유리
- 람다는 한 줄짜리 함수에 최적
- `map`, `filter`, `reduce`와 함께 사용 가능

## ✅ 3. 모듈 (Module)

> 다른 파일에서 작성한 함수/클래스를 **재사용하기 위한 파일 단위 코드 집합**

### 🔹 모듈 불러오기

```python
import math
print(math.sqrt(16))  # 4.0

from datetime import datetime
print(datetime.now())

```

### 🔹 사용자 정의 모듈

```python
# utils.py
def add(a, b):
    return a + b

# main.py
from utils import add
print(add(3, 4))  # 7

```

### 🧠 실무 팁

- 파일 이름이 곧 모듈 이름
- `__init__.py`가 있으면 패키지로 인식
- 외부 라이브러리는 `pip install`로 설치 (`numpy`, `pandas` 등)

## ✅ 4. Pandas / Numpy 기초

### 🔹 Pandas: 표 형태 데이터 분석

```python
import pandas as pd

data = {"name": ["Alice", "Bob"], "age": [25, 30]}
df = pd.DataFrame(data)
print(df["name"])  # Series 출력
```

### 🔹 주요 기능

| 기능        | 예시                      |
| ----------- | ------------------------- |
| CSV 읽기    | `pd.read_csv("data.csv")` |
| 행 선택     | `df.iloc[0]`, `df.loc[0]` |
| 조건 필터링 | `df[df["age"] > 25]`      |
| 정렬        | `df.sort_values("age")`   |

### 🔹 Numpy: 수치 연산용 배열 라이브러리

```python
import numpy as np

arr = np.array([1, 2, 3])
print(arr * 2)  # [2 4 6]
```

### 🔹 주요 기능

| 기능         | 예시                                |
| ------------ | ----------------------------------- |
| 배열 생성    | `np.array`, `np.zeros`, `np.arange` |
| 브로드캐스팅 | `arr + 10`                          |
| 통계 연산    | `np.mean(arr)`, `np.std(arr)`       |
| 다차원 배열  | `arr.reshape(2, 3)`, `arr.T`        |

### 🧠 실무 팁

- **Pandas**는 Excel/CSV/DB 데이터를 다룰 때 강력
- **Numpy**는 대규모 수치 연산, 과학계산에서 필수
- Pandas는 내부적으로 Numpy를 사용함

## ✅ 전체 요약 정리

| 항목         | 핵심 내용              | 예시                     |
| ------------ | ---------------------- | ------------------------ |
| 자료구조     | 리스트, 딕셔너리, 집합 | `list`, `dict`, `set`    |
| 함수         | 재사용 가능한 코드     | `def`, `lambda`, `*args` |
| 모듈         | 코드 파일 재사용       | `import`, 사용자 정의    |
| Pandas/Numpy | 데이터 분석 도구       | `DataFrame`, `np.array`  |

# C: 포인터, 구조체, 파일 입출력

# 4-2. 라이브러리 활용

# java.util, java.io, java.net

## ✅ 1. `java.util` – 유틸리티 패키지 (자료구조, 날짜, 기타)

### ● 주요 클래스 분류

| 분류     | 주요 클래스                                  | 설명                    |
| -------- | -------------------------------------------- | ----------------------- |
| 📦 컬렉션 | `List`, `Set`, `Map`, `Queue`                | 자료구조                |
| 📅 날짜   | `Date`, `Calendar`, `LocalDateTime`          | 시간/날짜 처리          |
| 🔢 유틸   | `Random`, `Arrays`, `Collections`, `Scanner` | 정렬, 난수, 편의 메서드 |

### ● 예시: List, Map

```java
import java.util.*;

List<String> names = new ArrayList<>();
names.add("Alice");
names.add("Bob");

Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 90);
System.out.println(scores.get("Alice"));  // 90

```

### 🧠 실무 팁

- `ArrayList`, `HashMap` → 기본 자료형 대신 객체 타입 사용 (`Integer`, `String`)
- `Collections.sort(list)` / `Arrays.sort(array)` 등 정렬 유틸 활용
- `Scanner`는 콘솔 입력, `Random`은 랜덤값 생성에 자주 사용

## ✅ 2. `java.io` – 입출력(IO) 패키지

### ● 주요 클래스 분류

| 유형          | 클래스                             | 설명                      |
| ------------- | ---------------------------------- | ------------------------- |
| 바이트 스트림 | `InputStream`, `OutputStream`      | 이진 파일/네트워크 입출력 |
| 문자 스트림   | `Reader`, `Writer`                 | 텍스트 파일 입출력        |
| 고급 스트림   | `Buffered`, `Print`, `Object` 계열 | 성능 향상, 직렬화 등      |

### ● 예시: 파일 읽기/쓰기

```java
import java.io.*;

BufferedReader br = new BufferedReader(new FileReader("input.txt"));
BufferedWriter bw = new BufferedWriter(new FileWriter("output.txt"));

String line;
while ((line = br.readLine()) != null) {
    bw.write(line);
    bw.newLine();
}

br.close();
bw.close();

```

### 🧠 실무 팁

- **try-with-resources** 구문으로 자원 자동 해제 권장
- 대용량 파일은 `BufferedReader/Writer`로 처리 (메모리 효율)
- 직렬화(Serializable)와 `ObjectOutputStream`/`InputStream`은 객체 저장에 사용됨

## ✅ 3. `java.net` – 네트워크 패키지

### ● 주요 클래스

| 클래스                   | 설명                         |
| ------------------------ | ---------------------------- |
| `URL`, `URLConnection`   | 웹 주소 연결, 요청/응답 처리 |
| `Socket`, `ServerSocket` | TCP 클라이언트/서버 구현     |
| `InetAddress`            | IP 주소 관리                 |
| `DatagramSocket`         | UDP 통신                     |

### ● 예시: TCP 클라이언트/서버

#### 🔹 서버

```java
ServerSocket server = new ServerSocket(1234);
Socket client = server.accept();
BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream()));
System.out.println("클라이언트: " + in.readLine());
```

#### 🔹 클라이언트

```java
Socket socket = new Socket("localhost", 1234);
PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
out.println("안녕하세요!");
```

### 🧠 실무 팁

- **Socket**은 블로킹 I/O 기반, 대용량 처리에는 `NIO`(Non-blocking IO) 또는 프레임워크(Netty 등) 사용
- **URL**을 통한 HTTP 통신은 `HttpURLConnection`보다 `HttpClient` (Java 11 이상) 사용 권장
- 로컬 IP/도메인 해석은 `InetAddress.getByName("www.example.com")`

## ✅ 전체 요약 정리

| 패키지      | 역할           | 대표 클래스                                    | 실무 활용                      |
| ----------- | -------------- | ---------------------------------------------- | ------------------------------ |
| `java.util` | 자료구조, 유틸 | `ArrayList`, `HashMap`, `Random`, `Scanner`    | 컬렉션 처리, 날짜 계산         |
| `java.io`   | 파일 입출력    | `File`, `BufferedReader`, `ObjectOutputStream` | 텍스트/바이너리 파일 읽고 쓰기 |
| `java.net`  | 네트워크 통신  | `Socket`, `URL`, `HttpURLConnection`           | TCP, HTTP, IP 통신 구현        |

# Python 표준 라이브러리

## ✅ Python 표준 라이브러리란?

> Python 설치 시 **기본 포함되어 있는 모듈/패키지 집합**
>  별도의 설치 없이 `import`만으로 사용 가능하며,
>  문자열 처리, 날짜, 파일 입출력, 수학, 시스템, 네트워크 등 **전 분야를 지원**

## 📂 주요 라이브러리 분류표

| 범주          | 모듈                            | 주요 기능         |
| ------------- | ------------------------------- | ----------------- |
| 문자열 처리   | `re`, `string`                  | 정규표현식, 포맷  |
| 날짜/시간     | `datetime`, `time`, `calendar`  | 날짜 계산, 타이머 |
| 파일/디렉토리 | `os`, `pathlib`, `shutil`       | 파일 시스템 조작  |
| 시스템 제어   | `sys`, `argparse`               | 인자 처리, 종료   |
| 수학/통계     | `math`, `random`, `statistics`  | 수식, 난수, 평균  |
| 자료구조      | `collections`, `heapq`, `queue` | deque, heap       |
| 데이터 직렬화 | `json`, `pickle`                | 저장/로드         |
| 네트워크      | `socket`, `urllib`              | 소켓, HTTP 요청   |
| 압축/암호화   | `zipfile`, `hashlib`            | 압축, 해시        |
| 디버깅        | `logging`, `traceback`          | 로그, 예외 추적   |

## ✅ 1. 문자열 처리

### 🔹 `re` – 정규 표현식

```python
import re
text = "email: user@example.com"
match = re.search(r'\w+@\w+\.\w+', text)
print(match.group())  # user@example.com
```

## ✅ 2. 날짜/시간

### 🔹 `datetime`

```python
from datetime import datetime, timedelta

now = datetime.now()
future = now + timedelta(days=7)
print(future.strftime('%Y-%m-%d'))

```

## ✅ 3. 파일/디렉토리

### 🔹 `os`, `shutil`, `pathlib`

```python
import os
print(os.getcwd())  # 현재 경로
os.mkdir("mydir")

from pathlib import Path
p = Path("mydir") / "file.txt"
p.write_text("Hello")

```

## ✅ 4. 시스템 제어

### 🔹 `sys`

```python
import sys
print(sys.argv)  # 명령줄 인자 리스트
sys.exit()       # 프로그램 종료

```

### 🔹 `argparse`

```python
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--name')
args = parser.parse_args()
print(args.name)

```

## ✅ 5. 수학/통계

### 🔹 `math`, `random`, `statistics`

```python
import math, random, statistics
print(math.sqrt(25))  # 5.0
print(random.randint(1, 10))  # 1~10 정수
print(statistics.mean([1, 2, 3]))  # 평균

```

## ✅ 6. 자료구조

### 🔹 `collections`

```python
from collections import deque, Counter, defaultdict

dq = deque([1, 2])
dq.appendleft(0)

counter = Counter("hello")
print(counter['l'])  # 2

dd = defaultdict(int)
dd['a'] += 1

```

## ✅ 7. 데이터 직렬화

### 🔹 `json`, `pickle`

```python
import json
data = {"name": "Alice", "age": 30}
json_str = json.dumps(data)
print(json.loads(json_str)['name'])

import pickle
with open("data.pkl", "wb") as f:
    pickle.dump(data, f)

```

## ✅ 8. 네트워크

### 🔹 `socket`

```python
import socket
s = socket.socket()
s.connect(('example.com', 80))
s.send(b'GET / HTTP/1.1\r\nHost: example.com\r\n\r\n')

```

### 🔹 `urllib`

```python
from urllib.request import urlopen
html = urlopen("https://example.com").read()
print(html[:100])

```

## ✅ 9. 압축/암호화

### 🔹 `zipfile`, `hashlib`

```python
import zipfile
with zipfile.ZipFile('archive.zip', 'r') as z:
    z.extractall()

import hashlib
print(hashlib.md5(b'hello').hexdigest())

```

## ✅ 10. 디버깅 / 로깅

### 🔹 `logging`, `traceback`

```python
import logging
logging.basicConfig(level=logging.INFO)
logging.info("시작합니다")

try:
    1 / 0
except:
    import traceback
    traceback.print_exc()

```

## 🧠 실무 요약표

| 모듈              | 기능             | 실무 예          |
| ----------------- | ---------------- | ---------------- |
| `datetime`        | 날짜 계산        | 기간별 리포트    |
| `os` / `pathlib`  | 파일 제어        | 자동 백업        |
| `argparse`        | 명령줄 인자 처리 | CLI 도구 작성    |
| `json` / `pickle` | 파일 저장/로드   | 설정, 캐시       |
| `logging`         | 로깅             | 시스템 로그 관리 |
| `re`              | 패턴 매칭        | 텍스트 필터링    |
| `collections`     | 고급 자료구조    | 데이터 집계      |

# 외부 패키지 연동

# 4-3. 응용 SW API 사용

# Open API 호출

## ✅ 1. Open API란?

> 누구나 사용할 수 있도록 **공개된 웹 API**로,
>  일반적으로 **HTTP(S) 기반 REST 방식**으로 제공됨.
>  인증이 필요한 경우가 많고, **JSON, XML** 형식으로 데이터 반환.

## ✅ 2. 호출 방식 요약

| 항목            | 설명                           | 예시                            |
| --------------- | ------------------------------ | ------------------------------- |
| **요청 메서드** | `GET`, `POST`, `PUT`, `DELETE` | `GET`으로 데이터 조회           |
| **요청 URL**    | API 주소 + 쿼리스트링          | `...?q=seoul&key=API_KEY`       |
| **헤더**        | 인증, 타입 지정 등             | `Authorization`, `Content-Type` |
| **응답 형식**   | `JSON`, `XML`                  | `.json()` 파싱                  |

## ✅ 3. 필수 도구: `requests` 라이브러리

```bash
pip install requests

```

## ✅ 4. 실전 예제 – 공공데이터 포털(OpenAPI)

예시: **공공데이터포털 대기정보 조회 API**

```python
import requests

URL = "http://apis.data.go.kr/B552584/ArpltnInforInqireSvc/getCtprvnRltmMesureDnsty"
params = {
    "serviceKey": "발급받은인증키",
    "returnType": "json",
    "sidoName": "서울",
    "numOfRows": 5
}

response = requests.get(URL, params=params)
data = response.json()

for item in data['response']['body']['items']:
    print(f"{item['stationName']} : 미세먼지(PM10) {item['pm10Value']} ㎍/㎥")

```

## ✅ 5. POST 방식 예시 (JSON 본문 전달)

```python
url = "https://api.example.com/login"
headers = {"Content-Type": "application/json"}
payload = {"username": "admin", "password": "1234"}

res = requests.post(url, json=payload, headers=headers)
print(res.json())

```

## ✅ 6. 파일 다운로드 예제

```python
url = "https://example.com/file.zip"
res = requests.get(url)
with open("file.zip", "wb") as f:
    f.write(res.content)

```

## ✅ 7. 인증 방식 요약

| 인증 방식    | 설명                           | 예시                               |
| ------------ | ------------------------------ | ---------------------------------- |
| API Key      | 쿼리 파라미터 또는 헤더로 전달 | `?key=abc123`                      |
| Bearer Token | OAuth 기반 토큰 인증           | `Authorization: Bearer xxx`        |
| Basic Auth   | ID/PW Base64 인코딩            | `requests.auth.HTTPBasicAuth` 사용 |

### ● Bearer Token 헤더 예

```python
headers = {"Authorization": "Bearer YOUR_ACCESS_TOKEN"}
res = requests.get(api_url, headers=headers)

```

## 🧠 실무 팁 요약

| 팁                 | 설명                                           |
| ------------------ | ---------------------------------------------- |
| `timeout` 설정     | 응답 지연 방지: `requests.get(url, timeout=5)` |
| 예외 처리          | `try-except`으로 `requests.exceptions` 처리    |
| `status_code` 확인 | `res.status_code == 200` 체크                  |
| 반환값 처리        | `.json()` 또는 `.text` 또는 `.content`         |
| `params` / `json`  | GET은 `params`, POST는 `json` 활용             |

## ✅ 예외 처리 예시

```python
try:
    res = requests.get("https://example.com", timeout=3)
    res.raise_for_status()  # 4xx, 5xx 예외 발생
except requests.exceptions.RequestException as e:
    print("API 호출 실패:", e)

```

# JSON, XML 파싱

## ✅ 1. JSON 파싱

### ● 개념

> JSON (JavaScript Object Notation):
>  **키-값 쌍 기반의 텍스트 데이터 형식**.
>  대부분의 Open API, REST API에서 기본 응답 포맷으로 사용됨.

### ● 사용 라이브러리: `json` (표준 내장)

```python
import json

```

### ● 기본 사용 예제

```python
json_str = '{"name": "Alice", "age": 25}'
data = json.loads(json_str)   # 문자열 → 딕셔너리
print(data['name'])           # Alice

# 다시 JSON 문자열로 변환
json_out = json.dumps(data, indent=2)
print(json_out)

```

### ● JSON 파일 읽기/쓰기

```python
# 읽기
with open("data.json", "r", encoding="utf-8") as f:
    data = json.load(f)

# 쓰기
with open("output.json", "w", encoding="utf-8") as f:
    json.dump(data, f, indent=4)

```

## ✅ 2. XML 파싱

### ● 개념

> XML (eXtensible Markup Language):
>  **태그 기반의 계층적 구조 데이터 형식**.
>  정부, 공공기관, SOAP API 등에서 여전히 많이 사용됨.

### ● 사용 라이브러리

| 라이브러리              | 설명                                     |
| ----------------------- | ---------------------------------------- |
| `xml.etree.ElementTree` | 내장, 가장 기본적인 파싱                 |
| `BeautifulSoup`         | HTML/XML 모두 파싱 가능 (강력함)         |
| `lxml`                  | 빠르고 강력한 외부 라이브러리 (선택사항) |

### ● 기본 예제 (`ElementTree`)

```python
import xml.etree.ElementTree as ET

xml_data = '''
<person>
  <name>Alice</name>
  <age>25</age>
</person>
'''

root = ET.fromstring(xml_data)
print(root.find('name').text)  # Alice

```

### ● XML 파일 읽기

```python
tree = ET.parse("data.xml")
root = tree.getroot()

for item in root.findall("item"):
    title = item.find("title").text
    print(title)

```

### ● BeautifulSoup 활용 예시

```bash
pip install beautifulsoup4

```

```python
from bs4 import BeautifulSoup

xml_data = "<note><to>Bob</to><from>Alice</from></note>"
soup = BeautifulSoup(xml_data, "xml")

print(soup.to.text)     # Bob
print(soup.find("from").text)  # Alice

```

## 🧠 JSON vs XML 파싱 비교 요약표

| 항목      | JSON              | XML                      |
| --------- | ----------------- | ------------------------ |
| 구조      | 딕셔너리/리스트   | 계층적 태그              |
| 표준 모듈 | `json`            | `xml.etree.ElementTree`  |
| 사용성    | API 응답에 일반적 | 공공데이터, 문서 중심    |
| 외부 도구 | 거의 불필요       | BeautifulSoup, lxml 추천 |

## ✅ 실무 팁 요약

| 상황                      | 추천                                          |
| ------------------------- | --------------------------------------------- |
| Open API 응답 처리        | JSON (`requests.get().json()`)                |
| 공공데이터 포털(XML 응답) | `ElementTree` 또는 `BeautifulSoup`            |
| JSON 응답 구조 분석       | `print(json.dumps(data, indent=2))`           |
| 중첩 구조                 | `for key in dict["data"]["items"]:` 방식 반복 |
| HTML + XML 혼합 파싱      | `BeautifulSoup("html.parser")` or `"xml"      |

# RESTful 통신 구현

## ✅ 1. RESTful이란?

> **HTTP 프로토콜을 기반으로 리소스를 자원 중심으로 설계**한 통신 방식

### ● REST 핵심 구성

| 요소                 | 의미                | 예시                    |
| -------------------- | ------------------- | ----------------------- |
| 리소스(Resource)     | URI로 표현되는 대상 | `/users`, `/posts/1`    |
| 메서드(Method)       | HTTP 행위           | GET, POST, PUT, DELETE  |
| 표현(Representation) | 리소스 상태         | JSON, XML, HTML 등      |
| 상태코드             | 처리 결과 명시      | 200, 201, 400, 404, 500 |

### ● HTTP 메서드 매핑

| HTTP 메서드 | 의미      | 예시 URI             |
| ----------- | --------- | -------------------- |
| `GET`       | 조회      | `/users`, `/users/1` |
| `POST`      | 생성      | `/users`             |
| `PUT`       | 전체 수정 | `/users/1`           |
| `PATCH`     | 부분 수정 | `/users/1`           |
| `DELETE`    | 삭제      | `/users/1`           |

## ✅ 2. 서버 구현 (Flask)

```bash
pip install flask

```

### ● 기본 구조

```python
from flask import Flask, request, jsonify

app = Flask(__name__)
users = {}

@app.route('/users', methods=['POST'])
def create_user():
    data = request.get_json()
    users[data['id']] = data['name']
    return jsonify({'result': 'ok'}), 201

@app.route('/users/<id>', methods=['GET'])
def get_user(id):
    name = users.get(id)
    if name:
        return jsonify({'id': id, 'name': name})
    else:
        return jsonify({'error': 'Not Found'}), 404

if __name__ == '__main__':
    app.run(debug=True)

```

## ✅ 3. 클라이언트 구현 (requests)

```bash
pip install requests

```

### ● POST 요청 (생성)

```python
import requests

url = 'http://localhost:5000/users'
data = {'id': '1', 'name': 'Alice'}
res = requests.post(url, json=data)
print(res.status_code, res.json())

```

### ● GET 요청 (조회)

```python
res = requests.get('http://localhost:5000/users/1')
print(res.json())  # {'id': '1', 'name': 'Alice'}

```

## ✅ 4. 실무 REST API 설계 규칙 요약

| 요소             | 설계 기준                                       |
| ---------------- | ----------------------------------------------- |
| URI 명사형       | `/users`, `/products/1` (동사가 아님)           |
| 메서드 일관성    | `GET`, `POST`, `PUT`, `DELETE`                  |
| 상태코드 사용    | 200(성공), 201(생성), 400(오류), 404(없음) 등   |
| JSON 응답 표준화 | `{"code": 200, "result": ..., "message": "OK"}` |
| 요청 유효성 검사 | `request.get_json()` 사용 후 검사 로직 작성     |

## 🧠 실무 팁 요약

| 상황       | 방법                                        |
| ---------- | ------------------------------------------- |
| CORS 허용  | `flask-cors` 설치 후 `CORS(app)`            |
| 인증/보안  | 토큰 방식(JWT), 헤더에 `Authorization` 포함 |
| API 문서화 | Swagger (`flasgger`, `drf-yasg` 등)         |
| 배포       | Flask → `gunicorn + nginx` 조합 or Docker   |

## ✅ 요청 흐름 요약

```
[Client] → [HTTP 요청] → [Flask Router]
       → [request 객체 처리]
       → [DB or Logic 처리]
       ← [jsonify 응답 반환] ← [Client 응답]

```

# 4-4. 웹 프로그래밍 개론

# HTML, CSS, JavaScript

## ✅ 1. HTML (HyperText Markup Language)

> 웹페이지의 **구조(뼈대)**를 정의하는 마크업 언어
>  요소(Element)는 `<태그>내용</태그>` 형식

### ● 기본 구조

```html
<!DOCTYPE html>
<html>
  <head>
    <title>내 웹페이지</title>
  </head>
  <body>
    <h1>환영합니다</h1>
    <p>이건 본문입니다.</p>
  </body>
</html>

```

### ● 주요 태그

| 태그             | 의미       | 예시                                    |
| ---------------- | ---------- | --------------------------------------- |
| `<h1>` ~ `<h6>`  | 제목       | `<h1>제목</h1>`                         |
| `<p>`            | 문단       | `<p>문장</p>`                           |
| `<a>`            | 하이퍼링크 | `<a href="https://naver.com">링크</a>`  |
| `<img>`          | 이미지     | `<img src="img.jpg" alt="사진">`        |
| `<ul>/<ol>/<li>` | 목록       | `<ul><li>항목</li></ul>`                |
| `<table>`        | 표         | `<table><tr><td>내용</td></tr></table>` |
| `<form>`         | 입력폼     | `<form><input></form>`                  |

## ✅ 2. CSS (Cascading Style Sheets)

> HTML 요소에 **디자인(색, 폰트, 배치 등 스타일)**을 지정하는 언어
>  선택자(selector)와 속성(property)으로 구성

### ● 기본 문법

```css
h1 {
  color: blue;
  font-size: 24px;
}

```

### ● 적용 방식

| 방식        | 설명              | 예시                                       |
| ----------- | ----------------- | ------------------------------------------ |
| 인라인      | 태그에 직접       | `<p style="color:red">문장</p>`            |
| 내부 스타일 | `<style>` 태그 안 | `<style>p {}</style>`                      |
| 외부 스타일 | `.css` 파일 연결  | `<link rel="stylesheet" href="style.css">` |

### ● 주요 속성

| 속성                        | 설명           | 예시                                    |
| --------------------------- | -------------- | --------------------------------------- |
| `color`, `background-color` | 글자/배경 색   | `color: red;`                           |
| `font-size`, `font-family`  | 글꼴 크기/종류 | `font-size: 16px;`                      |
| `margin`, `padding`         | 바깥/안쪽 여백 | `margin: 10px;`                         |
| `border`                    | 테두리         | `border: 1px solid black;`              |
| `display`, `position`       | 배치 방식      | `display: flex;`, `position: absolute;` |

## ✅ 3. JavaScript

> 웹페이지에 **동적인 동작과 로직**을 추가하는 프로그래밍 언어
>  브라우저에서 실행됨 (Client-side)

### ● 기본 문법

```html
<script>
  alert("Hello, JavaScript!");
</script>

```

### ● 변수, 함수

```js
let name = "Alice";
function greet() {
  console.log("Hi " + name);
}
greet();  // Hi Alice

```

### ● DOM 조작

```html
<p id="demo">내용</p>
<script>
  document.getElementById("demo").innerText = "변경된 내용";
</script>

```

### ● 이벤트 처리

```html
<button onclick="alert('버튼 클릭됨')">클릭</button>

```

### ● 주요 기능 예시

| 기능   | 설명           | 코드                             |
| ------ | -------------- | -------------------------------- |
| 조건문 | `if`, `else`   | `if (x > 0) {}`                  |
| 반복문 | `for`, `while` | `for (let i = 0; i < 5; i++) {}` |
| 배열   | `[]`           | `let arr = [1, 2, 3];`           |
| 객체   | `{}`           | `let user = {name: "Tom"};`      |

## ✅ 웹페이지 통합 예시

```html
<!DOCTYPE html>
<html>
<head>
  <title>예제</title>
  <style>
    body { background-color: #f0f0f0; font-family: sans-serif; }
    p { color: blue; }
  </style>
</head>
<body>
  <h1>JavaScript 동작 테스트</h1>
  <p id="text">초기 텍스트</p>
  <button onclick="changeText()">변경하기</button>

  <script>
    function changeText() {
      document.getElementById("text").innerText = "변경 완료!";
    }
  </script>
</body>
</html>

```

## 🧠 실무 팁 요약

| 항목            | 추천 방식                              |
| --------------- | -------------------------------------- |
| CSS 분리        | 별도 `.css` 파일 관리 (`style.css`)    |
| JS 분리         | `<script src="main.js"></script>`      |
| 접근성          | `alt`, `label`, `aria-*` 속성 사용     |
| 반응형          | CSS `@media`, `flex`, `grid` 활용      |
| 브라우저 호환성 | 최신 문법 시 Babel, Polyfill 사용 고려 |

# 클라이언트-서버 모델

## ✅ 1. 클라이언트-서버 모델이란?

> 네트워크 상에서 **역할을 분리하여 통신하는 구조**
>  **클라이언트(Client)**는 요청을 보내고,
>  **서버(Server)**는 요청을 처리하고 응답을 보내는 구조

### 🔸 구성 요소

| 구성       | 역할                                          |
| ---------- | --------------------------------------------- |
| 클라이언트 | 사용자 입장에서 요청 (웹 브라우저, 앱 등)     |
| 서버       | 요청을 받아 처리하고 응답 (웹서버, DB서버 등) |
| 네트워크   | 양측을 연결해주는 매개 (인터넷, LAN 등)       |

## ✅ 2. 작동 흐름

```
[Client] --요청(Request)--> [Server]
            <--응답(Response)--      
```

- 클라이언트가 **요청(request)** 전송 (예: 웹사이트 접속)
- 서버가 **요청 처리 후 응답(response)** 전송 (HTML, JSON 등)

## ✅ 3. 동작 구조 예시

```
사용자 → 브라우저에서 www.example.com 접속
→ 브라우저가 HTTP 요청 전송
→ 웹 서버가 HTML 페이지 응답
→ 브라우저가 렌더링하여 사용자에게 보여줌

```

## ✅ 4. 실습 예제 – Python 소켓 기반

### ● 서버 (서버는 먼저 실행해야 함)

```python
# server.py
import socket

server = socket.socket()
server.bind(('localhost', 9999))
server.listen(1)
print("서버 대기 중...")

conn, addr = server.accept()
print("접속:", addr)
msg = conn.recv(1024).decode()
print("클라이언트:", msg)

conn.send("안녕하세요 클라이언트님".encode())
conn.close()

```

### ● 클라이언트

```python
# client.py
import socket

client = socket.socket()
client.connect(('localhost', 9999))
client.send("Hello Server".encode())

reply = client.recv(1024).decode()
print("서버 응답:", reply)

client.close()

```

## ✅ 5. 웹 시스템에서의 적용

| 요소       | 실체 예                  |
| ---------- | ------------------------ |
| 클라이언트 | 웹 브라우저, 모바일 앱   |
| 서버       | Flask, Spring, Django 등 |
| 요청       | HTTP GET, POST 요청      |
| 응답       | HTML, JSON, 파일 등      |
| 통신 방식  | REST, WebSocket, gRPC 등 |

## ✅ 6. 클라이언트-서버 vs P2P 비교

| 구조                   | 설명             | 예시                  |
| ---------------------- | ---------------- | --------------------- |
| **Client-Server**      | 중앙 집중형      | 웹사이트, 은행 시스템 |
| **P2P (Peer-to-Peer)** | 모든 노드가 동등 | 토렌트, 블록체인      |

## 🧠 실무 팁 요약

| 상황      | 팁                                             |
| --------- | ---------------------------------------------- |
| 확장성    | 서버는 멀티스레드 or 멀티프로세싱 구조         |
| 보안      | HTTPS 사용, 인증 토큰, 방화벽 구성             |
| 오류 처리 | 타임아웃, 연결 끊김 예외 처리 필수             |
| 상태유지  | 세션(Session), 쿠키(Cookie), 토큰(JWT) 등 활용 |

# 프론트엔드/백엔드 개념

## ✅ 프론트엔드 vs 백엔드란?

| 구분          | 프론트엔드 (Frontend)                   | 백엔드 (Backend)                                |
| ------------- | --------------------------------------- | ----------------------------------------------- |
| **정의**      | 사용자가 직접 보는 **화면, 인터페이스** | 화면 뒤에서 **데이터 처리, 비즈니스 로직** 수행 |
| **역할**      | UI/UX 구현, 사용자 입력 처리            | DB 연동, 인증, API 제공, 서버 관리              |
| **동작 위치** | **브라우저** (클라이언트 측)            | **서버** 또는 클라우드 (서버 측)                |

## ✅ 프론트엔드 구성 요소

| 요소       | 설명                                       |
| ---------- | ------------------------------------------ |
| HTML       | 구조 (뼈대)                                |
| CSS        | 스타일링 (디자인)                          |
| JavaScript | 동적 동작 (클릭, 요청 등)                  |
| 프레임워크 | React, Vue, Angular 등                     |
| API 요청   | 서버로 데이터 요청 (AJAX, fetch, axios 등) |

## ✅ 백엔드 구성 요소

| 요소         | 설명                          |
| ------------ | ----------------------------- |
| 언어         | Java, Python, Node.js, PHP 등 |
| 프레임워크   | Spring, Django, Express 등    |
| 데이터베이스 | MySQL, PostgreSQL, MongoDB 등 |
| API 설계     | RESTful API, GraphQL 등       |
| 서버관리     | Nginx, Docker, AWS 등 포함    |

## ✅ 전체 동작 흐름 요약

```
[User 브라우저]
  → [Frontend] HTML + JS + CSS 로 UI 출력
  → [API 호출] fetch("/api/user") 등
  → [Backend 서버] 요청 수신 → DB 조회
  ← [응답 JSON] → 프론트에서 렌더링
```

## ✅ 예시: 사용자 로그인

| 단계         | 프론트엔드                     | 백엔드                  |
| ------------ | ------------------------------ | ----------------------- |
| 1. 입력      | ID/PW 입력 폼 작성             | -                       |
| 2. 요청      | 로그인 버튼 클릭 → API 전송    | 로그인 로직 처리        |
| 3. 처리      | -                              | DB에서 사용자 인증 확인 |
| 4. 응답      | 성공 시 화면 전환 or 에러 표시 | JSON 응답: OK or 401    |
| 5. 상태 저장 | 토큰 저장 (쿠키/localStorage)  | 토큰 발급 및 검증       |

## ✅ 프론트엔드 vs 백엔드 비교표

| 항목      | 프론트엔드              | 백엔드                   |
| --------- | ----------------------- | ------------------------ |
| 위치      | 클라이언트(브라우저)    | 서버                     |
| 기술      | HTML, CSS, JS, React 등 | Python, Java, Node.js 등 |
| 관심사    | 화면, UX, 반응성        | 데이터, 로직, 보안       |
| 대표 도구 | Figma, Chrome DevTools  | Postman, DBMS, API 서버  |
| 출력 결과 | UI                      | API(JSON, 파일 등)       |

## ✅ 풀스택(Full Stack)이란?

> 프론트엔드 + 백엔드 모두 이해하고 개발할 수 있는 개발자

### ● 기술 조합 예시 (풀스택)

- **프론트**: React + TailwindCSS
- **백엔드**: Django REST API
- **DB**: PostgreSQL
- **배포**: Docker + Nginx + AWS EC2

## 🧠 실무 팁 요약

| 질문                     | 답변                              |
| ------------------------ | --------------------------------- |
| 프론트에서 DB 접속 가능? | ❌. 반드시 백엔드 거쳐야 함 (보안) |
| 통신 방식은?             | REST API, AJAX, fetch, axios      |
| 왜 역할 구분?            | 보안, 확장성, 유지보수 때문       |
| 프론트에서 중요한 건?    | UX, 반응성, 비동기 처리           |
| 백엔드에서 중요한 건?    | 보안, 데이터 무결성, 성능         |

# 5. **정보시스템 구축관리**

# 5-1. 프로젝트 관리

# 프로젝트 생명주기

## ✅ 프로젝트 생명주기란?

> 하나의 소프트웨어/IT 프로젝트가 **처음 구상되어 시작되고, 개발되며, 유지관리되고, 종료되는 전 과정을 구조화한 것**
>  PMBOK, SDLC(Software Development Life Cycle), ISO/IEC 표준 등에서 정의된 절차 기반

## ✅ 전체 단계 요약 (SDLC 기준)

| 단계                        | 핵심 질문                                 | 주요 산출물                |
| --------------------------- | ----------------------------------------- | -------------------------- |
| 1. **요구사항 분석**        | 무엇을 만들 것인가?                       | 요구사항 명세서 (SRS)      |
| 2. **설계(Design)**         | 어떻게 만들 것인가?                       | 시스템/DB/아키텍처 설계서  |
| 3. **구현(Implementation)** | 어떻게 코드로 구현할 것인가?              | 소스코드, 버전관리         |
| 4. **테스트(Test)**         | 잘 동작하는가?                            | 테스트케이스, 버그리포트   |
| 5. **배포(Deployment)**     | 어떻게 배포하고 사용할 수 있게 할 것인가? | 빌드 결과물, 운영환경 구성 |
| 6. **운영 및 유지보수**     | 지속적으로 안정적으로 운영되는가?         | 로그분석, 패치, 보안점검   |

## ✅ 각 단계 상세 정리

### 🔹 1. 요구사항 분석 (Requirement Analysis)

- 사용자 니즈, 기능 요구사항, 비기능 요구사항 수집
- 워크숍, 인터뷰, 설문조사, Use Case 모델 활용
- **산출물:** 요구사항 명세서 (SRS), 기능 목록, 유스케이스 다이어그램

### 🔹 2. 설계 (Design)

- 시스템 구조, 데이터베이스, 모듈, 인터페이스 설계
- 아키텍처 결정 (MVC, 레이어드 등), ERD 작성
- **산출물:** 설계 명세서, ERD, UML, API 명세서

### 🔹 3. 구현 (Development)

- 실제 개발자가 코딩하는 단계
- 버전 관리(Git), 코드 리뷰, CI/CD 적용
- **산출물:** 소스코드, 커밋 로그, 유닛 테스트 코드

### 🔹 4. 테스트 (Testing)

- 요구사항 기반 테스트케이스 작성 및 실행
- 유닛, 통합, 시스템, 인수 테스트 수행
- **산출물:** 테스트 계획서, 테스트 결과 리포트, QA 문서

### 🔹 5. 배포 (Deployment)

- 운영 환경에 코드 배포 및 릴리즈
- 도커, Jenkins, Kubernetes 등 활용 가능
- **산출물:** 빌드 결과물, 배포 스크립트, 운영 인수인계 문서

### 🔹 6. 운영 및 유지보수 (Maintenance)

- 사용 중 발견된 버그 수정, 기능 개선
- 정기 보안 점검, 로그 모니터링, SLA 준수
- **산출물:** 수정 내역 문서, 운영 매뉴얼, 릴리즈 노트

## 🧠 실무 팁 요약

| 항목              | 팁                                      |
| ----------------- | --------------------------------------- |
| **초기 단계**     | 요구사항 빠짐/모호함이 나중에 비용 ↑    |
| **설계 중요성**   | 설계 없이 코딩하면 구조가 무너짐        |
| **테스트 자동화** | CI 파이프라인과 함께 필수화             |
| **배포 전략**     | 무중단 배포(blue/green, canary) 고려    |
| **운영 중 로그**  | 실시간 모니터링으로 장애 조기 발견 가능 |

## ✅ 예시: 웹 서비스 프로젝트 생명주기

```
1. 고객 요구: 예약 시스템 필요  
→ 2. 설계: 화면 흐름도 + DB 설계 (ERD)  
→ 3. 구현: React + Django 개발  
→ 4. 테스트: 기능 테스트, UI 테스트  
→ 5. 배포: AWS 서버에 Docker로 배포  
→ 6. 운영: 모니터링 + 주기적 보안 패치
```

## ✅ 참고: 프로젝트 관리 프로세스 (PMBOK 기반)

| 분류      | 설명                                     |
| --------- | ---------------------------------------- |
| 착수      | 프로젝트 시작 정의, 이해관계자 식별      |
| 계획      | 범위, 일정, 리스크, 품질, 자원 계획 수립 |
| 실행      | 개발 실행, 인력 배치, 업무 수행          |
| 감시/통제 | 일정, 품질, 비용 모니터링                |
| 종료      | 산출물 검수, 결과 문서화, 마무리 보고    |

# WBS, CPM, Gantt Chart

## ✅ 1. WBS (Work Breakdown Structure) – 작업 분할 구조

> 프로젝트를 **작업 단위(Work Package)**로 계층적으로 나눈 구조
>  "무엇을 할 것인가?"에 대한 답 → 범위(Work Scope)를 명확히 함

### ● 구성 방식

```
├── 1. 기획
│   ├── 1.1 요구사항 수집
│   └── 1.2 기능 정의
├── 2. 설계
│   ├── 2.1 화면 설계
│   └── 2.2 DB 설계
├── 3. 구현
│   ├── 3.1 프론트엔드
│   └── 3.2 백엔드
```

### ● 실무 목적

| 효과      | 설명                       |
| --------- | -------------------------- |
| 작업 정의 | 전체 범위 시각화           |
| 책임 구분 | 부서별, 인력별 작업 지정   |
| 예산 추정 | 각 작업에 비용과 자원 연결 |

## ✅ 2. CPM (Critical Path Method) – 주공정법

> 프로젝트 일정 중 **가장 오래 걸리는 경로(최장 경로)**를 찾아
>  전체 프로젝트 기간을 결정하는 기법

### ● 용어 정리

| 용어                      | 의미                                            |
| ------------------------- | ----------------------------------------------- |
| 작업(활동)                | 실제 수행되는 단위 작업                         |
| 노드                      | 이벤트, 작업의 시작/종료                        |
| 경로                      | 시작 → 종료까지 연결된 작업들의 집합            |
| **주경로(Critical Path)** | 여유 시간(부동)이 0인 경로 → 프로젝트 기간 결정 |

### ● 예시 (작업 시간 단위: 일)

```
A(2) → B(4) → E(3)
A(2) → C(3) → D(2) → E(3)
```

- 경로1: A-B-E = 2+4+3 = **9일**
- 경로2: A-C-D-E = 2+3+2+3 = **10일** ← **주경로(Critical Path)**

### ● 실무 활용

| 항목      | 설명                                      |
| --------- | ----------------------------------------- |
| 일정 단축 | 주경로 작업에 인력 집중                   |
| 위험 관리 | 주경로 작업 지연 시 전체 지연             |
| 여유 확인 | 부경로 작업은 일정 조정 여지 있음 (Float) |

## ✅ 3. Gantt Chart (간트 차트)

> **작업별 일정과 기간을 막대그래프로 시각화**한 프로젝트 도구
>  "언제 누가 무엇을 얼마나" 할지를 한눈에 보여줌

### ● 구성 요소

| 요소    | 설명                    |
| ------- | ----------------------- |
| Y축     | 작업 항목 (WBS 기반)    |
| X축     | 시간 (일/주/월 단위)    |
| 바(bar) | 작업 기간 표시          |
| 연관선  | 의존관계 표시 (→, ↘ 등) |

### ● 예시

| 작업   | 시작일 | 종료일 | 기간 |
| ------ | ------ | ------ | ---- |
| 기획   | 5/1    | 5/3    | 3일  |
| 설계   | 5/4    | 5/8    | 5일  |
| 구현   | 5/9    | 5/20   | 10일 |
| 테스트 | 5/21   | 5/25   | 5일  |

→ Gantt Chart 툴: **Excel, Notion, Jira, MS Project, Trello + Gantt Power-Up**

## ✅ 3대 도구 비교 정리

| 구분        | WBS               | CPM                  | Gantt Chart           |
| ----------- | ----------------- | -------------------- | --------------------- |
| 목적        | 작업 정의, 구조화 | 일정 분석, 경로 도출 | 전체 일정 시각화      |
| 구조        | 계층적 (트리)     | 네트워크 흐름        | 막대 그래프           |
| 주요 포인트 | "무엇을?"         | "언제, 어디가 중요?" | "언제 무엇을 얼마나?" |
| 활용 시기   | 초반 설계         | 일정 확정/분석       | 실행/진행 추적        |

## 🧠 실무 팁 요약

| 팁                    | 설명                                        |
| --------------------- | ------------------------------------------- |
| **WBS 먼저**          | 전체 작업을 식별하고 계층화한 후            |
| **CPM으로 일정 분석** | 병렬/직렬 작업 식별, 주경로 추출            |
| **Gantt로 진행관리**  | 일정표 작성 → 진척률 업데이트               |
| **PM 도구 사용 추천** | Notion, ClickUp, Jira, MS Project, Excel 등 |

# 형상관리 / 변경관리

## ✅ 1. 형상관리(Configuration Management)

> **소프트웨어 개발 산출물(코드, 문서, 설정 등)의 버전, 변경, 상태를 체계적으로 관리**하는 활동
>  "무엇이, 언제, 어떻게 바뀌었는가?"를 추적 가능하게 만드는 기술

### 🔸 목적

| 목적        | 설명                              |
| ----------- | --------------------------------- |
| 변경 추적   | 코드, 문서, 환경 설정의 이력 보존 |
| 버전 통제   | 특정 시점의 상태로 복구 가능      |
| 협업 지원   | 여러 개발자 작업 병합/분기 관리   |
| 무결성 유지 | 일관된 산출물 유지 (재현 가능성)  |

### 🔸 구성 요소 (4대 기능)

| 구성 요소          | 설명                                     |
| ------------------ | ---------------------------------------- |
| **형상 식별**      | 관리 대상 정의 (코드, 문서, 바이너리 등) |
| **형상 통제**      | 변경 요청, 승인, 반영 절차 관리          |
| **형상 상태 보고** | 버전, 이력, 변경 기록 보고               |
| **형상 감사**      | 실제 산출물과 기록된 정보 일치 여부 점검 |

### 🔸 대표 도구

| 도구                     | 설명                                     |
| ------------------------ | ---------------------------------------- |
| **Git**                  | 분산형 버전관리 시스템 (최고 인기)       |
| **SVN**                  | 중앙집중형, 조직형 프로젝트에 적합       |
| **GitHub / GitLab**      | Git 호스팅 플랫폼, CI/CD 연계            |
| **Jenkins**, **Ansible** | 설정파일/배포 설정도 형상 관리 대상 가능 |

## ✅ 2. 변경관리(Change Management)

> **요구사항, 설계, 코드, 기능의 변경을 공식적인 프로세스에 따라 관리**하는 활동
>  변경 사항이 프로젝트에 미치는 영향을 **사전에 분석하고 통제**

### 🔸 절차 단계

| 단계           | 설명                                          |
| -------------- | --------------------------------------------- |
| 변경 요청      | 사용자/개발자가 공식 변경 제안                |
| 영향 분석      | 일정, 비용, 품질, 범위에 미치는 영향 평가     |
| 승인 여부 결정 | 변경관리 위원회(CCB) 또는 PM이 승인 여부 판단 |
| 변경 반영      | 승인 시 작업 항목에 적용 및 테스트            |
| 문서화         | 변경 이력, 테스트 결과 기록                   |

### 🔸 실무 적용 예시

> 예: 요구사항 변경 요청

```
1. 고객이 '비밀번호 찾기' 기능 추가 요청  
→ 2. 기능/보안 영향 분석 → 개발비용 +3일  
→ 3. PM 승인 → 백로그 추가  
→ 4. 형상관리 시스템(Git)에 변경 분기 생성  
→ 5. 구현 + 테스트 → 릴리즈 → 변경 이력 기록
```

## ✅ 형상관리 vs 변경관리 비교

| 구분      | 형상관리                         | 변경관리                           |
| --------- | -------------------------------- | ---------------------------------- |
| 초점      | **변경 이력과 산출물 상태 관리** | **변경 의사결정과 승인 절차 관리** |
| 관리 대상 | 코드, 문서, 설정 파일 등         | 요구사항, 기능, 일정, 범위         |
| 프로세스  | 버전관리, 브랜칭, 머지           | 변경 요청 → 영향 분석 → 승인       |
| 도구      | Git, SVN, GitLab, Jenkins        | Jira, Confluence, Redmine 등       |

## 🧠 실무 팁 요약

| 상황               | 팁                                 |
| ------------------ | ---------------------------------- |
| 협업 중 충돌       | Git 브랜치 전략 도입 (Git Flow 등) |
| 변경 요청 폭주     | 변경관리 위원회(CCB) 운영          |
| 산출물 누락 방지   | 형상 식별표 유지 (문서, 명세 포함) |
| 릴리즈 안정성 확보 | 형상감사 실시 + CI/CD 통합         |

# 5-2. 품질보증 및 시험

# ISO/IEC 25010

## ✅ ISO/IEC 25010이란?

> **소프트웨어 제품의 품질을 평가하기 위한 국제 표준 모델**
>  기존 ISO/IEC 9126을 계승하여, 2011년에 개정된 표준
>  **총 8개의 품질 특성과 31개의 세부 특성**으로 구성됨

## ✅ 품질 특성 8가지 (상위 특성)

| 품질 특성                               | 설명                                    |
| --------------------------------------- | --------------------------------------- |
| 1. 기능 적합성 (Functional Suitability) | 요구된 기능을 정확히 수행하는가         |
| 2. 성능 효율성 (Performance Efficiency) | 응답 속도, 자원 사용이 적절한가         |
| 3. 호환성 (Compatibility)               | 다른 시스템과 잘 작동하는가             |
| 4. 사용성 (Usability)                   | 배우기 쉽고, 사용하기 편한가            |
| 5. 신뢰성 (Reliability)                 | 오류 없이 안정적으로 작동하는가         |
| 6. 보안성 (Security)                    | 데이터가 안전하고 접근 통제가 되는가    |
| 7. 유지보수성 (Maintainability)         | 고치고 확장하기 쉬운가                  |
| 8. 이식성 (Portability)                 | 다양한 환경에서 쉽게 설치/이동 가능한가 |

## ✅ 각 품질 특성의 세부 특성

### 🔹 1. 기능 적합성

| 세부 특성   | 설명                          |
| ----------- | ----------------------------- |
| 기능 완전성 | 필요한 기능이 모두 존재하는가 |
| 기능 정확성 | 정확한 결과를 제공하는가      |
| 기능 적절성 | 목표를 효율적으로 지원하는가  |

### 🔹 2. 성능 효율성

| 세부 특성        | 설명                                   |
| ---------------- | -------------------------------------- |
| 응답 시간/처리량 | 빠르게 처리되는가                      |
| 자원 효율성      | CPU, 메모리 사용이 적절한가            |
| 용량             | 시스템이 감당할 수 있는 최대 부하 수준 |

### 🔹 3. 호환성

| 세부 특성  | 설명                                       |
| ---------- | ------------------------------------------ |
| 공존성     | 다른 시스템과 함께 사용해도 문제 없는가    |
| 상호운용성 | 다른 시스템과 통신, 데이터 교환이 가능한가 |

### 🔹 4. 사용성

| 세부 특성              | 설명                                  |
| ---------------------- | ------------------------------------- |
| 이해성                 | 사용자가 이해하기 쉬운가              |
| 학습성                 | 배우기 쉬운가                         |
| 운용성                 | 효율적으로 사용할 수 있는가           |
| 사용자 오류 보호성     | 사용자의 실수를 방지/복구할 수 있는가 |
| 사용자 인터페이스 미학 | 보기 좋은가                           |
| 접근성                 | 장애인이 사용 가능한가                |

### 🔹 5. 신뢰성

| 세부 특성   | 설명                             |
| ----------- | -------------------------------- |
| 성숙성      | 정상 동작 확률이 높은가          |
| 가용성      | 항상 사용할 수 있는가            |
| 결함 허용성 | 오류 발생 시도 복구 가능한가     |
| 복구성      | 장애 후 얼마나 빠르게 회복하는가 |

### 🔹 6. 보안성

| 세부 특성   | 설명                                     |
| ----------- | ---------------------------------------- |
| 기밀성      | 정보가 허가된 사용자에게만 보이는가      |
| 무결성      | 데이터가 손상 없이 유지되는가            |
| 부인 방지   | 행위자가 나중에 부정하지 못하도록 기록됨 |
| 사용자 인증 | 적절한 사용자만 접근할 수 있는가         |
| 권한 관리   | 역할 기반 접근 제어 등                   |

### 🔹 7. 유지보수성

| 세부 특성 | 설명                            |
| --------- | ------------------------------- |
| 모듈성    | 변경이 부분적으로 가능한가      |
| 재사용성  | 코드나 모듈을 재활용하기 쉬운가 |
| 분석성    | 오류나 원인을 찾기 쉬운가       |
| 변경성    | 수정이 쉬운가                   |
| 시험성    | 테스트하기 좋은 구조인가        |

### 🔹 8. 이식성

| 세부 특성   | 설명                                  |
| ----------- | ------------------------------------- |
| 환경 적응성 | 다양한 플랫폼에서 동작 가능한가       |
| 설치성      | 설치가 쉬운가                         |
| 대체성      | 다른 시스템으로 쉽게 대체될 수 있는가 |

## ✅ 실무 활용 예시

| 상황                   | 적용 특성                   |
| ---------------------- | --------------------------- |
| 고객이 느리다고 불만   | **성능 효율성 → 응답 시간** |
| 장애 발생 후 오래 걸림 | **신뢰성 → 복구성**         |
| 사용자가 어려워함      | **사용성 → 학습성, 운용성** |
| 플랫폼 확장 고려       | **이식성 → 환경 적응성**    |
| 보안 위협 대응         | **보안성 → 무결성, 인증성** |

## 🧠 실무 팁 요약

| 항목            | 팁                                              |
| --------------- | ----------------------------------------------- |
| 평가 기준       | 기능 외에도 품질 특성 기준 도입 필수            |
| 문서화          | 품질 요구사항을 SRS, Test Case에 명시           |
| 도구 연계       | 성능: JMeter / 보안: SonarQube / 가용성: Zabbix |
| 유지보수성 확보 | 모듈화, 주석, 테스트 코드 병행                  |

## ✅ ISO/IEC 25010 요약도

```
[ISO/IEC 25010 품질 모델]
├── 기능 적합성 (기능성)
├── 성능 효율성
├── 호환성
├── 사용성
├── 신뢰성
├── 보안성
├── 유지보수성
└── 이식성
```

# 품질 측정 기준

## ✅ 1. 품질 측정 기준이란?

> 소프트웨어의 **품질 특성(기능성, 성능, 신뢰성 등)**을
>  **정량적/정성적으로 평가하기 위해 사용하는 구체적인 측정 지표와 기준선**

즉,

> "품질이 좋다" → 어떤 특성이, 얼마나 좋은가?
>  → 수치나 조건으로 판단할 수 있어야 해.

## ✅ 2. 품질 특성별 대표 측정 지표

| 품질 특성       | 측정 기준(지표)             | 측정 방법                               |
| --------------- | --------------------------- | --------------------------------------- |
| **기능 적합성** | 요구사항 충족률             | 충족 요구사항 수 / 전체 요구사항 수 (%) |
| **성능 효율성** | 응답 시간, 처리량           | 평균 응답 시간(ms), 초당 요청 수        |
| **사용성**      | 에러율, 학습 시간           | 사용자 테스트: 5명 중 에러율 20%        |
| **신뢰성**      | 평균 고장 간격(MTBF)        | 고장 발생 주기 시간 측정                |
| **보안성**      | 취약점 수, 인증 통과율      | 보안 점검 도구 결과, 침투 테스트        |
| **유지보수성**  | 결함 수정 시간, 모듈 결합도 | 평균 수정 시간(hr), 코드 복잡도         |
| **이식성**      | 설치 성공률, OS별 호환성    | OS 5개 중 4개 성공(80%)                 |

## ✅ 3. 정량 vs 정성 지표 구분

| 분류       | 예시                          | 특징                          |
| ---------- | ----------------------------- | ----------------------------- |
| **정량적** | 응답시간, 버그 개수, 수정시간 | 수치로 측정 가능, 자동화 용이 |
| **정성적** | 사용성 만족도, UI 직관성      | 설문조사, 사용자 평가 기반    |

## ✅ 4. 실무용 측정 지표 예시 세트

### 🔹 예: 기능 품질 측정

| 지표명      | 설명                               |
| ----------- | ---------------------------------- |
| 기능 완전성 | 모든 요구사항 반영 여부 (%)        |
| 기능 정확성 | 기능 오작동 비율 (%)               |
| 기능 적절성 | 주요 업무 절차에서 기능이 유효한가 |

### 🔹 예: 성능 효율성 측정

| 지표명         | 기준                      |
| -------------- | ------------------------- |
| 평균 응답 시간 | < 200ms                   |
| 처리량         | 100 TPS 이상              |
| 자원 사용률    | CPU < 70%, RAM < 80% 유지 |

### 🔹 예: 보안 측정

| 지표명                        | 기준           |
| ----------------------------- | -------------- |
| OWASP Top 10 취약점 발견 여부 | 없음           |
| 사용자 권한 오용              | 0건            |
| 로그인 실패 시도 감지율       | 100% 탐지 기록 |

## ✅ 5. 실무 품질 기준서 작성 예시

| 항목                         | 기준                              |
| ---------------------------- | --------------------------------- |
| **기능 요구 충족률**         | 100%                              |
| **평균 응답 시간**           | ≤ 300ms                           |
| **시스템 가용성**            | 99.9% 이상 (MTTR 기준 1시간 이하) |
| **UI 에러 발생률**           | ≤ 5%                              |
| **버그 수정 평균 소요 시간** | ≤ 24시간                          |

## ✅ 6. 품질 기준 수립 절차

```
1. 품질 특성 정의 (25010 기반 등)
2. 측정 지표 정의 (수치, 기준치)
3. 측정 도구 선정 (JMeter, SonarQube, 사용자 설문 등)
4. 기준선 설정 (합격 기준값)
5. 정기 측정 및 분석
```

## 🧠 실무 팁 요약

| 상황             | 팁                                             |
| ---------------- | ---------------------------------------------- |
| QA 부서 관리     | 테스트 기준서 + 품질 체크리스트 작성           |
| 자동화 도구 활용 | 성능: JMeter / 보안: Zap / 정적분석: SonarQube |
| 품질 목표 수립   | ISO/IEC 25010 기준으로 정량 목표 설정          |
| 개발과 품질 통합 | CI/CD 파이프라인에 품질 측정 포함              |

# 결함 추적 및 리포팅

## ✅ 1. 결함 추적(Defect/Bug Tracking)이란?

> 개발 중 발견된 **오류, 예외, 비정상 동작(=결함)**을
>  **기록하고 상태를 추적하며 해결될 때까지 관리하는 활동**

> 핵심 목표:
>  "언제 어떤 문제가 생겼고, 지금 해결됐는지 추적 가능해야 한다."

## ✅ 2. 결함 추적 기본 흐름

```
[발견] → [기록] → [할당] → [수정] → [검증] → [종료/보류]
```

| 단계         | 설명                                          |
| ------------ | --------------------------------------------- |
| 발견         | 테스터, 사용자, 자동화 테스트가 결함 발견     |
| 기록         | 결함 리포트 작성 (화면, 증상, 재현조건 포함)  |
| 할당         | 개발자에게 담당 지정                          |
| 수정         | 개발자가 코드 수정 및 커밋                    |
| 검증         | 테스터가 재테스트 수행                        |
| 종료 or 보류 | 수정 확인 시 닫음, 아니면 재오픈 or 보류 처리 |

## ✅ 3. 결함 리포트(Defect Report) 구성 예시

| 항목                | 설명                                                  |
| ------------------- | ----------------------------------------------------- |
| 제목 (Title)        | 요약: "[회원가입] 생년월일 입력 시 오류 발생"         |
| 발견 버전           | 테스트 중인 소프트웨어 버전                           |
| 발생 환경           | OS, 브라우저, 디바이스 등                             |
| 발생 단계           | 재현 절차: 어떤 순서로 발생했는지 상세히 기술         |
| 기대 결과           | 정상적으로 동작했어야 할 내용                         |
| 실제 결과           | 발생한 문제/오류 화면                                 |
| 심각도 (Severity)   | 치명적(Critical), 높음(High), 보통(Medium), 낮음(Low) |
| 우선순위 (Priority) | 즉시 수정(P1), 다음 스프린트(P2), 다음 버전(P3) 등    |
| 스크린샷/로그       | 화면 캡처, 에러 메시지, 콘솔 로그 등 첨부             |
| 상태(Status)        | New → Assigned → In Progress → Resolved → Closed 등   |
| 담당자              | 수정 책임자 (개발자)                                  |
| 작성자 / 작성일     | 리포트 작성자 정보                                    |

## ✅ 4. 실무 도구 예시

| 도구                  | 특징                                             |
| --------------------- | ------------------------------------------------ |
| **Jira**              | 애자일 기반 이슈+결함 관리 통합 (업계 최다 사용) |
| **Redmine**           | 오픈소스 이슈+Wiki 연동 시스템                   |
| **GitHub Issues**     | Git 기반 프로젝트에 적합                         |
| **TestLink**          | 테스트 케이스와 결함 연계 가능                   |
| **Bugzilla / Mantis** | 클래식 결함 관리 전용 툴                         |

### 🛠️ Jira 결함 흐름 예시

```css
To Do → In Progress → Code Review → QA Test → Done
```

→ 모든 단계가 추적 가능하게 설정하고 자동 알림 설정

## ✅ 5. 실무 적용 팁

| 상황               | 전략                                              |
| ------------------ | ------------------------------------------------- |
| 우선순위 많은 경우 | "Severity × Priority" 기반 정렬                   |
| 반복되는 이슈      | 카테고리/레이블로 분류 + 템플릿화                 |
| 커뮤니케이션 병목  | Slack/Jira 연동, 메일 자동화                      |
| 보고 누락 방지     | 자동화 테스트에서 발견된 오류 자동 등록 (CI 연계) |
| 통계 리포트        | 주간 버그 통계 보고서 작성 → QA 평가              |

## ✅ 6. 결함 관리 지표 예시 (QA 관리용)

| 지표           | 설명                                   |
| -------------- | -------------------------------------- |
| 결함 밀도      | 코드 1KLOC당 결함 수                   |
| 결함 발견 시기 | 요구/설계/구현/테스트 단계별 버그 비율 |
| 결함 해결률    | 전체 결함 중 해결 완료 비율            |
| 평균 해결 시간 | Bug 오픈부터 종료까지 소요 시간        |
| 재오픈율       | 해결됐다고 했지만 실제로 안 된 비율    |

## 🧠 실무 요약

| 항목        | 핵심 내용                                      |
| ----------- | ---------------------------------------------- |
| 목적        | 결함 상태의 전과정을 기록/추적                 |
| 리포트 작성 | 재현 가능하게, 객관적 증거 포함                |
| 도구 활용   | Jira + Git 연동 or Redmine + 이메일 연계       |
| 전략        | 자동화 + 정기 통계 + 우선순위 기반 조정        |
| 성공 조건   | "결함이 닫히기 전까지 추적 가능해야 함"이 핵심 |

# 5-3. 소프트웨어 개발 방법론

# 폭포수, 프로토타입, 나선형, 애자일(Scrum, XP)

## ✅ 1. 폭포수 모델 (Waterfall Model)

> **가장 고전적인 순차적 개발 방식**.
>  위에서 아래로 물이 흐르듯 각 단계를 **완료 후 다음 단계로 이동**함.

### ● 개발 절차

```
요구사항 → 설계 → 구현 → 테스트 → 배포 → 유지보수
```

### ● 특징

| 항목               | 내용                                |
| ------------------ | ----------------------------------- |
| 계획 기반          | 문서화 중시, 계획 수립 필수         |
| 변화 대응력 ↓      | 한 번 지나간 단계는 되돌리기 어려움 |
| 명확한 요구에 적합 | 요구사항이 고정되어 있는 경우 적합  |

### ● 장점

- 문서가 명확하여 **이해관계자 간 의사소통 용이**
- 진행 관리가 **단계별로 명확**

### ● 단점

- **요구사항 변경에 매우 취약**
- 테스트가 **너무 뒤에서만 이루어짐**
- 결과물 확인이 **늦음**

## ✅ 2. 프로토타입 모델 (Prototype Model)

> **최종 제품 전, 사용자와 함께 UI나 기능을 시제품 형태로 구현**
>  반복 피드백을 통해 요구사항을 점진적으로 확정

### ● 개발 절차

```
요구 파악 → 프로토타입 개발 → 사용자 평가 → 개선 → 실제 개발

```

### ● 특징

- 고객이 **초기부터 직접 시연/피드백 가능**
- 실제 시스템의 일부 기능만 선 구현

### ● 장점

- **요구사항 명확화**에 매우 효과적
- 사용자 만족도 ↑

### ● 단점

- **프로토타입이 최종 제품과 다를 수 있음**
- 과도한 기대 → 개발 범위 오해 가능성 있음

## ✅ 3. 나선형 모델 (Spiral Model)

> **폭포수 + 프로토타입 + 위험 분석을 결합**한 **위험 주도적 반복 모델**

### ● 개발 절차 (나선을 따라 반복)

```
1. 목표 설정 → 2. 위험 분석 → 3. 개발 및 검증 → 4. 계획 수립  
→ 위 과정을 반복하며 점진적 개발

```

### ● 특징

- **점진적 반복(Iteration)** + **위험 분석 강조**
- 대형 프로젝트, 고위험 시스템에 적합

### ● 장점

- 위험 요소를 **초기에 관리 가능**
- 요구사항 변경에 유연

### ● 단점

- 복잡하고, 비용/시간 ↑
- **경험 많은 관리자 필요**

## ✅ 4. 애자일 방법론 (Agile)

> 고객의 변화에 유연하게 대응하는 **반복적·점진적 개발 방식**
>  **문서보다 작동하는 소프트웨어**, **계획보다 변화 수용**을 중시함

### ● 대표 프레임워크 ①: **Scrum**

| 역할          | 설명                   |
| ------------- | ---------------------- |
| Product Owner | 요구사항 우선순위 결정 |
| Scrum Master  | 프로세스 가이드        |
| 개발팀        | 실제 구현 담당         |

### ● Scrum 절차

```
Product Backlog → Sprint Planning → Sprint(2~4주)  
→ Daily Scrum → Sprint Review → Retrospective

```

### ● 대표 프레임워크 ②: **XP (eXtreme Programming)**

| 실천 기술              | 설명                     |
| ---------------------- | ------------------------ |
| Pair Programming       | 두 명이 짝을 이루어 코딩 |
| TDD (테스트 주도 개발) | 테스트를 먼저 작성       |
| CI (지속적 통합)       | 코드를 자주 통합/빌드    |
| Refactoring            | 지속적인 코드 개선       |

###  애자일 장점

- 빠른 피드백, 고객 참여 ↑
- 변화에 **유연하게 대응 가능**
- 개발자 간 **커뮤니케이션 강화**

### ● 애자일 단점

- **초기 문서화 부족 → 유지보수 시 어려움**
- 명확한 스펙이 없는 경우 관리자 부담 ↑

## ✅ 네 가지 모델 비교표

| 구분           | 폭포수         | 프로토타입                 | 나선형                | 애자일(Scrum/XP)          |
| -------------- | -------------- | -------------------------- | --------------------- | ------------------------- |
| 개발 방식      | 순차적         | 반복적                     | 반복 + 위험 중심      | 반복 + 고객 중심          |
| 요구 변경 대응 | ❌ 낮음         | ✅ 유연                     | ✅ 유연                | ✅ 매우 유연               |
| 문서화         | 매우 중요      | 보통                       | 중요                  | 최소화                    |
| 고객 참여      | 낮음           | 높음                       | 중간                  | 매우 높음                 |
| 추천 대상      | 정부/계약 기반 | UI중심, 사용자 피드백 필요 | 대규모, 복잡 프로젝트 | 스타트업, 웹서비스        |
| 리스크 분석    | 없음           | 미약                       | 강함                  | 없음 (신속 피드백이 대체) |

## 🧠 실무 팁 요약

| 상황                                | 추천 모델              |
| ----------------------------------- | ---------------------- |
| 명확하고 고정된 요구사항            | **폭포수**             |
| 요구가 불명확하거나 UI 비중이 클 때 | **프로토타입**         |
| 안전성/위험이 중요한 대규모 시스템  | **나선형**             |
| 빠르게 릴리즈하고 계속 개선         | **애자일 (Scrum, XP)** |

# DevOps 개념

## ✅ DevOps란?

> **Dev**elopment(개발) + **Op**erations(운영)의 합성어로,
>  개발팀과 운영팀 간의 **협업과 자동화를 통해 소프트웨어를 빠르고 안정적으로 제공**하기 위한 문화이자 방법론

## ✅ 1. DevOps의 목적

| 목표                | 설명                                      |
| ------------------- | ----------------------------------------- |
| 배포 속도 향상      | 코드가 빠르게 운영에 적용되도록           |
| 품질 및 안정성 확보 | 자동화된 테스트, 모니터링으로 오류 최소화 |
| 개발-운영 협업 강화 | 사일로(Silo) 제거, 공통 목표 중심 협력    |
| 고객 피드백 반영    | 작은 단위로 빠르게 배포해 빠른 개선 가능  |

## ✅ 2. DevOps 핵심 원칙

| 원칙                   | 설명                                            |
| ---------------------- | ----------------------------------------------- |
| **자동화**             | 빌드, 테스트, 배포, 모니터링까지 전 과정 자동화 |
| **지속적 통합(CI)**    | 개발 중 코드를 자주 병합하고 테스트             |
| **지속적 배포(CD)**    | 테스트 통과 시 자동으로 운영환경에 배포         |
| **모니터링 및 피드백** | 운영 상태를 실시간으로 수집하여 개선 반영       |
| **협업 문화**          | Dev-Ops, QA, 보안 간 경계 제거 → 통합 팀 문화   |

## ✅ 3. DevOps 툴체인(자동화 도구 흐름)

```
[코딩] → [빌드] → [테스트] → [배포] → [모니터링]
```

| 단계            | 대표 도구                                    |
| --------------- | -------------------------------------------- |
| **소스 관리**   | Git, GitHub, GitLab                          |
| **CI/CD**       | Jenkins, GitHub Actions, GitLab CI, CircleCI |
| **테스트**      | JUnit, Selenium, PyTest                      |
| **컨테이너**    | Docker, Kubernetes                           |
| **배포 자동화** | Ansible, Terraform                           |
| **모니터링**    | Prometheus, Grafana, ELK, New Relic          |

## ✅ 4. DevOps 흐름 요약

1. **개발자가 Git에 코드 커밋**
2. **CI 툴이 자동으로 빌드 + 테스트**
3. 테스트 통과 시 **배포 자동화(CD)**가 실행됨
4. 운영 상태는 **모니터링 시스템이 수집**
5. **피드백은 Slack, Jira 등으로 개발자에게 전달**

## ✅ 5. DevOps와 전통 방식 비교

| 항목         | 전통 방식         | DevOps 방식                         |
| ------------ | ----------------- | ----------------------------------- |
| 배포 주기    | 수주 ~ 수개월     | 수일 ~ 수시간                       |
| 부서 간 협업 | 개발-운영 분리    | 통합된 팀워크                       |
| 오류 대응    | 수동 디버깅       | 자동화 테스트 + 롤백                |
| 릴리즈 방식  | 야간 배포, 대규모 | 무중단, 점진적 (Canary, Blue/Green) |
| 품질 확보    | QA 부서 중심      | 개발자가 직접 품질 책임             |

## ✅ 6. DevOps 실무 적용 예시

| 업무              | DevOps 접근                    |
| ----------------- | ------------------------------ |
| 코드 관리         | Git + PR 리뷰 + 브랜치 전략    |
| 테스트 자동화     | 커밋 시 단위 테스트 자동 실행  |
| Docker 컨테이너화 | 동일한 실행 환경 확보          |
| Kubernetes 배포   | 확장성 + 무중단 배포           |
| 로그 분석         | ELK Stack으로 에러 실시간 감지 |

## 🧠 실무 팁 요약

| 상황             | 전략                                          |
| ---------------- | --------------------------------------------- |
| 팀 간 협업 부족  | 공통 KPI 설정 (배포 성공률, 배포 속도)        |
| 배포 잦은 오류   | 테스트 자동화부터 시작                        |
| 배포 속도 개선   | CI/CD → 컨테이너화 → 무중단 배포 순           |
| 문화 정착 어려움 | DevOps = 도구가 아니라 **문화**임을 인식할 것 |

## ✅ DevOps 핵심 키워드 요약

```
지속적 통합(CI)  
지속적 배포(CD)  
자동화(AUTOMATION)  
모니터링(MONITORING)  
협업(COLLABORATION)  
문화(CULTURE)
```

# 요구사항 추적성

## ✅ 1. 요구사항 추적성이란?

> **요구사항이 개발 생명주기 전체에서 어떻게 반영되고 검증되었는지를 추적할 수 있는 능력**
>  즉, *“이 요구사항은 어떤 설계/코드/테스트 항목과 연결되어 있는가?”* 를 **양방향으로 파악**하는 것

## ✅ 2. 요구사항 추적성의 목적

| 목적                 | 설명                                                  |
| -------------------- | ----------------------------------------------------- |
| ✅ 요구사항 이행 확인 | 요구가 실제로 구현·검증되었는지 확인 가능             |
| ✅ 변경 영향 분석     | 특정 요구가 바뀌면 **어디에 영향이 있는지 분석 가능** |
| ✅ 결함 역추적        | 테스트 실패 → 어떤 요구사항에서 시작된 문제인지 파악  |
| ✅ 프로젝트 품질 보증 | 감사 대응, 인증 심사 등에서 객관적 증빙 가능          |

## ✅ 3. 추적성 유형 (3가지)

| 유형                              | 설명                                   | 예시                            |
| --------------------------------- | -------------------------------------- | ------------------------------- |
| **전방 추적성 (Forward)**         | 요구사항 → 설계 → 구현 → 테스트        | 기능 A → 클래스 A.java → TC_001 |
| **후방 추적성 (Backward)**        | 테스트/코드 → 요구사항으로 거슬러 추적 | 결함 발견 → 어떤 요구사항 누락? |
| **양방향 추적성 (Bidirectional)** | 요구 ↔ 구현 ↔ 테스트 상호 추적 가능    | 가장 이상적인 상태              |

## ✅ 4. 요구사항 추적 매트릭스 (RTM: Requirements Traceability Matrix)

> 요구사항 ID별로 관련된 설계 문서, 코드 모듈, 테스트케이스 등을 **표 형태로 연결**하는 문서

### ● RTM 예시

| 요구사항 ID | 설명                 | 설계 문서 | 구현 모듈      | 테스트 케이스 |
| ----------- | -------------------- | --------- | -------------- | ------------- |
| REQ-001     | 사용자 로그인 기능   | SDD-Login | login.py       | TC_Login_001  |
| REQ-002     | 비밀번호 재설정 기능 | SDD-Reset | reset_pwd.java | TC_Reset_002  |

→ 이걸 통해 어떤 요구가 빠졌는지, 어떤 테스트가 누락됐는지 쉽게 알 수 있음

## ✅ 5. 실무 적용 예시

### 💡 사용 시나리오

| 상황                   | 적용 방식                                                    |
| ---------------------- | ------------------------------------------------------------ |
| **변경 요청 발생**     | 어떤 요구사항과 관련된 코드/테스트를 찾아 빠르게 수정 범위 파악 |
| **감사/심사 대응**     | ISO 9001, CMMI, 인증 심사 시 요구-테스트 대응 증빙           |
| **결함 발생 시**       | 테스트 실패 → 어떤 요구사항/설계에 문제 있는지 추적          |
| **요구사항 누락 검토** | RTM 통해 “구현되지 않은 요구” 확인 가능                      |

## ✅ 6. 요구사항 추적 도구

| 도구                   | 특징                                            |
| ---------------------- | ----------------------------------------------- |
| **Jira**               | 요구, 개발, 테스트 간 링크 설정 가능            |
| **IBM DOORS**          | 산업용 대형 시스템 추적성 관리에 특화           |
| **ReqView**            | 요구-설계-테스트 연결 RTM 생성                  |
| **Trello + Checklist** | 소규모 팀도 가볍게 구현 가능                    |
| **Excel**              | 수동 작성 RTM 관리 가능 (단, 대규모에는 비효율) |

## 🧠 실무 팁 요약

| 팁             | 설명                                                      |
| -------------- | --------------------------------------------------------- |
| 요구 ID 명확히 | 모든 요구는 식별 가능한 ID를 부여할 것 (ex. REQ-001)      |
| 추적 단위 정의 | 기능, 비기능, 인터페이스 요구 등 모두 추적 대상화         |
| 자동화 연계    | Git 커밋, 테스트 리포트에 요구 ID 연결하면 자동 추적 가능 |
| 검토 주기화    | 프로젝트 중간에 RTM 누락/불일치 점검 회의 운영 추천       |

## ✅ 요구사항 추적성 = 품질의 연결고리

> “요구가 **빠짐 없이 구현되고 테스트되었는가?”를 보장하는 핵심 기준”

# 5-4. 운영체제와 네트워크

# OS 구조, 메모리/프로세스 관리

## ✅ 1. OS(Operating System)의 구조

> OS는 **사용자와 하드웨어 사이의 중개자**이자,
>  **프로세스, 메모리, 입출력, 파일 시스템 등을 관리**하는 핵심 시스템 소프트웨어야.

### ● OS 구성 계층 (일반 구조)

```
┌──────────────┐
│ 사용자(User) │
├──────────────┤
│ 응용 프로그램 │
├──────────────┤
│ 시스템 콜 API │ ← 인터페이스 (glibc 등)
├──────────────┤
│ 커널(Kernel)  │ ← OS의 핵심
│ ├ 스케줄러     │
│ ├ 메모리 관리  │
│ ├ 파일 시스템  │
│ ├ 입출력 관리  │
│ └ 네트워크 스택 │
├──────────────┤
│ 하드웨어       │
└──────────────┘
```

## ✅ 2. 메모리 관리 (Memory Management)

> **프로세스에 메모리 공간을 효율적으로 할당/회수**하고
>  **보호 및 가상화**를 통해 안정적 실행을 보장하는 기능

### ● 주요 개념

| 개념                             | 설명                                                      |
| -------------------------------- | --------------------------------------------------------- |
| **가상 메모리(Virtual Memory)**  | 실제 물리 메모리보다 큰 주소 공간 사용 가능 (페이징 기반) |
| **페이징(Paging)**               | 메모리를 **동일한 크기 블록(페이지)**로 나눠 관리         |
| **세그멘테이션(Segmentation)**   | 논리적 단위(함수, 변수 등)로 메모리 관리                  |
| **MMU (Memory Management Unit)** | 가상주소 ↔ 물리주소 변환하는 하드웨어                     |
| **스와핑(Swapping)**             | 메모리가 부족하면 일부 프로세스를 디스크로 이동           |

### ● 메모리 할당 방식

| 방식      | 설명                                 |
| --------- | ------------------------------------ |
| 고정 분할 | 메모리를 정해진 크기로 나눔          |
| 가변 분할 | 필요에 따라 가변 크기 블록 할당      |
| 페이징    | 내부 단편화는 있음, 외부 단편화 해결 |
| 세그멘트  | 사용자가 논리 단위로 접근, 가독성 ↑  |

### ● 페이지 테이블과 TLB

- **페이지 테이블**: 가상주소 → 물리주소 매핑 테이블
- **TLB** (Translation Lookaside Buffer): 주소 변환 캐시 (속도 ↑)

## ✅ 3. 프로세스 관리 (Process Management)

> 프로세스란 **실행 중인 프로그램의 인스턴스**
>  OS는 **수많은 프로세스를 생성, 실행, 종료하며 자원(메모리, CPU 등)을 관리**함

### ● 프로세스 상태

```mathematica
New → Ready → Running → Waiting → Terminated
             ↑       ↓
          (Interrupt)(I/O Complete)
```

### ● 주요 개념

| 용어                          | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| **PCB**                       | 프로세스 제어 블록: PID, 상태, 레지스터 등 관리              |
| **스케줄링**                  | 어떤 프로세스를 언제 CPU에 올릴지 결정                       |
| **문맥 교환(Context Switch)** | CPU가 다른 프로세스를 실행하기 위해 상태 저장/복원           |
| **멀티태스킹**                | 여러 프로세스를 번갈아 빠르게 실행 (실제는 싱글코어라도 가능) |
| **쓰레드(Thread)**            | 프로세스 내 실행 단위 (메모리 공유)                          |

### ● CPU 스케줄링 알고리즘

| 알고리즘                      | 특징                               |
| ----------------------------- | ---------------------------------- |
| FCFS (First Come First Serve) | 가장 먼저 도착한 순서로 처리       |
| SJF (Shortest Job First)      | 실행 시간이 가장 짧은 것 우선      |
| RR (Round Robin)              | 시간 할당량(TQ)으로 프로세스 순환  |
| Priority                      | 우선순위가 높은 프로세스 우선 처리 |

## ✅ 4. 프로세스 vs 쓰레드

| 구분      | 프로세스                            | 쓰레드                                    |
| --------- | ----------------------------------- | ----------------------------------------- |
| 메모리    | 독립된 메모리 공간 사용             | 동일한 공간 공유 (heap 등)                |
| 생성 비용 | 큼                                  | 작음                                      |
| 오류 전파 | 하나 죽어도 다른 프로세스 영향 없음 | 하나 죽으면 전체 위험                     |
| 병렬성    | 프로세스 간 병렬성                  | 쓰레드 간 병렬성 가능 (멀티코어에서 유리) |

## ✅ 실무 예시

| 사례                       | 적용된 OS 기능                                  |
| -------------------------- | ----------------------------------------------- |
| 프로그램 동시에 실행       | 프로세스 관리 + 스케줄링                        |
| 멀티탭 브라우저            | 멀티프로세스 or 멀티스레딩                      |
| Android 앱 백그라운드 실행 | 쓰레드, 서비스 관리                             |
| Docker, 가상화             | 격리된 프로세스 공간 + 네임스페이스(Cgroups 등) |
| 페이지 오류 후 느려짐      | 스와핑/페이징 이슈 → 디스크 I/O 증가            |

## 🧠 실무 요약

| 항목        | 핵심                                     |
| ----------- | ---------------------------------------- |
| 가상 메모리 | 제한된 물리 RAM을 확장시켜주는 핵심 기술 |
| 프로세스    | 실행 단위, 상태 및 자원 독립             |
| 쓰레드      | 경량 실행 단위, 메모리 공유              |
| 스케줄링    | 응답 속도, 처리량, 공정성 조율           |
| 문맥 교환   | 시스템 성능에 직접적 영향 있음           |

# IP, TCP, HTTP, DNS

## ✅ 1. IP (Internet Protocol) – **주소 지정 + 패킷 전달**

> 인터넷에서 **장치 간 통신을 위한 주소 체계와 패킷 라우팅 규칙**

### ● 핵심 기능

| 항목      | 설명                                                 |
| --------- | ---------------------------------------------------- |
| 주소 지정 | IP 주소로 목적지 컴퓨터를 식별 (ex. 192.168.0.1)     |
| 라우팅    | 패킷을 여러 네트워크를 거쳐 **최종 목적지까지 전달** |
| 비연결형  | 연결 상태 없이 독립적으로 패킷 전송                  |

### ● IP 주소 구조

- IPv4: 32비트 (예: `192.168.1.1`)
- IPv6: 128비트 (예: `2001:0db8::1`)
- 공인 IP ↔ 사설 IP 구분 존재

## ✅ 2. TCP (Transmission Control Protocol) – **신뢰성 있는 데이터 전송**

> IP의 비신뢰적인 통신 위에서 **데이터를 순서대로, 완전하게 전달**하는 프로토콜

### ● 특징

| 항목        | 설명                                     |
| ----------- | ---------------------------------------- |
| 연결지향형  | 통신 전에 3-way handshake로 연결 설정    |
| 흐름 제어   | 수신자 처리 속도에 맞춰 전송량 조절      |
| 오류 제어   | 손실 시 재전송, 패킷 순서 재정렬         |
| 신뢰성 보장 | 수신 확인(ACK), 패킷 분할 및 재조립 지원 |

### ● TCP 연결 절차 (3-way handshake)

```
[Client] → SYN → [Server]  
[Client] ← SYN + ACK ← [Server]  
[Client] → ACK → [Server]  
→ 연결 완료
```

## ✅ 3. HTTP (HyperText Transfer Protocol) – **웹 통신 프로토콜**

> **웹 브라우저와 서버 간 문서, 이미지, API 요청/응답을 위한 애플리케이션 계층 프로토콜**

### ● 특징

| 항목        | 설명                                              |
| ----------- | ------------------------------------------------- |
| 비연결성    | 요청-응답 이후 연결 끊음 (단, HTTP/2는 유지 가능) |
| 무상태성    | 이전 요청과 독립 (쿠키/세션으로 상태 유지 가능)   |
| 메서드 기반 | GET, POST, PUT, DELETE 등 동작 명시               |
| 구조        | 요청(Request) → 응답(Response) 형식               |

### ● HTTP 요청 예시

```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Chrome

```

### ● HTTP 응답 예시

```http
HTTP/1.1 200 OK
Content-Type: text/html

<html>...</html>

```

## ✅ 4. DNS (Domain Name System) – **도메인 → IP 변환**

> 사람이 기억하기 쉬운 **도메인 이름을 실제 IP 주소로 변환**해주는 시스템
>  전화번호부 역할

### ● 흐름 예시

```
브라우저 → www.naver.com 입력
→ DNS 요청 → 223.130.200.104 반환 → HTTP 연결 시도
```

### ● DNS 계층 구조

| 계층                | 예시                           |
| ------------------- | ------------------------------ |
| 루트 도메인         | . (점)                         |
| 최상위 도메인 (TLD) | .com, .kr                      |
| 2차 도메인          | naver                          |
| 서브도메인          | mail.naver.com, blog.naver.com |

### ● DNS 작동 흐름

```
1. 브라우저 캐시 확인  
2. OS/라우터 캐시 확인  
3. 로컬 DNS 서버 질의  
4. 상위 DNS로 재귀적 질의  
5. IP 주소 반환
```

## ✅ 프로토콜 계층별 정리

| 계층 (TCP/IP) | 프로토콜      | 설명                    |
| ------------- | ------------- | ----------------------- |
| 애플리케이션  | **HTTP, DNS** | 웹, 도메인 처리         |
| 전송 계층     | **TCP**       | 신뢰성 있는 데이터 전송 |
| 인터넷 계층   | **IP**        | 주소 지정, 패킷 전달    |
| 링크 계층     | Ethernet 등   | 실제 물리 전송          |

## ✅ 실무 예시 흐름 정리

```
1. 사용자가 www.google.com 입력
2. DNS → IP 주소 조회 (ex. 142.250.206.4)
3. TCP 연결 (3-way handshake)
4. HTTP GET / 요청
5. 서버에서 HTML 응답
6. 브라우저에 웹페이지 렌더링
```

## 🧠 실무 팁 요약

| 항목 | 핵심 정리                                                    |
| ---- | ------------------------------------------------------------ |
| IP   | 인터넷 주소, 패킷 전달 (비연결)                              |
| TCP  | 신뢰성 있는 통신 (연결지향, 순서보장)                        |
| HTTP | 웹 문서/데이터 전송 방식                                     |
| DNS  | 도메인 → IP 매핑 (브라우저가 가장 먼저 수행하는 작업 중 하나) |

# 클라이언트-서버 모델

## ✅ 1. 클라이언트-서버 모델이란?

> **서비스를 요청하는 클라이언트(Client)**와
>  **요청을 받아 처리하는 서버(Server)**로 역할을 분리하여
>  네트워크 통신을 수행하는 **분산 시스템 아키텍처**

## ✅ 1. 클라이언트-서버 모델이란?

> **서비스를 요청하는 클라이언트(Client)**와
>  **요청을 받아 처리하는 서버(Server)**로 역할을 분리하여
>  네트워크 통신을 수행하는 **분산 시스템 아키텍처**

### ● 예시 구조

```
[사용자] → 웹 브라우저 (Client)
             ↓
      HTTP 요청 (GET /index.html)
             ↓
         웹 서버 (Server)
             ↓
      HTML 응답 → 웹 브라우저 렌더링
```

## ✅ 3. 통신 흐름 (기본 HTTP 기반)

```
1. 클라이언트: 요청(Request) 전송 (ex. HTTP GET)
2. 서버: 요청 수신 후 처리
3. 서버: 응답(Response) 전송 (ex. HTML, JSON)
4. 클라이언트: 결과 수신 후 표시
```

## ✅ 4. 특징

| 항목      | 설명                                              |
| --------- | ------------------------------------------------- |
| 역할 분리 | Client는 요청, Server는 처리                      |
| 중앙 집중 | Server에 데이터/기능 집중 (보안, 관리 유리)       |
| 비대칭성  | Client 수많이 분산, Server는 집중                 |
| 확장성    | 서버를 수평 확장(로드밸런서)하여 대규모 처리 가능 |

## ✅ 5. 실습 예시 (Python 기반 TCP 통신)

### ● 서버 코드

```python
import socket

server = socket.socket()
server.bind(('localhost', 9999))
server.listen(1)
print("서버 대기 중...")

conn, addr = server.accept()
data = conn.recv(1024).decode()
print("클라이언트:", data)

conn.send("서버 응답 완료".encode())
conn.close()
```

### ● 클라이언트 코드

```python
import socket

client = socket.socket()
client.connect(('localhost', 9999))
client.send("안녕하세요 서버님".encode())

response = client.recv(1024).decode()
print("서버 응답:", response)
client.close()
```

## ✅ 6. 클라이언트-서버 vs P2P 모델 비교

| 항목        | 클라이언트-서버        | P2P (Peer to Peer)  |
| ----------- | ---------------------- | ------------------- |
| 구조        | 중앙 서버 존재         | 중앙 서버 없음      |
| 데이터 저장 | 서버에 집중            | 각 노드에 분산      |
| 예시        | 웹 서비스, 은행 시스템 | 토렌트, 블록체인    |
| 장점        | 보안, 관리 용이        | 확장성, 중복성 우수 |
| 단점        | 서버 장애 시 전체 영향 | 보안/관리 어려움    |

## ✅ 실무 활용 예

| 시스템    | 클라이언트       | 서버                        |
| --------- | ---------------- | --------------------------- |
| 웹 서비스 | 브라우저         | 웹 서버 (Apache, Nginx)     |
| 모바일 앱 | 앱 화면          | 백엔드 서버 (Flask, Spring) |
| 게임      | 플레이어 단말기  | 게임 서버                   |
| API 통신  | React/Vue 프론트 | Node/Django API 서버        |

## 🧠 요약

| 키워드     | 설명                                      |
| ---------- | ----------------------------------------- |
| 클라이언트 | 요청을 보내는 쪽                          |
| 서버       | 요청을 처리하고 응답                      |
| 요청/응답  | 네트워크 기반 통신 핵심                   |
| 상태 관리  | 쿠키, 세션, 토큰으로 클라이언트 상태 유지 |
| 확장 전략  | 로드밸런싱, 클러스터링, CDN 등 사용       |

# A. 알고리즘 코딩

# 문제 해결 패턴 (완전탐색, DFS/BFS, 그리디)

## ✅ 1. 완전탐색 (Brute Force)

> 가능한 모든 경우를 **무식하게 하나하나 전부 시도**해 정답을 찾는 방식
>  단순하지만 **정확하고 구현이 쉬움**, 작은 입력(n ≤ 10⁴ 이하)일 때 강력

### ● 핵심 아이디어

- 모든 조합/순열/경우의 수를 생성해
   조건에 맞는 경우를 필터링 → 정답 도출

### ● 예시: 1~9 숫자 중 3개 합이 15인 경우 찾기

```python
from itertools import combinations

for comb in combinations(range(1, 10), 3):
    if sum(comb) == 15:
        print(comb)

```

### ● 실전 적용

| 패턴        | 예시 문제                |
| ----------- | ------------------------ |
| 순열 생성   | 암호 조합 문제           |
| 조합 필터링 | 특정 합/조건 만족 경우   |
| 자리수 탐색 | 비밀번호, 시계 숫자 문제 |

## ✅ 2. DFS / BFS (그래프 탐색)

> **트리/그래프 구조**에서 노드(상태)를 방문하는 전략
>  **DFS(깊이우선)**: 한쪽 끝까지 깊게
>  **BFS(너비우선)**: 가까운 곳부터 넓게

### ● DFS (스택 or 재귀)

```python
def dfs(graph, v, visited):
    visited[v] = True
    for nv in graph[v]:
        if not visited[nv]:
            dfs(graph, nv, visited)
```

### ● BFS (큐)

```python
from collections import deque

def bfs(graph, start):
    visited = [False] * len(graph)
    queue = deque([start])
    visited[start] = True
    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if not visited[nv]:
                queue.append(nv)
                visited[nv] = True
```

### ● 실전 비교

| 구분      | DFS                 | BFS                 |
| --------- | ------------------- | ------------------- |
| 사용 도구 | 스택, 재귀          | 큐                  |
| 경로 탐색 | 가능한 경로 다 탐색 | 최단 거리 우선      |
| 메모리    | 상대적 적음         | 상대적 큼           |
| 응용      | 백트래킹, 미로 탐색 | 최단거리, 레벨 탐색 |

## ✅ 3. 그리디 (Greedy)

> 매 순간 **가장 좋아 보이는 선택**을 해서 최종 답을 만드는 전략
>  **국소 최적 선택 → 전체 최적 보장**되는 문제에만 사용 가능

### ● 핵심 조건

- **Greedy Choice Property**
   현재 순간의 최적이 전체 최적과 같아야 함
- **Optimal Substructure**
   문제를 부분 문제로 나눠도 성질이 유지돼야 함

### ● 예시: 동전 거스름돈 최소 개수

```python
coins = [500, 100, 50, 10]
target = 1260
count = 0

for coin in coins:
    count += target // coin
    target %= coin

print(count)
```

### ● 실전 문제 유형

| 유형           | 설명               | 예시                           |
| -------------- | ------------------ | ------------------------------ |
| 정렬 기반 선택 | 큰 수부터 선택     | 동전, 회의실 예약              |
| 우선순위 기반  | 작은 작업부터 처리 | 작업 스케줄링                  |
| 탐욕적 경로    | 앞부터 조건 만족   | 문자열 압축, 압축 비율 문제 등 |

## ✅ 문제 해결 패턴 요약 비교

| 항목      | 완전탐색       | DFS/BFS               | 그리디                     |
| --------- | -------------- | --------------------- | -------------------------- |
| 방식      | 모든 경우 확인 | 경로/구조 탐색        | 순간 최적 선택             |
| 성능      | 느림 (O(n!))   | 조건에 따라 다양      | 빠름 (O(n log n) 등)       |
| 정확도    | 항상 정답      | 항상 정답             | 최적이 아닐 수도 있음      |
| 사용 조건 | 작은 데이터    | 트리/그래프, 상태공간 | 선택이 전체 최적과 같을 때 |

## 🧠 실무 팁

| 상황                  | 전략                               |
| --------------------- | ---------------------------------- |
| 조건문 없는 단순 경우 | 완전탐색으로 시작 (→ 이후 최적화)  |
| 경로/상태 변화 문제   | DFS/BFS (ex. 미로, 섬의 개수)      |
| 최소/최대 선택 문제   | 정렬 후 그리디 시도                |
| 잘 안 풀릴 때         | “완전탐색으로 가능한가?”부터 체크! |

# 문자열 처리, 수학, 시뮬레이션

## ✅ 1. 문자열 처리 (String Manipulation)

> 문자열에서 **문자 단위 처리, 비교, 분할, 패턴 검색** 등 수행
>  자주 등장하지만 사소한 실수로 틀리기 쉬운 분야

### ● 핵심 개념

| 기능             | Python 예시                     |
| ---------------- | ------------------------------- |
| 길이 구하기      | `len(s)`                        |
| 슬라이싱         | `s[1:4]`                        |
| 문자열 뒤집기    | `s[::-1]`                       |
| 부분 문자열 포함 | `'abc' in s`                    |
| 대소문자 변환    | `s.lower()`, `s.upper()`        |
| 문자열 정렬      | `''.join(sorted(s))`            |
| 문자 빈도수      | `Counter(s)` from `collections` |

### ● 대표 문제 예시

```python
# 팰린드롬 확인
s = input()
print("YES" if s == s[::-1] else "NO")
```

```python
# 단어별 길이 출력
for word in input().split():
    print(len(word))

```

### ● 실전 전략

- **문자 vs 문자열 구분**
- **정규표현식(re)** 필요 시 도입
- **ASCII 처리**: `ord(c)`, `chr(n)`
- **대소문자 통일 후 비교**
- **슬라이싱을 최대한 활용**

## ✅ 2. 수학 (Mathematical Logic)

> 수학 개념 없이 코딩 실력만으로는 풀기 어려운 문제들
>  **최대공약수, 소수, 약수, 조합, 나머지 연산, 수열** 등 포함

### ● 필수 공식/함수

| 기능       | Python 예시                             |
| ---------- | --------------------------------------- |
| 최대공약수 | `gcd(a, b)` from `math`                 |
| 최소공배수 | `a * b // gcd(a, b)`                    |
| 소수 판별  | `n % i == 0` 여부 반복                  |
| 조합       | `combinations(arr, r)` from `itertools` |
| 모듈 연산  | `(a + b) % m` 등                        |
| 누적합     | `prefix[i] = prefix[i-1] + arr[i]`      |

### ● 대표 문제 예시

```python
# 소수 판별
def is_prime(n):
    if n <= 1: return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0: return False
    return True

```

```python
# 유클리드 호제법
from math import gcd
a, b = map(int, input().split())
print(gcd(a, b))

```

### ● 실전 전략

- **시간복잡도 고려한 제곱근 이하 반복**
- **수열, 규칙 찾기** 문제에서는 수학적 귀납법 필요
- **문제의 조건을 등식으로 표현**해보고 단순화

## ✅ 3. 시뮬레이션 (Simulation)

> 문제의 조건을 **그대로 코드로 옮겨 시나리오대로 단계별로 구현**
>  "수학적으로 못 풀면 직접 돌려보자" 전략

### ● 핵심 접근법

| 항목  | 설명                                        |
| ----- | ------------------------------------------- |
| 1단계 | 입력 → 자료구조에 담기 (grid, 배열 등)      |
| 2단계 | 명세에 따라 순서대로 if/loop로 처리         |
| 3단계 | 상태 갱신, 방향 설정, 조건 분기 정확히 구현 |

### ● 대표 문제 유형

- 좌표 이동 (로봇, 미로, 게임판)
- 조건 시뮬레이션 (주사위 굴리기, 퍼즐 회전)
- 다단계 시간 시뮬레이션 (N초 후 결과)

### ● 대표 예시

```python
# 방향 배열 시뮬레이션
dx = [0, 1, 0, -1]  # 우하좌상
dy = [1, 0, -1, 0]
x, y = 0, 0
for d in moves:
    nx = x + dx[d]
    ny = y + dy[d]
    # 경계 체크
    if 0 <= nx < N and 0 <= ny < M:
        x, y = nx, ny

```

### ● 실전 전략

- **조건을 “그대로” 구현하기**
- 예외 처리 필수 (인덱스 범위, 나눗셈 0 등)
- 다차원 배열 초기화는 `[[0]*N for _ in range(M)]`
- 상태를 매 step마다 갱신할 것 (임시 배열, deepcopy 고려)

## ✅ 3대 패턴 비교 요약

| 항목             | 문자열 처리            | 수학                | 시뮬레이션              |
| ---------------- | ---------------------- | ------------------- | ----------------------- |
| 주로 다루는 대상 | 문자, 패턴             | 수식, 수열, 연산    | 상태 변화, 로직         |
| 핵심 스킬        | 슬라이싱, split, count | GCD, 소수, 나머지   | 조건 분기, 방향 처리    |
| 실전 팁          | 문자열 정제 후 비교    | 시간복잡도 O(√N)    | step-by-step 구현력     |
| 자주 쓰는 도구   | `str`, `Counter`, `re` | `math`, `itertools` | `copy`, `deque`, `list` |

# 파일 입출력 처리

## ✅ 1. 파일 입출력(File I/O)이란?

> **파일에 데이터를 저장하거나 불러오는 작업**
>  외부 저장소(하드디스크, SSD)에 있는 정보를
>  **메모리로 읽거나 → 메모리에서 파일로 저장**하는 과정

## ✅ 2. 파일 열기 모드 (Python 기준)

| 모드           | 의미              | 설명                              |
| -------------- | ----------------- | --------------------------------- |
| `'r'`          | 읽기              | 파일이 있어야 함                  |
| `'w'`          | 쓰기              | 파일이 없으면 생성, 있으면 덮어씀 |
| `'a'`          | 추가              | 파일 끝에 내용 추가               |
| `'rb'`, `'wb'` | 이진(binary) 모드 | 이미지, 영상 등 이진 파일 처리    |
| `'r+'`, `'w+'` | 읽기+쓰기         | 읽고 쓰기 둘 다 가능              |

## ✅ 3. 파일 읽기 (read)

```python
# 한 줄씩 읽기
with open("input.txt", "r", encoding="utf-8") as f:
    for line in f:
        print(line.strip())

# 모든 줄 읽기 (리스트로 반환)
lines = open("input.txt", "r", encoding="utf-8").readlines()

```

## ✅ 4. 파일 쓰기 (write)

```python
with open("output.txt", "w", encoding="utf-8") as f:
    f.write("Hello\n")
    f.write("World\n")

```

## ✅ 5. 파일 덧붙이기 (append)

```python
with open("output.txt", "a", encoding="utf-8") as f:
    f.write("추가된 내용\n")

```

## ✅ 6. 이진 파일 처리 (이미지, 바이너리 등)

```python
# 이미지 복사 예제
with open("img.png", "rb") as src, open("img_copy.png", "wb") as dst:
    dst.write(src.read())

```

## ✅ 7. CSV 파일 읽기/쓰기

```python
import csv

# CSV 읽기
with open("data.csv", newline="", encoding="utf-8") as f:
    reader = csv.reader(f)
    for row in reader:
        print(row)

# CSV 쓰기
with open("output.csv", "w", newline="", encoding="utf-8") as f:
    writer = csv.writer(f)
    writer.writerow(["이름", "나이"])
    writer.writerow(["홍길동", 30])

```

## ✅ 8. JSON 파일 처리

```python
import json

# 쓰기
data = {"name": "Alice", "age": 25}
with open("user.json", "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2)

# 읽기
with open("user.json", "r", encoding="utf-8") as f:
    user = json.load(f)
print(user["name"])

```

## ✅ 실무 팁 요약

| 팁                     | 설명                                                   |
| ---------------------- | ------------------------------------------------------ |
| `with open(...) as f:` | 자동으로 파일 닫힘 (`f.close()` 생략 가능)             |
| 파일 인코딩 오류       | 한글은 `encoding="utf-8"` 꼭 지정                      |
| 빈 줄 문제             | `csv`는 `newline=""` 필수                              |
| 큰 파일 처리           | `readlines()` 대신 `for line in f:` 사용 (메모리 절약) |
| 에러 처리              | `try-except`로 `FileNotFoundError` 등 처리 가능        |

## ✅ 사용 예시 요약

| 목적               | 함수/모드                      |
| ------------------ | ------------------------------ |
| 텍스트 읽기        | `open(file, 'r')`              |
| 텍스트 쓰기        | `open(file, 'w')`              |
| 이미지 복사        | `'rb'`, `'wb'`                 |
| 구조화된 파일 처리 | `csv`, `json`                  |
| 폴더 관리          | `os`, `pathlib` 모듈 함께 사용 |

# B. SQL & DB 설계

# 복잡한 SQL 쿼리 작성

## ✅ 1. 복잡한 SQL이란?

> **다중 테이블, 서브쿼리, 집계, 조건 필터링, 조인, 창 함수 등**이
>  **동시에 포함된 다단계 SQL**을 의미하며,
>  **대규모 데이터 처리, 리포트 생성, 통계 분석, 비즈니스 로직 구현**에 사용됨.

## ✅ 2. 복잡한 쿼리 핵심 구성 요소

| 요소                  | 예시                                   |
| --------------------- | -------------------------------------- |
| **JOIN**              | 여러 테이블에서 데이터 통합 조회       |
| **서브쿼리**          | 중첩된 SELECT로 조건/집계/필터링       |
| **집계 함수**         | `SUM`, `COUNT`, `AVG`, `MAX`, `MIN` 등 |
| **GROUP BY + HAVING** | 그룹별 통계 + 조건                     |
| **윈도우 함수**       | `ROW_NUMBER()`, `RANK()`, `LAG()` 등   |
| **CTE (WITH)**        | 쿼리 재사용, 가독성 향상               |

## ✅ 3. 복잡한 SQL 패턴별 예시

### 🔹 1. 다중 테이블 JOIN + 집계

```sql
SELECT c.name, COUNT(o.id) AS order_count
FROM customers c
JOIN orders o ON c.id = o.customer_id
WHERE o.created_at >= '2024-01-01'
GROUP BY c.name
HAVING COUNT(o.id) >= 3
ORDER BY order_count DESC;
```

👉 특정 기간 이후 **주문한 고객 중 3회 이상 주문한 고객**만 출력

### 🔹 2. 서브쿼리로 조건 필터링

```sql
SELECT *
FROM employees
WHERE department_id IN (
  SELECT id
  FROM departments
  WHERE name LIKE '%개발%'
);
```

👉 “**개발 부서**” 소속 직원만 필터링

### 🔹 3. 서브쿼리 vs JOIN 비교

```sql
-- 서브쿼리
SELECT name
FROM students
WHERE score = (
  SELECT MAX(score)
  FROM students
);

-- JOIN 방식
SELECT s.name
FROM students s
JOIN (
  SELECT MAX(score) AS max_score FROM students
) m ON s.score = m.max_score;
```

### 🔹 4. 윈도우 함수 (ROW_NUMBER 등)

```sql
SELECT *,
  ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank
FROM employees;
```

👉 각 부서별로 **급여 순위** 부여

### 🔹 5. CTE (WITH) + 윈도우 함수

```sql
WITH sales_ranked AS (
  SELECT *,
    RANK() OVER (PARTITION BY region ORDER BY total_sales DESC) AS rnk
  FROM sales
)
SELECT *
FROM sales_ranked
WHERE rnk <= 3;
```

👉 지역별 **매출 상위 3개 항목 추출**

### 🔹 6. 복합 조건 처리 (CASE + GROUP BY)

```sql
SELECT
  department,
  COUNT(CASE WHEN gender = 'M' THEN 1 END) AS male_count,
  COUNT(CASE WHEN gender = 'F' THEN 1 END) AS female_count
FROM employees
GROUP BY department;
```

👉 부서별 **남녀 인원 수** 분리 집계

## ✅ 4. 복잡한 SQL 작성 전략

| 전략                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| **문제 분할**          | JOIN, GROUP BY, WHERE 등 단계별로 쿼리 분해                  |
| **CTE 적극 활용**      | 복잡한 서브쿼리 → WITH절로 구조화                            |
| **뷰(View) 활용**      | 반복되는 쿼리는 뷰로 등록해서 재사용                         |
| **인덱스 활용 고려**   | WHERE / JOIN 조건 필드에 인덱스 확인                         |
| **순차적 테스트**      | 조인 → 필터 → 그룹 → 정렬 순으로 테스트                      |
| **SQL Formatter 사용** | [SQLFormat](https://sqlformat.org), DBeaver 등으로 구조 가독성 확보 |

## ✅ 5. 실무 팁 요약

| 상황            | 팁                                          |
| --------------- | ------------------------------------------- |
| 다중 조건 WHERE | `AND`, `OR`, 괄호 순서 주의                 |
| 집계 후 필터링  | `HAVING` 사용 (WHERE로 하면 안 됨)          |
| 윈도우 vs 그룹  | `GROUP BY`는 줄이지만, `OVER()`는 행 유지   |
| 성능 문제 발생  | 조인 순서, 인덱스 확인, 서브쿼리 → CTE 변경 |

# 조건 처리, JOIN, 윈도우 함수

## ✅ 1. 조건 처리 (WHERE, CASE, HAVING)

### 🔹 `WHERE`: 행(row) 필터링 (SELECT 전에 수행됨)

```sql
SELECT *
FROM employees
WHERE salary > 3000 AND department = 'Sales';
```

👉 **조건이 맞는 행만** 조회

### 🔹 `CASE`: 조건 분기 → 새로운 컬럼 만들기

```sql
SELECT name, salary,
  CASE
    WHEN salary >= 5000 THEN '고연봉'
    WHEN salary >= 3000 THEN '중간'
    ELSE '저연봉'
  END AS 등급
FROM employees;
```

👉 **조건별 결과 분류**

### 🔹 `HAVING`: 그룹 결과 조건 필터링

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department
HAVING COUNT(*) >= 5;
```

👉 **그룹 결과에 조건** 걸기 (`WHERE`로 하면 에러!)

## ✅ 2. JOIN (테이블 간 연결)

### 🔹 기본 구조

```sql
SELECT *
FROM A
JOIN B ON A.id = B.a_id
```

### 🔹 JOIN 종류 요약

| 종류              | 설명                                       | 예시             |
| ----------------- | ------------------------------------------ | ---------------- |
| `INNER JOIN`      | 양쪽 테이블에 모두 존재하는 값만           | `A JOIN B`       |
| `LEFT JOIN`       | 왼쪽 기준, 오른쪽 없으면 NULL              | `A LEFT JOIN B`  |
| `RIGHT JOIN`      | 오른쪽 기준                                | `A RIGHT JOIN B` |
| `FULL OUTER JOIN` | 양쪽 모두 포함 (DB에 따라 안 될 수도 있음) |                  |

### 🔹 JOIN 예제

```sql
SELECT e.name, d.name AS department
FROM employees e
JOIN departments d ON e.dept_id = d.id
WHERE d.name LIKE '%영업%';
```

👉 **직원과 부서를 JOIN해서 영업부만 필터링**

## ✅ 3. 윈도우 함수 (Window Functions)

> GROUP BY처럼 요약하지 않고도 **원래 행(row)을 유지하면서 통계 계산 가능**

### 🔹 주요 함수 요약

| 함수             | 설명                      |
| ---------------- | ------------------------- |
| `ROW_NUMBER()`   | 순번 (중복 없이)          |
| `RANK()`         | 순위 (동점시 순번 건너뜀) |
| `DENSE_RANK()`   | 동점 순위도 연속 부여     |
| `SUM() OVER()`   | 누적합                    |
| `LAG() / LEAD()` | 이전/다음 행 비교         |
| `AVG() OVER()`   | 누적 평균                 |

### 🔹 예제 1: 부서별 급여순 랭킹

```sql
SELECT name, department, salary,
  ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS rank
FROM employees;
```

👉 부서별 급여 1등 찾기 가능

### 🔹 예제 2: 전일 대비 매출 변화

```sql
SELECT sale_date, amount,
  amount - LAG(amount) OVER (ORDER BY sale_date) AS diff
FROM daily_sales;
```

👉 **하루 전 대비 증감액**

### 🔹 예제 3: 누적합

```sql
SELECT customer_id, order_date, amount,
  SUM(amount) OVER (PARTITION BY customer_id ORDER BY order_date) AS 누적합
FROM orders;
```

## ✅ 4. 실무 팁 요약

| 항목                     | 팁                                              |
| ------------------------ | ----------------------------------------------- |
| WHERE vs HAVING          | 집계 전 필터 → `WHERE`, 집계 후 필터 → `HAVING` |
| JOIN 시 컬럼 충돌        | 반드시 별칭 사용 (`a.name`, `b.name`)           |
| 윈도우 함수 → GROUP BY X | 집계값과 개별 행 동시 보고 싶을 때 사용         |
| 윈도우 함수 속도 최적화  | `PARTITION BY + ORDER BY`에 인덱스 활용         |

## ✅ 실전 조합 예시

> “부서별로 급여 1등만 보기 + 조건 걸기”:

```sql
WITH ranked AS (
  SELECT *, 
    ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) AS rnk
  FROM employees
)
SELECT *
FROM ranked
WHERE rnk = 1 AND salary > 5000;
```

# 트랜잭션 처리 및 오류 디버깅

## ✅ 1. 트랜잭션(Transaction)이란?

> **논리적 작업 단위**로서, **하나의 트랜잭션은 반드시 전부 성공하거나, 전부 실패해야 함**

### 🔹 트랜잭션의 4대 성질 (ACID)

| 항목            | 의미   | 설명                                   |
| --------------- | ------ | -------------------------------------- |
| **A**tomacity   | 원자성 | 모두 실행 또는 모두 롤백               |
| **C**onsistency | 일관성 | 무결성 제약조건 만족                   |
| **I**solation   | 고립성 | 동시에 실행되는 트랜잭션은 서로 간섭 X |
| **D**urability  | 지속성 | 커밋된 내용은 장애가 나도 유지됨       |

## ✅ 2. 트랜잭션 기본 SQL 명령어

```sql
BEGIN;         -- 트랜잭션 시작 (DB마다 다름: START TRANSACTION 등)
UPDATE users SET balance = balance - 100 WHERE id = 1;
UPDATE users SET balance = balance + 100 WHERE id = 2;
COMMIT;        -- 변경사항 저장
ROLLBACK;      -- 오류 시 모든 변경 취소
```

### 🔹 Python 예시 (pymysql, psycopg2 등)

```python
conn = db.connect()
try:
    with conn:
        with conn.cursor() as cur:
            cur.execute("UPDATE account SET balance = balance - 100 WHERE id = 1")
            cur.execute("UPDATE account SET balance = balance + 100 WHERE id = 2")
except Exception as e:
    print("에러 발생:", e)
    conn.rollback()
```

## ✅ 3. 오류 상황 & 디버깅 전략

### 🔸 문제 유형

| 유형             | 예시                                  |
| ---------------- | ------------------------------------- |
| 트랜잭션 중단    | 중간에 오류 발생 → ROLLBACK 필요      |
| 데드락(Deadlock) | 서로가 잠근 자원을 기다리는 교착 상태 |
| 고립성 문제      | Dirty Read, Phantom Read 등           |
| 제약조건 위반    | PRIMARY KEY 중복, 외래키 오류 등      |

### 🔸 에러 대응 전략

| 전략                        | 설명                                        |
| --------------------------- | ------------------------------------------- |
| **트랜잭션 단위 최소화**    | 너무 많은 쿼리를 하나에 묶지 말 것          |
| **자동 커밋 비활성화 확인** | `autocommit = False` 설정 여부 확인         |
| **EXCEPTION 핸들링**        | ROLLBACK 조건 명확하게 설정                 |
| **로그 출력 필수**          | 어떤 쿼리에서 문제가 발생했는지 로그 남기기 |

## ✅ 4. Isolation Level (고립성 단계)

| 레벨                 | 설명                                             | 보장 수준 |
| -------------------- | ------------------------------------------------ | --------- |
| **READ UNCOMMITTED** | 커밋 전 변경도 읽음 → 매우 위험                  |           |
| **READ COMMITTED**   | 커밋된 데이터만 읽음                             |           |
| **REPEATABLE READ**  | 트랜잭션 중 같은 SELECT는 항상 같은 결과         |           |
| **SERIALIZABLE**     | 완전한 직렬 실행처럼 보장 (가장 엄격, 성능 저하) |           |

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

## ✅ 5. 실무 디버깅 체크리스트

| 체크 항목         | 확인 포인트                                      |
| ----------------- | ------------------------------------------------ |
| 트랜잭션 경계     | BEGIN ~ COMMIT 사이에 논리 단위 맞는가           |
| 예외 발생 시 롤백 | try-except → `rollback()` 했는가                 |
| 락 관련 오류      | 데드락 에러 메시지 확인 (SQLSTATE 40001 등)      |
| 테스트 시 재현    | 로그 기반 입력/상태 재현 가능한가                |
| DB 설정 확인      | 트랜잭션 로그 크기, 락 타임아웃, autocommit 설정 |

## ✅ 실무 예시: 돈 이체 트랜잭션 처리

```sql
BEGIN;

-- 출금
UPDATE account SET balance = balance - 10000 WHERE user_id = 1;

-- 입금
UPDATE account SET balance = balance + 10000 WHERE user_id = 2;

-- 커밋
COMMIT;
```

→ 입금만 성공하고 출금이 실패하면? → `ROLLBACK`으로 모두 취소해야 함

## 🧠 마무리 요약

| 항목            | 요약                                                    |
| --------------- | ------------------------------------------------------- |
| 트랜잭션        | 논리적 작업 단위, 전부 실행 또는 전부 롤백              |
| ROLLBACK        | 오류 시 반드시 수행                                     |
| Isolation Level | 동시성 제어 품질 조정                                   |
| 실무 팁         | 로그 남기고, ROLLBACK 대비하고, 쿼리 분할로 안정성 확보 |

# C. 프로그램 구현

# 요구사항 분석 → 클래스 설계 → 기능 구현

## ✅ 1. 요구사항 분석 (Requirement Analysis)

### 🔸 개념

> 사용자가 필요로 하는 기능, 동작 조건, 제약 사항을 **정리·정의·정형화**하는 단계

### 🔸 분석 절차

| 단계            | 설명                                     |
| --------------- | ---------------------------------------- |
| 요구사항 수집   | 인터뷰, 워크숍, 문서 분석                |
| 요구사항 분류   | **기능적 / 비기능적** 구분               |
| 유스케이스 정의 | 시스템이 사용자에게 제공할 시나리오 도출 |
| 예외 조건 파악  | 실패 케이스, 오류 흐름 고려              |
| 우선순위 지정   | 중요도/시급도 기반 정렬                  |

### 🔸 예시 요구사항

> “사용자가 **로그인**하면, **상품을 조회**하고 **장바구니에 담고**, **결제**할 수 있어야 한다.”

## ✅ 2. 클래스 설계 (Class Design)

### 🔸 개념

> 요구사항을 기반으로 **객체 지향적 구조**로 모델링
>  실세계 개념을 **클래스와 객체**로 추상화

### 🔸 설계 절차

| 절차      | 설명                                             |
| --------- | ------------------------------------------------ |
| 개체 도출 | 명사 → 클래스 후보 (User, Product, Cart 등)      |
| 책임 부여 | 동사 → 메서드 후보 (login(), addToCart(), pay()) |
| 관계 정의 | 클래스 간 **연관, 상속, 포함** 관계 설정         |
| 속성 정의 | 필요한 필드 정리 (name, price 등)                |

### 🔸 클래스 다이어그램 예시 (UML)

```
User
 ├─ id : String
 ├─ password : String
 └─ login() : boolean

Product
 ├─ id : int
 ├─ name : String
 └─ price : int

Cart
 ├─ items : List<Product>
 ├─ addProduct(p: Product)
 └─ totalPrice() : int
```

## ✅ 3. 기능 구현 (Coding / Implementation)

### 🔸 구현 예시 (Java 스타일, Python도 가능)

```python
class Product:
    def __init__(self, id, name, price):
        self.id = id
        self.name = name
        self.price = price

class User:
    def __init__(self, user_id, password):
        self.user_id = user_id
        self.password = password

    def login(self, input_pw):
        return self.password == input_pw

class Cart:
    def __init__(self):
        self.items = []

    def add_product(self, p):
        self.items.append(p)

    def total_price(self):
        return sum(p.price for p in self.items)
```

### 🔸 사용 예시

```python
u = User("abc", "1234")
if u.login("1234"):
    cart = Cart()
    p1 = Product(1, "Keyboard", 30000)
    p2 = Product(2, "Mouse", 15000)
    cart.add_product(p1)
    cart.add_product(p2)
    print("총액:", cart.total_price())
```

## ✅ 4. 실무 구현 전략

| 전략            | 설명                                                     |
| --------------- | -------------------------------------------------------- |
| SRP 원칙        | 한 클래스는 하나의 책임만 (로그인 처리 vs 장바구니 분리) |
| 캡슐화          | 내부 필드는 `private`처럼 숨기고 메서드로만 접근         |
| 테스트 가능성   | 유닛 테스트를 염두에 두고 메서드 구성                    |
| 유스케이스 우선 | UI보다는 기능 흐름(시나리오) 먼저 완성할 것              |

## ✅ 전체 절차 요약

```
1. 요구사항 정의
   → 로그인, 상품 조회, 장바구니 기능 필요

2. 클래스 도출
   → User, Product, Cart

3. 속성 및 메서드 정의
   → login(), addProduct(), totalPrice()

4. 기능 단위 구현
   → 객체 생성 → 메서드 호출 → 흐름 테스트

5. 결과 검증
   → 출력, 예외 처리, 유닛 테스트 포함
```

# 입력/출력 설계, 예외처리, 로직 구현

## ✅ 1. 입력/출력 설계 (Input / Output Design)

### 🔸 개념

> 사용자가 **어떻게 데이터를 제공하고**, 시스템은 **어떻게 결과를 반환할지** 결정하는 단계

### 🔸 실전 고려사항

| 항목        | 설명                        | 예시                     |
| ----------- | --------------------------- | ------------------------ |
| 입력 형식   | 텍스트/숫자/리스트/객체     | 사용자 ID, 상품 목록 등  |
| 입력 유효성 | 필수 여부, 형식 검사        | 비어있음, 숫자 아님 등   |
| 출력 형식   | 콘솔/화면/파일/JSON 등      | API 응답, 로그 파일      |
| 출력 레벨   | 사용자용 vs 관리자/디버그용 | 예: `print`, `log.debug` |

### 🔸 예시 (콘솔 기반)

```python
# 입력
user_id = input("아이디 입력: ").strip()
age = int(input("나이 입력: "))

# 출력
print(f"{user_id}님의 나이는 {age}세입니다.")
```

## ✅ 2. 예외 처리 (Exception Handling)

### 🔸 개념

> 예상치 못한 오류나 **입력값 이상 상황에 안전하게 대응**하는 기술
>  시스템이 **비정상 종료되지 않도록 보호**하는 역할

### 🔸 예시: Python

```python
try:
    n = int(input("정수 입력: "))
    print(10 / n)
except ValueError:
    print("정수를 입력해야 합니다.")
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
finally:
    print("입력 처리 종료")
```

### 🔸 예외 처리 전략

| 전략                  | 설명                   |
| --------------------- | ---------------------- |
| 입력 유효성 사전 검사 | 숫자 여부, 범위 제한   |
| 예외 세분화           | `try-except` 블록 분할 |
| 로깅 처리             | `logging` 모듈로 기록  |
| 사용자 친화적 메시지  | 기술어 대신 의미 전달  |

## ✅ 3. 로직 구현 (Business Logic)

### 🔸 개념

> 요구사항을 만족하기 위한 **실제 계산/판단/처리 알고리즘**

### 🔸 구성 흐름

```
[입력] → [조건 판단] → [계산/처리] → [출력]
```

### 🔸 예시: 구매 금액 계산기

```python
def calculate_total(prices):
    total = 0
    for price in prices:
        if price < 0:
            raise ValueError("가격은 음수일 수 없습니다.")
        total += price
    return total

try:
    inputs = input("상품 가격들 입력 (쉼표로 구분): ").split(',')
    prices = list(map(int, inputs))
    total = calculate_total(prices)
    print(f"총 구매 금액: {total}원")
except Exception as e:
    print("에러 발생:", e)
```

## ✅ 4. 실무 적용 전략

| 항목                 | 팁                                                  |
| -------------------- | --------------------------------------------------- |
| 입력 구조 설계       | 예: 웹 → form, CLI → `argparse`, API → JSON         |
| 출력 포맷 설계       | 예: `print()` vs 로그 vs API Response (`dict`)      |
| 예외 메시지          | 사용자/개발자 분리 필요                             |
| 로직 분리            | "입출력 함수"와 "처리 함수"를 나눌 것               |
| 유닛 테스트용 함수화 | `main()`과 별도로 `calculate()` 같은 로직 함수 분리 |

## ✅ 마무리 예시 구조 (CLI 기준)

```python
def get_input():
    raw = input("입력값: ")
    return int(raw)

def process(x):
    if x < 0:
        raise ValueError("음수는 처리할 수 없습니다.")
    return x * 2

def show_result(result):
    print(f"결과: {result}")

def main():
    try:
        data = get_input()
        result = process(data)
        show_result(result)
    except Exception as e:
        print("오류 발생:", e)

if __name__ == "__main__":
    main()
```

# REST API 통신 (GET/POST)

## ✅ 1. REST API란?

> **REpresentational State Transfer**의 약자
>  **자원을 URI로 명확히 표현하고, HTTP 메서드(GET, POST 등)로 조작하는 방식**

## ✅ 2. HTTP 메서드 주요 용도

| 메서드      | 용도        | 예시                           |
| ----------- | ----------- | ------------------------------ |
| **GET**     | 데이터 조회 | `GET /users/1` → 1번 유저 정보 |
| **POST**    | 데이터 생성 | `POST /users` + 이름/이메일    |
| PUT / PATCH | 데이터 수정 | `PUT /users/1`                 |
| DELETE      | 데이터 삭제 | `DELETE /users/1`              |

## ✅ 3. REST API 요청 구조

### 🔹 1. GET 요청 (조회)

```http
GET /api/products?category=phone&page=2 HTTP/1.1
Host: example.com
```

→ 주소창, `<a href>`, axios.get(), fetch() 등에서 사용

### 🔹 2. POST 요청 (전송/생성)

```http
POST /api/login HTTP/1.1
Content-Type: application/json

{
  "username": "user01",
  "password": "1234"
}
```

→ 폼 제출, fetch/axios POST 등

## ✅ 4. 클라이언트에서 호출 예 (Python, JS)

### 🔸 Python (`requests` 라이브러리)

```python
import requests

# GET
res = requests.get("http://example.com/api/items", params={"page": 2})
print(res.json())

# POST
payload = {"username": "admin", "password": "1234"}
res = requests.post("http://example.com/api/login", json=payload)
print(res.json())
```

### 🔸 JavaScript (fetch)

```javascript
// GET
fetch("/api/items?page=2")
  .then(res => res.json())
  .then(data => console.log(data));

// POST
fetch("/api/login", {
  method: "POST",
  headers: {"Content-Type": "application/json"},
  body: JSON.stringify({username: "admin", password: "1234"})
})
  .then(res => res.json())
  .then(data => console.log(data));
```

## ✅ 5. 서버 응답 예시 (JSON)

```json
// 200 OK
{
  "status": "success",
  "user_id": 42,
  "token": "abc123xyz"
}

// 400 Bad Request
{
  "status": "error",
  "message": "Invalid credentials"
}
```

## ✅ 6. 실무 설계 팁

| 항목      | 팁                                              |
| --------- | ----------------------------------------------- |
| GET 요청  | **조회**만 할 것. 절대 DB 변경 X                |
| POST 요청 | 로그인, 등록 등 **변경이 생기는 작업**          |
| 응답 포맷 | 항상 JSON, 명확한 status/message 포함           |
| 상태코드  | 200, 201, 400, 401, 404, 500 등을 올바르게 설정 |
| 보안      | 민감 정보는 HTTPS, 토큰 인증(JWT 등) 필수       |

## ✅ REST API URL 설계 예

| 작업           | URI         | 메서드      |
| -------------- | ----------- | ----------- |
| 모든 유저 조회 | `/users`    | GET         |
| 특정 유저 조회 | `/users/42` | GET         |
| 유저 생성      | `/users`    | POST        |
| 유저 수정      | `/users/42` | PUT / PATCH |
| 유저 삭제      | `/users/42` | DELETE      |

# D. 테스트 및 배포

# 단위 테스트 코드 작성

## ✅ 1. 단위 테스트(Unit Test)란?

> **개별 함수, 메서드, 모듈 등 최소 단위 코드에 대해
>  정확히 동작하는지 자동으로 검증하는 테스트 코드**

- 실패 시 즉시 확인 가능 (에러 위치 명확)
- 코드 리팩토링 시 회귀 방지
- 자동화된 QA 가능 (CI 파이프라인 포함)

## ✅ 2. 단위 테스트 기본 구조

| 구성 요소   | 설명                              |
| ----------- | --------------------------------- |
| **Arrange** | 테스트를 위한 입력/환경 준비      |
| **Act**     | 실제 테스트 대상 실행             |
| **Assert**  | 기대 결과와 비교 (pass/fail 결정) |

## ✅ 3. Python: `unittest` 예시

```python
import unittest

# 테스트 대상 함수
def add(a, b):
    return a + b

class TestAdd(unittest.TestCase):
    def test_add_positive(self):
        self.assertEqual(add(2, 3), 5)

    def test_add_negative(self):
        self.assertEqual(add(-1, -2), -3)

    def test_add_zero(self):
        self.assertEqual(add(0, 0), 0)

if __name__ == '__main__':
    unittest.main()
```

## ✅ 4. Java: JUnit 5 예시

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.api.Test;

public class CalculatorTest {

    int add(int a, int b) {
        return a + b;
    }

    @Test
    void testAdd() {
        assertEquals(5, add(2, 3));
        assertEquals(0, add(-1, 1));
    }
}
```

## ✅ 5. 테스트 대상 코드 분리 원칙

- 테스트하려는 함수는 **순수 함수(pure function)**로 만들 것
- I/O, 네트워크, DB는 **Mocking**으로 분리
- **입력 → 출력** 구조를 명확하게 유지할 것

## ✅ 6. 실패 예시도 꼭 테스트하자

```python
def divide(a, b):
    return a / b

class TestDivide(unittest.TestCase):
    def test_divide_by_zero(self):
        with self.assertRaises(ZeroDivisionError):
            divide(10, 0)
```

## ✅ 7. 실무 단위 테스트 전략

| 전략                      | 설명                                          |
| ------------------------- | --------------------------------------------- |
| 메서드별 테스트 함수 작성 | 하나의 `test_XXX()`당 하나의 기능             |
| 입력/출력 명확화          | 단일 책임 원칙 준수                           |
| 테스트 커버리지 측정      | `coverage.py`, `jacoco` 등으로 코드 누락 확인 |
| 빠른 실패(Fail Fast)      | assert를 통해 즉시 실패 지점 확인             |
| CI 연동                   | GitHub Actions, Jenkins 등과 자동 테스트 연동 |

## ✅ 8. 테스트 이름 짓기 팁

```python
# 좋은 예
def test_sum_two_positive_numbers_returns_correct_sum(): ...
def test_login_with_wrong_password_returns_401(): ...
```

→ **의도 + 조건 + 결과**가 이름에 드러나야 함

## ✅ 9. 자주 사용하는 Assertion 메서드

| 메서드                 | 설명           |
| ---------------------- | -------------- |
| `assertEqual(a, b)`    | a == b         |
| `assertNotEqual(a, b)` | a != b         |
| `assertTrue(expr)`     | expr is True   |
| `assertFalse(expr)`    | expr is False  |
| `assertIn(x, list)`    | x in list      |
| `assertRaises(Error)`  | 예외 발생 검사 |

# 로그 확인 / 예외 처리

## ✅ 1. 예외 처리 (Exception Handling)

### 🔹 개념

> 프로그램 실행 중 발생할 수 있는 **오류 상황을 탐지하고 안전하게 처리**하는 기법

### 🔹 예외 처리 구조 (Python 기준)

```python
try:
    # 예외 가능 코드
    result = 10 / int(input("나누는 수 입력: "))
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다.")
except ValueError:
    print("숫자를 입력하세요.")
except Exception as e:
    print("알 수 없는 오류 발생:", e)
finally:
    print("예외 여부와 무관하게 실행")
```

### 🔹 Java 예시

```java
try {
    int result = 10 / n;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없음");
} catch (Exception e) {
    e.printStackTrace(); // 전체 예외 추적 로그
} finally {
    System.out.println("무조건 실행됨");
}
```

## ✅ 2. 로깅 (Logging)

### 🔹 개념

> 시스템 동작/예외/흐름/에러 정보를 **기록(log)**하여
>  **문제 추적, 운영 상태 모니터링, 보안 분석 등**에 활용하는 기술

### 🔹 Python 로깅 기본

```python
import logging

logging.basicConfig(level=logging.INFO)

try:
    x = 1 / 0
except Exception as e:
    logging.error("에러 발생: %s", e, exc_info=True)
```

| 레벨       | 용도                           |
| ---------- | ------------------------------ |
| `DEBUG`    | 디버깅용 상세 정보             |
| `INFO`     | 일반적인 처리 흐름 (정상 로그) |
| `WARNING`  | 주의할 만한 경고               |
| `ERROR`    | 예외 발생                      |
| `CRITICAL` | 시스템 중단급 오류             |

### 🔹 Java 로깅 예시 (Logback + SLF4J)

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Example {
    private static final Logger log = LoggerFactory.getLogger(Example.class);

    public void run() {
        try {
            // ...
        } catch (Exception e) {
            log.error("예외 발생", e);
        }
    }
}
```

## ✅ 3. 실무 로깅/예외 처리 전략

| 항목             | 전략                                                         |
| ---------------- | ------------------------------------------------------------ |
| 사용자에게는     | 에러 메시지 감춤, 친절한 안내 제공                           |
| 개발자에게는     | 로그 파일로 상세 예외, 스택 추적 기록                        |
| 로그 파일 구조   | 날짜별 회전, 레벨별 분리(logrotate 등)                       |
| 예외 핸들링 위치 | **Controller → Service → DAO** 계층별 구분                   |
| 공통 처리        | Spring의 `@ControllerAdvice`, Python의 `try-wrap` 데코레이터 활용 |
| 테스트에서       | 의도된 예외는 `assertRaises`, `expect().toThrow()`로 검증    |

## ✅ 4. 로그 확인 방법

| 환경      | 확인 방식                                                    |
| --------- | ------------------------------------------------------------ |
| 콘솔      | `print()`, `System.out.println()`, `logging.info()`          |
| 파일 로그 | `log.txt`, `error.log` 등 지정한 경로                        |
| 서버      | `/var/log/`, `journalctl`, `docker logs`                     |
| 클라우드  | AWS CloudWatch, Azure Monitor, ELK Stack (Elasticsearch + Logstash + Kibana) |

## ✅ 5. 예외 처리 + 로그 예제 통합 (Python)

```python
import logging

logging.basicConfig(filename="app.log", level=logging.ERROR)

def divide(x, y):
    try:
        return x / y
    except ZeroDivisionError as e:
        logging.error("ZeroDivisionError: %s", e)
        return None

print(divide(10, 0))  # None 출력, 로그 기록됨
```

## 🧠 요약 정리

| 항목      | 핵심 내용                                     |
| --------- | --------------------------------------------- |
| 예외 처리 | try-except-finally → 오류를 잡고 앱 죽지 않게 |
| 로깅      | 시스템 상태 기록 → 디버깅/모니터링용          |
| 로그 레벨 | DEBUG < INFO < WARNING < ERROR < CRITICAL     |
| 실무 전략 | 사용자용 메시지 vs 개발자용 상세 로그 분리    |
| 확인 위치 | 콘솔, 파일, 서버 로그, 클라우드 로그 시스템   |

# 배포 스크립트 작성 (bash, bat)

## ✅ 1. 배포 스크립트란?

> **애플리케이션 빌드 → 백업 → 복사 → 실행** 과정을 자동화하는 스크립트
>  사람 실수를 줄이고, 운영환경 배포를 **일관되게 처리**할 수 있도록 만듦

## ✅ 2. 기본 구조 예시

### 🔹 배포 작업 흐름 예시

```
1. 기존 서버 백업
2. 최신 코드 pull or 복사
3. 빌드 수행 (예: gradle, npm)
4. 실행 중인 서버 종료
5. 새 버전 실행
6. 로그 확인 or 알림
```

## ✅ 3. Bash 스크립트 (.sh)

### ● 파일명 예시: `deploy.sh`

```bash
#!/bin/bash

# 1. 변수 설정
APP_NAME="myapp"
APP_DIR="/home/ubuntu/myapp"
JAR_FILE="$APP_DIR/build/libs/myapp.jar"
LOG_FILE="$APP_DIR/deploy.log"
PID_FILE="$APP_DIR/app.pid"

# 2. 기존 프로세스 종료
if [ -f "$PID_FILE" ]; then
  PID=$(cat "$PID_FILE")
  echo ">> 기존 프로세스 종료: $PID"
  kill -9 "$PID"
  rm "$PID_FILE"
fi

# 3. 최신 빌드
echo ">> 빌드 시작"
cd "$APP_DIR" || exit 1
./gradlew build >> "$LOG_FILE" 2>&1

# 4. 새 프로세스 실행
echo ">> 새 서버 실행"
nohup java -jar "$JAR_FILE" > "$APP_DIR/nohup.out" 2>&1 &
echo $! > "$PID_FILE"

echo ">> 배포 완료"
```

## ✅ 4. Batch 스크립트 (.bat, Windows)

### ● 파일명 예시: `deploy.bat`

```bat
@echo off
set APP_DIR=C:\myapp
set JAR_FILE=%APP_DIR%\build\libs\myapp.jar
set PID_FILE=%APP_DIR%\app.pid

echo Killing existing process...
for /f %%i in (%PID_FILE%) do taskkill /PID %%i /F

echo Building project...
cd /d %APP_DIR%
call gradlew.bat build

echo Starting server...
start /B java -jar %JAR_FILE% > %APP_DIR%\log.txt 2>&1
echo %ERRORLEVEL% > %PID_FILE%

echo Deployment complete.
```

## ✅ 5. 실무용 추가 기능

| 기능         | 설명                                                  |
| ------------ | ----------------------------------------------------- |
| `git pull`   | 최신 코드 자동 반영                                   |
| `rsync`      | 원격 서버에 파일 동기화                               |
| `scp`        | 타 서버에 바이너리 전송                               |
| `curl/slack` | 배포 완료 알림 전송                                   |
| `systemctl`  | 리눅스 서비스 등록/재시작 (`systemctl restart myapp`) |

## ✅ 6. 배포 자동화 전략

| 전략                 | 설명                                                 |
| -------------------- | ---------------------------------------------------- |
| **백업 포함**        | `cp -r ./backup/$(date)`으로 기존 버전 보관          |
| **롤백 대비**        | 이전 JAR 또는 설정 보관 및 복구 가능하게             |
| **로그 기록**        | `>> deploy.log 2>&1` 로 표준출력 + 에러 모두 기록    |
| **실행 사용자 제한** | `chmod 700 deploy.sh`, `sudo` 사용 제한              |
| **CI/CD 연동**       | GitHub Actions, Jenkins, GitLab CI에서 스크립트 호출 |

## ✅ 실행 방법

- **Linux/Mac**

```bash
chmod +x deploy.sh
./deploy.sh
```

- **Windows**

```bat
deploy.bat
```

## 🧠 마무리 요약

| 항목 | 핵심 내용                                                    |
| ---- | ------------------------------------------------------------ |
| 목적 | 배포 자동화, 수동 실수 방지                                  |
| bash | 리눅스용, `.sh`, `#!/bin/bash`, `nohup`, `kill` 등           |
| bat  | 윈도우용, `.bat`, `taskkill`, `start /B` 등                  |
| 팁   | `log 기록`, `PID 추적`, `백업`, `빌드 실패 감지` 꼭 추가할 것 |

