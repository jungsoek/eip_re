## 1.4 Builder (빌더)

- 복잡한 객체를 단계적으로 생성
- `setX().setY().build()` 형태

### ✅ Builder 패턴이란?

> **복잡한 객체의 생성 과정을 분리**해서
>  **동일한 생성 절차로 서로 다른 표현 결과**를 만들 수 있게 하는 디자인 패턴

- 객체를 **부분적으로, 단계적으로 구성**
- 객체 생성의 **과정을 캡슐화**하여,
   **객체 내부 구조와 생성 과정을 분리**

### ✅ 1. 언제 쓰는가? (적용 목적)

| 상황                                   | 설명                                                  |
| -------------------------------------- | ----------------------------------------------------- |
| 생성자 파라미터가 너무 많을 때         | new Car("red", 4, false, true, ...)처럼 혼란스러울 때 |
| 선택적 파라미터가 많을 때              | 필수/옵션 구분해 유연하게 생성                        |
| 복잡한 객체 생성 절차를 숨기고 싶을 때 | 디렉터에게 빌더만 넘기면 됨                           |

### ✅ 2. 구조 (UML 기준)

```
         ┌──────────────┐
         │  Director    │ ← 생성 순서 관리
         └─────┬────────┘
               │
         ┌─────▼────────┐
         │  Builder     │ ← 추상 빌더 인터페이스
         ├──────────────┤
         │+buildPartA() │
         │+buildPartB() │
         │+getResult()  │
         └─────▲────────┘
       ┌───────────────┐
       │ConcreteBuilder│ ← 실제 구성 책임
       └───────────────┘

        ┌──────────────┐
        │  Product     │ ← 완성 객체
        └──────────────┘
```

### ✅ 3. Java 예제

#### 🔸 Product 클래스

```java
public class Car {
    private String engine;
    private String wheels;
    private boolean sunroof;

    // setter 방식 or 생성자 생략
    public void setEngine(String engine) { this.engine = engine; }
    public void setWheels(String wheels) { this.wheels = wheels; }
    public void setSunroof(boolean sunroof) { this.sunroof = sunroof; }

    public void showSpec() {
        System.out.println("엔진: " + engine);
        System.out.println("바퀴: " + wheels);
        System.out.println("썬루프: " + sunroof);
    }
}
```

#### 🔸 Builder 인터페이스

```java
public interface CarBuilder {
    void buildEngine();
    void buildWheels();
    void buildSunroof();
    Car getResult();
}
```

#### 🔸 ConcreteBuilder

```java
public class SportsCarBuilder implements CarBuilder {
    private Car car = new Car();

    public void buildEngine() { car.setEngine("V8 엔진"); }
    public void buildWheels() { car.setWheels("레이싱 타이어"); }
    public void buildSunroof() { car.setSunroof(true); }
    public Car getResult() { return car; }
}
```

#### 🔸 Director (조립 순서 담당)

```java
public class CarDirector {
    public Car construct(CarBuilder builder) {
        builder.buildEngine();
        builder.buildWheels();
        builder.buildSunroof();
        return builder.getResult();
    }
}
```

#### 🔸 사용 예

```java
public class Client {
    public static void main(String[] args) {
        CarBuilder builder = new SportsCarBuilder();
        CarDirector director = new CarDirector();
        Car car = director.construct(builder);
        car.showSpec();
    }
}
```

### ✅ 4. 파라미터 체이닝 방식 (Java 스타일 빌더)

```java
public class User {
    private final String name;
    private final int age;
    private final String email;

    private User(Builder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.email = builder.email;
    }

    public static class Builder {
        private String name;
        private int age;
        private String email;

        public Builder name(String name) {
            this.name = name; return this;
        }

        public Builder age(int age) {
            this.age = age; return this;
        }

        public Builder email(String email) {
            this.email = email; return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
```

### 🔹 사용 예

```java
User user = new User.Builder()
    .name("홍길동")
    .age(30)
    .email("hong@example.com")
    .build();
```

### ✅ 5. Python 예시

```python
class Burger:
    def __init__(self):
        self.parts = []

    def add(self, part):
        self.parts.append(part)

    def show(self):
        print("버거 구성:", self.parts)

class BurgerBuilder:
    def __init__(self):
        self.burger = Burger()

    def add_bun(self):
        self.burger.add("빵")
        return self

    def add_patty(self):
        self.burger.add("패티")
        return self

    def add_lettuce(self):
        self.burger.add("양상추")
        return self

    def build(self):
        return self.burger

# 사용
burger = BurgerBuilder().add_bun().add_patty().add_lettuce().build()
burger.show()
```

### ✅ 6. Builder vs Abstract Factory vs Factory Method

| 패턴                 | 목적                         | 특징                               |
| -------------------- | ---------------------------- | ---------------------------------- |
| **Builder**          | **복합 객체 생성 절차 분리** | 단계별 생성, 구조 유연             |
| **Factory Method**   | **단일 객체 생성 위임**      | 구상 객체 숨기고 서브클래스에 위임 |
| **Abstract Factory** | **제품군 일관성 유지**       | 팩토리로 여러 객체 일괄 생성       |

### ✅ 7. 장점

| 장점                  | 설명                                     |
| --------------------- | ---------------------------------------- |
| 복잡한 생성 로직 분리 | 생성과 표현을 분리함으로써 유지보수 용이 |
| 유연한 객체 생성      | 생성 순서/구성 선택 가능                 |
| 가독성 향상           | `builder.setX().setY()`로 코드 명확      |
| 불변 객체 생성에 유리 | 생성 후 변경 불가 객체 생성 시 효과적    |

### ❌ 단점

| 단점               | 설명                                |
| ------------------ | ----------------------------------- |
| 클래스 수 증가     | Builder, Director 등 추가 코드 필요 |
| 간단한 객체엔 과함 | 단순 객체엔 불필요한 구조           |

### ✅ 8. 실무 활용 예시

| 분야              | 활용                             |
| ----------------- | -------------------------------- |
| Lombok @Builder   | DTO, 엔티티 생성자 대체          |
| Jackson / GSON    | JSON → 객체 변환 시 Builder 지원 |
| REST API 응답     | 복합 응답 객체 생성 시 유용      |
| 객체 시리얼라이징 | 상태를 단계별로 구성할 때 효과적 |

### 🧠 마무리 요약

| 항목      | 핵심 내용                                          |
| --------- | -------------------------------------------------- |
| 목적      | 복잡한 객체 생성 과정을 분리하고, 다양한 표현 지원 |
| 핵심 구성 | Product, Builder, ConcreteBuilder, Director        |
| 사용 조건 | 파라미터가 많거나 조합이 다양한 객체 생성 시       |
| 대안      | `@Builder`, 체이닝 생성자, 팩토리 패턴과 조합      |

## 1.5 Prototype (프로토타입)

- 객체를 **복제(clone)**해서 생성
- 예: 객체 복사 성능 이슈 해결

### ✅ 1. 언제 쓰는가? (목적)

| 목적                                          | 설명                                          |
| --------------------------------------------- | --------------------------------------------- |
| 생성 비용이 큰 객체                           | 매번 생성하기 어려운 경우 복제하여 재사용     |
| 설정/상태가 동일한 객체가 여러 개 필요한 경우 | 공통 틀에서 복제해 다른 속성만 살짝 바꿔 사용 |
| `new` 키워드 사용을 줄이고 싶을 때            | 클래스가 뭔지 몰라도 객체 복제가 가능하게     |

### ✅ 2. 구조 (UML)

```
     ┌──────────────┐
     │ Prototype    │ ← clone() 메서드 선언 (interface or abstract)
     └─────┬────────┘
           │
     ┌─────▼────────┐
     │ ConcretePrototype │ ← clone() 구현
     └──────────────┘

           ▲
           │
     ┌──────────────┐
     │   Client     │ ← clone() 호출
     └──────────────┘
```

### ✅ 3. Java 예제

#### 🔸 ① Prototype 인터페이스

```java
public interface Prototype extends Cloneable {
    Prototype clone();
}
```

#### 🔸 ② ConcretePrototype

```java
public class Document implements Prototype {
    private String content;

    public Document(String content) {
        this.content = content;
    }

    public void print() {
        System.out.println("문서 내용: " + content);
    }

    @Override
    public Document clone() {
        try {
            return (Document) super.clone(); // 얕은 복사
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }

    public void setContent(String content) {
        this.content = content;
    }
}
```

#### 🔸 ③ 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        Document doc1 = new Document("원본 문서");
        Document doc2 = doc1.clone(); // 복제

        doc2.setContent("복제 문서");
        doc1.print(); // 원본 문서
        doc2.print(); // 복제 문서
    }
}
```

### ✅ 4. 얕은 복사 vs 깊은 복사

| 구분                    | 설명                                         | 영향                |
| ----------------------- | -------------------------------------------- | ------------------- |
| **얕은 복사 (Shallow)** | 기본 타입은 값 복사, 참조 타입은 주소만 복사 | 내부 참조 객체 공유 |
| **깊은 복사 (Deep)**    | 모든 내부 객체까지 재귀적으로 복사           | 독립된 객체 복사    |

#### 🔸 Java 깊은 복사 예시

```java
@Override
public Document clone() {
    Document copy = new Document(this.content); // 직접 새로 생성
    return copy;
}
```

### ✅ 5. Python 예제 (copy 모듈)

```python
import copy

class Prototype:
    def __init__(self, name, meta):
        self.name = name
        self.meta = meta

    def __str__(self):
        return f"{self.name}, {self.meta}"

# 얕은 복사
a = Prototype("원본", {"id": 1})
b = copy.copy(a)
b.meta["id"] = 2

print(a)  # meta도 바뀜!
print(b)
```

```python
# 깊은 복사
b = copy.deepcopy(a)
b.meta["id"] = 999
```

### ✅ 6. Prototype vs Factory Method

| 항목      | Prototype               | Factory Method                 |
| --------- | ----------------------- | ------------------------------ |
| 생성 방식 | 객체 복제               | 클래스 통해 직접 생성          |
| 속도      | 빠름 (복사)             | 상대적으로 느림                |
| 목적      | 동일한 구조의 객체 복제 | 객체 생성을 하위 클래스로 위임 |
| 유연성    | 동적으로 구조 복제      | 구조 확장에 강함               |

### ✅ 7. 장점

| 장점                    | 설명                               |
| ----------------------- | ---------------------------------- |
| 객체 생성 비용 감소     | 복제로 빠른 생성 가능              |
| 클래스에 의존하지 않음  | `.clone()`만 있으면 됨             |
| 다양한 객체의 동적 생성 | 런타임에서 객체 동적으로 복제 가능 |

### ❌ 단점

| 단점                              | 설명                                         |
| --------------------------------- | -------------------------------------------- |
| clone 구현이 까다로움             | 깊은 복사 시 재귀 처리, 참조 객체 고려 필요  |
| cloneable 미지원 객체 처리 어려움 | Java: `CloneNotSupportedException` 처리 필요 |
| 무분별한 복제는 혼란 유발         | 상태 관리 주의 필요 (공유된 객체 파손 가능)  |

### ✅ 8. 실무 활용 예

| 분야          | 사용 예                     |
| ------------- | --------------------------- |
| GUI 복제      | 컴포넌트 복사해서 UI 배치   |
| 게임 오브젝트 | 무기/캐릭터 템플릿 복사     |
| 문서 편집기   | 페이지/요소 복사 기능 구현  |
| 데이터 템플릿 | 양식 기반 입력폼, 보고서 등 |

### ✅ 9. Prototype Registry (프로토타입 캐시)

```java
Map<String, Prototype> registry = new HashMap<>();
registry.put("basic", new Document("템플릿"));
Document copy = registry.get("basic").clone();
```

→ 자주 쓰는 **템플릿 객체를 복제용으로 보관**해두는 방식

### 🧠 마무리 요약

| 항목        | 내용                                                     |
| ----------- | -------------------------------------------------------- |
| 목적        | **비용이 큰 객체 생성 대신, 복제(clone)로 새 객체 생성** |
| 구성        | Prototype 인터페이스, ConcretePrototype, Client          |
| 구현 포인트 | 얕은 복사 vs 깊은 복사 구분 필수                         |
| 실전 활용   | 문서 복제, 게임 객체, UI 컴포넌트 복사                   |
| 주의        | 복사 시 참조된 객체들의 상태 공유 주의                   |

## 🧱 2. **구조 패턴 (Structural)**

## 2.1 Adapter (어댑터)

- **호환되지 않는 인터페이스**를 연결
- `USB → Micro5핀`, `ListAdapter`, `@ResponseEntity` 등

### ✅ Adapter 패턴이란?

> **인터페이스 호환이 되지 않는 클래스를 클라이언트가 사용하도록 중간에 어댑터를 끼워 맞추는 구조 패턴**
>  즉, **"끼워 맞추기"**, "**변환기 역할**"을 하는 패턴.

### ✅ 1. 목적 (왜 쓰는가?)

| 목적                          | 설명                                                    |
| ----------------------------- | ------------------------------------------------------- |
| 인터페이스가 다른 클래스 사용 | 기존 코드 재사용, 외부 라이브러리 적용                  |
| 호환성 문제 해결              | 클라이언트는 A 인터페이스를 기대하는데, B만 제공될 경우 |
| 기존 클래스를 수정 없이 활용  | 변경 없이 어댑터만 만들어서 호환                        |

### ✅ 2. 구조 요약

```
Client ──────▶ Target (사용하고자 하는 인터페이스)
                          ▲
                          │
                  ┌───────┴────────┐
                  │   Adapter      │ ← 중간 변환자 (Target을 흉내냄)
                  └───────┬────────┘
                          │
                          ▼
                      Adaptee (기존 구현체)
```

### ✅ 3. Adapter 패턴의 2가지 종류

| 유형              | 설명                        | 구현 방식                                       |
| ----------------- | --------------------------- | ----------------------------------------------- |
| **클래스 어댑터** | 상속을 통해 인터페이스 변환 | `extends` + `implements` 사용 (Java에서 제한적) |
| **객체 어댑터**   | 위임(Composition)으로 변환  | 어댑터가 기존 객체를 참조하여 메서드 변환       |

→ 일반적으로 **객체 어댑터 방식이 더 유연하고 흔하게 쓰임**

### ✅ 4. UML (객체 어댑터 기준)

```
       ┌────────────┐
       │   Client   │
       └────┬───────┘
            ▼
       ┌────────────┐
       │   Target   │◄──────┐
       └────┬───────┘       │
            ▼               │
       ┌────────────┐       │
       │  Adapter   │──────►│
       └────────────┘       │
            ▲               │
            │ has-a         │
       ┌────────────┐       │
       │  Adaptee   │───────┘
       └────────────┘
```

### ✅ 5. Java 예제 (객체 어댑터 방식)

#### 🔹 기존 클래스 (Adaptee)

```java
public class OldPrinter {
    public void oldPrint(String msg) {
        System.out.println("OLD 출력: " + msg);
    }
}
```

#### 🔹 원하는 인터페이스 (Target)

```java
public interface Printer {
    void print(String msg);
}
```

#### 🔹 어댑터

```java
public class PrinterAdapter implements Printer {
    private OldPrinter oldPrinter;

    public PrinterAdapter(OldPrinter oldPrinter) {
        this.oldPrinter = oldPrinter;
    }

    public void print(String msg) {
        oldPrinter.oldPrint(msg); // 변환 수행
    }
}
```

#### 🔹 클라이언트 사용 예

```java
public class Client {
    public static void main(String[] args) {
        OldPrinter legacy = new OldPrinter();
        Printer printer = new PrinterAdapter(legacy); // 호환 가능

        printer.print("Hello Adapter!");
    }
}
```

### ✅ 6. Python 예시

```python
class OldPrinter:
    def old_print(self, text):
        print("OLD:", text)

class PrinterAdapter:
    def __init__(self, adaptee):
        self.adaptee = adaptee

    def print(self, msg):
        self.adaptee.old_print(msg)

# 사용
legacy = OldPrinter()
adapter = PrinterAdapter(legacy)
adapter.print("어댑터 패턴 예제")
```

### ✅ 7. 실무 활용 예

| 분야                 | 사용 예                                                      |
| -------------------- | ------------------------------------------------------------ |
| 외부 API 연동        | 인터페이스가 다를 때 중간 어댑터로 변환                      |
| 레거시 코드 리팩토링 | 기존 시스템 클래스를 새 시스템에 맞춰 사용할 때              |
| GUI 컴포넌트 연결    | 시스템마다 다른 인터페이스를 일관된 인터페이스로 통일        |
| JDBC/ORM             | `DataSource`, `ResultSet` 등 다양한 구현이 하나의 인터페이스로 작동 |

### ✅ 8. 장점

| 장점               | 설명                                           |
| ------------------ | ---------------------------------------------- |
| 재사용성 ↑         | 기존 클래스 변경 없이 재활용                   |
| 분리 구조 유지     | 새 시스템과 기존 구현 간 결합도 낮춤           |
| 유연한 시스템 구성 | 다양한 형식의 객체를 통일된 방식으로 사용 가능 |

### ❌ 단점

| 단점           | 설명                                               |
| -------------- | -------------------------------------------------- |
| 클래스 수 증가 | Adapter, Target 등 인터페이스 구성 필요            |
| 복잡도 증가    | 너무 많은 어댑터는 오히려 구조를 복잡하게 만듦     |
| 성능 이슈      | 중간 어댑터를 통해 호출되므로 약간의 오버헤드 존재 |

### ✅ 9. Adapter vs 다른 구조 패턴 비교

| 패턴          | 목적                                     | 특징                                           |
| ------------- | ---------------------------------------- | ---------------------------------------------- |
| **Adapter**   | 기존 인터페이스 ↔ 새로운 인터페이스 연결 | 클래스 수정 없이 연결                          |
| **Decorator** | 기능 확장                                | 인터페이스는 동일, 기능만 추가                 |
| **Facade**    | 서브시스템 간소화                        | 여러 인터페이스를 하나로 묶어 제공             |
| **Bridge**    | 구현과 추상 분리                         | 계층구조 확장에 유리 (interface + implementor) |

### 🧠 마무리 요약

| 항목      | 내용                                                     |
| --------- | -------------------------------------------------------- |
| 정의      | **호환되지 않는 인터페이스를 연결하는 중간 객체**        |
| 핵심 구조 | `Client → Target → Adapter → Adaptee`                    |
| 추천 방식 | **객체 어댑터 방식 (위임 기반)**                         |
| 실무 활용 | 레거시 ↔ 신규 연결, API 호환 처리                        |
| 주의점    | Adapter는 "변환기"일 뿐, 과도하게 남용하면 구조가 흐려짐 |

## 2.2 Bridge (브리지)

- **기능과 구현을 분리**
- 서로 독립적 확장 가능

### ✅ Bridge 패턴이란?

> **추상(Abstraction)과 구현(Implementation)을 분리**해서
>  **서로 독립적으로 확장할 수 있게** 만드는 구조 패턴

### ✅ 1. 언제 쓰는가? (목적)

| 상황                                          | 설명                                                  |
| --------------------------------------------- | ----------------------------------------------------- |
| **계층적으로 변화하는 클래스 구조가 있을 때** | ex) "도형"은 확장돼야 하고, "색상"도 계속 추가된다면? |
| **구현과 인터페이스를 독립적으로 확장**       | 각 변화가 서로 영향을 주지 않도록 분리                |
| **다형적 구조를 유지하면서 조합 가능한 경우** | 조합 개수 증가 시, 클래스 수 증가 폭을 줄이기 위해    |

### ✅ 2. 구조 요약 (핵심 개념)

| 요소                    | 설명                                                   |
| ----------------------- | ------------------------------------------------------ |
| **Abstraction**         | 인터페이스나 추상 클래스 역할. 구현에 대한 참조를 포함 |
| **RefinedAbstraction**  | Abstraction의 확장 (클라이언트가 사용하는 객체)        |
| **Implementor**         | 실제 기능을 수행할 인터페이스 (플랫폼 종속적 작업 등)  |
| **ConcreteImplementor** | Implementor의 구체 구현체                              |

### ✅ 3. UML 구조

```
        ┌────────────────────┐
        │   Abstraction      │
        ├────────────────────┤
        │ +operation()       │
        │ -impl : Implementor│──┐
        └────────────────────┘  │
                ▲               │
        ┌──────────────┐        │
        │ RefinedAbstr │        │
        └──────────────┘        │
                                ▼
                      ┌──────────────────┐
                      │   Implementor    │
                      ├──────────────────┤
                      │ +operationImpl() │
                      └──────────────────┘
                                ▲
                     ┌──────────┴──────────┐
                     │ ConcreteImplementor │
                     └─────────────────────┘
```

### ✅ 4. 예제 시나리오: **모양(Shape)** + **색상(Color)**

#### ✦ "Shape"와 "Color"를 독립적으로 확장하고 싶다면?

### ✅ 5. Java 예제

#### 🔸 Implementor

```java
public interface Color {
    String fill();
}
```

#### 🔸 ConcreteImplementor

```java
public class Red implements Color {
    public String fill() {
        return "빨간색";
    }
}

public class Blue implements Color {
    public String fill() {
        return "파란색";
    }
}
```

#### 🔸 Abstraction

```java
public abstract class Shape {
    protected Color color;

    public Shape(Color color) {
        this.color = color;
    }

    public abstract void draw();
}
```

#### 🔸 RefinedAbstraction

```java
public class Circle extends Shape {
    public Circle(Color color) {
        super(color);
    }

    public void draw() {
        System.out.println(color.fill() + " 원 그리기");
    }
}

public class Square extends Shape {
    public Square(Color color) {
        super(color);
    }

    public void draw() {
        System.out.println(color.fill() + " 정사각형 그리기");
    }
}
```

#### 🔸 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        Shape redCircle = new Circle(new Red());
        Shape blueSquare = new Square(new Blue());

        redCircle.draw();     // 빨간색 원 그리기
        blueSquare.draw();    // 파란색 정사각형 그리기
    }
}
```

### ✅ 6. Python 예시

```python
class Color:
    def fill(self): pass

class Red(Color):
    def fill(self): return "빨간색"

class Shape:
    def __init__(self, color):
        self.color = color

    def draw(self): pass

class Circle(Shape):
    def draw(self): print(f"{self.color.fill()} 원")

class Square(Shape):
    def draw(self): print(f"{self.color.fill()} 정사각형")

# 사용
Circle(Red()).draw()
```

### ✅ 7. 장점

| 장점                | 설명                                           |
| ------------------- | ---------------------------------------------- |
| 변화에 유연         | Abstraction ↔ Implementor 독립적으로 확장 가능 |
| 조합 수 증가에 강함 | 2개 축이 조합되더라도 클래스 수 폭발 막음      |
| 의존성 역전         | 상위 계층이 하위 구현에 직접 의존하지 않음     |

### ❌ 단점

| 단점                                | 설명                                     |
| ----------------------------------- | ---------------------------------------- |
| 구조가 복잡해짐                     | 추상 계층 + 구현 계층 → 구성 요소 많아짐 |
| 단순한 문제에 오버엔지니어링 가능성 | 작은 프로젝트엔 과한 설계일 수 있음      |

### ✅ 8. Bridge vs Adapter

| 구분      | Bridge                        | Adapter                                    |
| --------- | ----------------------------- | ------------------------------------------ |
| 목적      | **추상 ↔ 구현 분리 (확장성)** | **호환되지 않는 인터페이스 연결 (호환성)** |
| 사용 시점 | **설계 단계부터 적용**        | **기존 코드 재사용 시 적용**               |
| 관계      | 새로운 조합 설계              | 기존 코드 수정 없이 변환                   |
| 구조      | 다형성 기반 위임 구조         | 하나의 Target을 변환하는 중간 객체         |

### ✅ 9. 실무 적용 예

| 적용 분야     | 예시                                                     |
| ------------- | -------------------------------------------------------- |
| UI 프레임워크 | 테마(Abstraction) + 렌더러(Implementor) 분리             |
| DB 연결       | DAO와 DB 드라이버를 독립적으로 관리                      |
| 그래픽 API    | Shape 클래스 ↔ OpenGL/DirectX 같은 렌더링 계층 분리      |
| 리포트 생성기 | 리포트 타입(Excel, PDF) + 출력 방식(API, 파일 저장) 분리 |

### 🧠 마무리 요약

| 항목      | 내용                                                         |
| --------- | ------------------------------------------------------------ |
| 정의      | **추상과 구현을 분리**해서 각자 독립적으로 확장 가능하게 만드는 구조 패턴 |
| 구조      | `Abstraction ↔ Implementor`, 상호 위임                       |
| 장점      | 확장성 ↑, 조합 수 ↑, 느슨한 결합                             |
| 사용 시점 | "2개 이상의 확장 축"이 필요한 상황                           |
| 비교      | Adapter는 호환, Bridge는 구조적 확장                         |

## 2.3 Composite (컴포지트)

- 트리 구조 표현, **개별 객체와 그룹을 동일하게 취급**
- 예: 폴더와 파일, 댓글과 대댓글

### ✅ Composite 패턴이란?

> **부분-전체 계층 구조(트리 구조)**를 표현할 때,
>  **개별 객체와 복합 객체(그룹)를 동일하게 다룰 수 있게 하는 패턴**

즉, 클라이언트가 **"Leaf"와 "Group"을 구분하지 않고 동일한 방식으로 다루게** 해줌.

### ✅ 1. 목적

| 목표              | 설명                                  |
| ----------------- | ------------------------------------- |
| 트리 구조 표현    | 예: 디렉터리 안에 또 디렉터리, 파일   |
| 클라이언트 단순화 | Leaf/Group 구분 없이 통일된 연산 사용 |
| 재귀적 구조 처리  | 재귀 호출로 전체 구조를 손쉽게 탐색   |

### ✅ 2. 구조 (UML)

```
                ┌───────────────┐
                │   Component   │ ← 공통 인터페이스 (추상)
                ├───────────────┤
                │ +operation()  │
                └──────┬────────┘
             ┌─────────┴──────────┐
             ▼                    ▼
     ┌───────────────┐     ┌──────────────┐
     │     Leaf      │     │   Composite  │
     ├───────────────┤     ├──────────────┤
     │ +operation()  │     │ +add()       │
     └───────────────┘     │ +remove()    │
                           │ +operation() │ → 자식에게 위임
                           └──────────────┘
```

### ✅ 3. 현실 예시

- **파일 시스템**: 파일(Leaf) vs 폴더(Composite)
- **GUI 컴포넌트**: 버튼(Leaf) vs 패널(Composite)
- **조직도**: 직원(Leaf) vs 부서(Composite)

### ✅ 4. Java 예제: 파일 시스템 구조

#### 🔸 Component (공통 인터페이스)

```java
public interface FileComponent {
    void showInfo(String indent);
}
```

#### 🔸 Leaf

```java
public class FileLeaf implements FileComponent {
    private String name;

    public FileLeaf(String name) {
        this.name = name;
    }

    public void showInfo(String indent) {
        System.out.println(indent + "- 파일: " + name);
    }
}
```

#### 🔸 Composite

```java
import java.util.ArrayList;
import java.util.List;

public class DirectoryComposite implements FileComponent {
    private String name;
    private List<FileComponent> children = new ArrayList<>();

    public DirectoryComposite(String name) {
        this.name = name;
    }

    public void add(FileComponent component) {
        children.add(component);
    }

    public void remove(FileComponent component) {
        children.remove(component);
    }

    public void showInfo(String indent) {
        System.out.println(indent + "+ 폴더: " + name);
        for (FileComponent child : children) {
            child.showInfo(indent + "  ");
        }
    }
}
```

#### 🔸 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        FileComponent root = new DirectoryComposite("루트");
        FileComponent img = new DirectoryComposite("이미지");
        FileComponent doc = new DirectoryComposite("문서");

        img.add(new FileLeaf("photo.jpg"));
        doc.add(new FileLeaf("resume.pdf"));
        doc.add(new FileLeaf("report.docx"));

        root.add(img);
        root.add(doc);
        root.add(new FileLeaf("readme.txt"));

        root.showInfo(""); // 전체 트리 출력
    }
}
```

### ✅ 5. Python 예시 (간단 버전)

```python
class FileComponent:
    def show(self, indent=""): pass

class FileLeaf(FileComponent):
    def __init__(self, name):
        self.name = name

    def show(self, indent=""):
        print(indent + "- 파일:", self.name)

class DirectoryComposite(FileComponent):
    def __init__(self, name):
        self.name = name
        self.children = []

    def add(self, component):
        self.children.append(component)

    def show(self, indent=""):
        print(indent + "+ 폴더:", self.name)
        for child in self.children:
            child.show(indent + "  ")
```

### ✅ 6. 장점

| 장점                   | 설명                                               |
| ---------------------- | -------------------------------------------------- |
| 구조적 유연성 ↑        | 트리 구조에 적합, 구성 요소 간 계층 관계 표현 쉬움 |
| 클라이언트 코드 단순화 | Leaf/Composite 구분 없이 동일한 인터페이스 사용    |
| 재귀적 처리            | 트리 순회, 출력, 계산 등이 자연스러움              |

### ❌ 단점

| 단점                     | 설명                                            |
| ------------------------ | ----------------------------------------------- |
| 전체 구조 이해 어려움    | 중첩 구조가 깊어지면 디버깅 복잡                |
| 너무 범용적인 인터페이스 | Leaf에 필요 없는 메서드까지 정의하게 될 수 있음 |

### ✅ 7. Composite vs 다른 구조 패턴

| 패턴                        | 목적               | 특징                                 |
| --------------------------- | ------------------ | ------------------------------------ |
| **Composite**               | 트리 구조 표현     | Leaf와 Composite를 동일하게 사용     |
| **Decorator**               | 동적으로 기능 추가 | 계층 구조지만 목적은 “기능 덧붙이기” |
| **Bridge**                  | 추상과 구현 분리   | Tree 구조 아님, 계층 분리 중심       |
| **Chain of Responsibility** | 책임 전가          | 계층이지만 순차적 전달 구조          |

### ✅ 8. 실무 적용 예

| 분야            | 예시                                   |
| --------------- | -------------------------------------- |
| HTML DOM        | 태그 내부에 또 태그 (div > ul > li 등) |
| UI 구성         | 컴포넌트 → 패널 → 프레임               |
| 디렉터리 탐색기 | 폴더-파일 계층                         |
| 메뉴 시스템     | 메뉴 > 서브메뉴 > 항목                 |

### 🧠 마무리 요약

| 항목      | 내용                                                     |
| --------- | -------------------------------------------------------- |
| 정의      | **부분-전체 트리 구조에서 Leaf와 Group을 동일하게 처리** |
| 핵심 구조 | `Component ↔ Leaf`, `Composite → children 구성`          |
| 장점      | 트리 구조 표현, 재귀적 처리, 코드 단순화                 |
| 사용 시점 | 복합 구조를 클라이언트가 재귀적으로 처리해야 할 때       |

## 2.4 Decorator (데코레이터)

- 객체에 **기능을 동적으로 추가**
- 상속 대신 조합으로 확장
- 예: `BufferedInputStream`, `@Transactional`

### ✅ Decorator 패턴이란?

> **기존 객체를 변경하지 않고, 런타임에 기능을 동적으로 추가**할 수 있도록 하는 구조 패턴
>  즉, **상속 없이 기능을 확장하고 싶을 때 사용하는 패턴**

### ✅ 1. 언제 쓰는가? (적용 목적)

| 상황                            | 설명                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| 기능 조합이 많아질 때           | 상속으로 모든 조합 만들기 어려움 → 데코레이터로 유연하게 조합 |
| 클래스 수정이 불가능할 때       | 이미 배포된 라이브러리 등                                    |
| 실행 중 기능을 덧붙이고 싶을 때 | 런타임에 기능을 조절하고 확장해야 할 때                      |

### ✅ 2. 구조 (UML)

```
        ┌──────────────┐
        │  Component   │ ← 공통 인터페이스
        └─────┬────────┘
              │
   ┌──────────┴────────────┐
   ▼                       ▼
ConcreteComponent      Decorator (추상)
                          │
                ┌─────────┴────────┐
                ▼                  ▼
       ConcreteDecoratorA   ConcreteDecoratorB
```

### ✅ 3. 동작 방식 요약

- **Component**: 공통 인터페이스 정의
- **ConcreteComponent**: 기본 기능 구현
- **Decorator**: Component를 구현하고, 내부에 Component를 포함
- **ConcreteDecorator**: 실제로 기능을 덧붙이는 클래스

### ✅ 4. Java 예제: 메시지 포맷터

#### 🔸 Component

```java
public interface Message {
    String getContent();
}
```

#### 🔸 ConcreteComponent

```java
public class TextMessage implements Message {
    private String content;

    public TextMessage(String content) {
        this.content = content;
    }

    public String getContent() {
        return content;
    }
}
```

#### 🔸 Decorator (추상 클래스)

```java
public abstract class MessageDecorator implements Message {
    protected Message message;

    public MessageDecorator(Message message) {
        this.message = message;
    }
}
```

#### 🔸 ConcreteDecoratorA: HTML 태그로 감싸기

```java
public class HtmlDecorator extends MessageDecorator {
    public HtmlDecorator(Message message) {
        super(message);
    }

    public String getContent() {
        return "<html>" + message.getContent() + "</html>";
    }
}
```

#### 🔸 ConcreteDecoratorB: 암호화

```java
public class EncryptionDecorator extends MessageDecorator {
    public EncryptionDecorator(Message message) {
        super(message);
    }

    public String getContent() {
        return encrypt(message.getContent());
    }

    private String encrypt(String msg) {
        return new StringBuilder(msg).reverse().toString(); // 단순 반전
    }
}
```

#### 🔸 사용 예

```java
public class Client {
    public static void main(String[] args) {
        Message msg = new TextMessage("안녕하세요");

        Message html = new HtmlDecorator(msg);
        Message encrypted = new EncryptionDecorator(html);

        System.out.println(encrypted.getContent()); // >lmth/<요세하녕안><html>
    }
}
```

### ✅ 5. Python 예시

```python
class Message:
    def get_content(self): pass

class TextMessage(Message):
    def __init__(self, content):
        self.content = content

    def get_content(self):
        return self.content

class Decorator(Message):
    def __init__(self, msg):
        self.msg = msg

class HtmlDecorator(Decorator):
    def get_content(self):
        return f"<html>{self.msg.get_content()}</html>"

class EncryptDecorator(Decorator):
    def get_content(self):
        return self.msg.get_content()[::-1]

# 사용
msg = TextMessage("Hello")
decorated = EncryptDecorator(HtmlDecorator(msg))
print(decorated.get_content())  # >lmth<olleH>html<
```

### ✅ 6. 실무 활용 예시

| 분야               | 적용 사례                                             |
| ------------------ | ----------------------------------------------------- |
| **Java I/O**       | `InputStream → BufferedInputStream → GZIPInputStream` |
| **스프링 AOP**     | 프록시 기반 메서드 감싸기                             |
| **HTTP 필터 체인** | 요청/응답에 기능을 덧붙이면서 연결                    |
| **GUI 컴포넌트**   | 테두리, 스크롤바, 그림자 등 기능 계층적 조합          |

### ✅ 7. 장점

| 장점                | 설명                                          |
| ------------------- | --------------------------------------------- |
| 상속 없이 기능 확장 | 클래스 계층 없이 기능을 유연하게 붙일 수 있음 |
| 조합 가능           | 데코레이터를 중첩해서 다단계 기능 제공 가능   |
| OCP 만족            | 기존 코드 변경 없이 기능 확장 가능            |

### ❌ 단점

| 단점                                    | 설명                                         |
| --------------------------------------- | -------------------------------------------- |
| 디버깅 어려움                           | 여러 개가 중첩되면 어떤 순서인지 추적 어려움 |
| 클래스 수 증가                          | 데코레이터 수가 많아지면 구조 복잡           |
| Client가 내부 구조 모르면 사용이 어려움 | 어떤 데코레이터를 적용했는지 파악해야 함     |

### ✅ 8. 데코레이터 vs 관련 패턴

| 비교 대상     | 차이점                      |
| ------------- | --------------------------- |
| **Adapter**   | 인터페이스 변환             |
| **Composite** | 트리 구조                   |
| **Proxy**     | 객체 접근 제어 (보안, 캐싱) |
| **Decorator** | 기능을 확장                 |

### 🧠 마무리 요약

| 항목 | 내용                                            |
| ---- | ----------------------------------------------- |
| 정의 | **객체를 감싸 기능을 동적으로 추가**하는 패턴   |
| 구조 | `Component ↔ Decorator` 계층 + 내부 위임        |
| 목적 | 상속 대신 조합으로 기능 확장                    |
| 실전 | I/O 스트림, AOP, GUI 효과 조합                  |
| 특징 | 중첩 가능, 코드 확장성 우수, 디버깅 난이도 높음 |

## 2.5 Facade (퍼사드)

- 복잡한 서브시스템을 단순화
- 하나의 인터페이스로 여러 컴포넌트 묶기

### ✅ Facade 패턴이란?

> 복잡한 서브시스템(여러 클래스, 모듈 등)을
>  **단순한 인터페이스 하나로 감싸**,
>  **클라이언트가 쉽게 사용할 수 있도록 만든 구조 패턴**

### ✅ 1. 왜 사용하는가? (목적)

| 목적              | 설명                                       |
| ----------------- | ------------------------------------------ |
| 서브시스템 단순화 | 복잡한 하위 로직 묶음에 단일 진입점 제공   |
| 클라이언트 단순화 | 내부 구조를 몰라도 쉽게 사용 가능          |
| 결합도 낮추기     | 변경에 유연하게 대응 가능 (중간 계층 역할) |

### ✅ 2. 구조 요약 (UML)

```
Client
   │
   ▼
┌────────┐
│ Facade │ ◄────────────┐
└────────┘              │
  │     │     │         ▼
  ▼     ▼     ▼     SubsystemA
SubA  SubB  SubC     SubsystemB
                     SubsystemC
```

- **Client**: 복잡한 서브시스템을 직접 호출 X
- **Facade**: 여러 서브시스템에 대한 단순화된 인터페이스 제공
- **Subsystem**: 실질적인 작업 수행

### ✅ 3. Java 예제: 홈시어터 시스템

#### 🔸 하위 시스템들

```java
public class Amplifier {
    public void on() { System.out.println("앰프 켬"); }
    public void off() { System.out.println("앰프 끔"); }
}

public class Projector {
    public void on() { System.out.println("프로젝터 켬"); }
    public void off() { System.out.println("프로젝터 끔"); }
}

public class StreamingPlayer {
    public void play(String movie) {
        System.out.println("영화 재생: " + movie);
    }
    public void stop() {
        System.out.println("재생 중지");
    }
}
```

#### 🔸 퍼사드 클래스

```java
public class HomeTheaterFacade {
    private Amplifier amp;
    private Projector projector;
    private StreamingPlayer player;

    public HomeTheaterFacade(Amplifier amp, Projector proj, StreamingPlayer player) {
        this.amp = amp;
        this.projector = proj;
        this.player = player;
    }

    public void watchMovie(String movie) {
        System.out.println("=== 영화 보기 시작 ===");
        amp.on();
        projector.on();
        player.play(movie);
    }

    public void endMovie() {
        System.out.println("=== 영화 종료 ===");
        player.stop();
        projector.off();
        amp.off();
    }
}
```

#### 🔸 클라이언트 사용 예시

```java
public class Client {
    public static void main(String[] args) {
        Amplifier amp = new Amplifier();
        Projector proj = new Projector();
        StreamingPlayer player = new StreamingPlayer();

        HomeTheaterFacade home = new HomeTheaterFacade(amp, proj, player);

        home.watchMovie("Inception");
        home.endMovie();
    }
}
```

### ✅ 4. Python 예제 (간단 버전)

```python
class Amplifier:
    def on(self): print("앰프 켜짐")
    def off(self): print("앰프 꺼짐")

class Projector:
    def on(self): print("프로젝터 켜짐")
    def off(self): print("프로젝터 꺼짐")

class Player:
    def play(self, movie): print(f"{movie} 재생 중")
    def stop(self): print("재생 중지")

class HomeTheater:
    def __init__(self, amp, proj, player):
        self.amp = amp
        self.proj = proj
        self.player = player

    def start(self, movie):
        self.amp.on(); self.proj.on(); self.player.play(movie)

    def stop(self):
        self.player.stop(); self.proj.off(); self.amp.off()

# 사용
facade = HomeTheater(Amplifier(), Projector(), Player())
facade.start("Interstellar")
facade.stop()
```

### ✅ 5. 실무 활용 예

| 분야                 | 예시                                                         |
| -------------------- | ------------------------------------------------------------ |
| **스프링 Framework** | `JdbcTemplate`, `RestTemplate`, `WebClient` 모두 내부 복잡한 로직 감쌈 |
| **JPA/Hibernate**    | `EntityManager` → SQL, 트랜잭션, flush 등 복잡한 기능 포장   |
| **AWS SDK Wrapper**  | S3, EC2 등 여러 API 호출을 하나의 서비스로 감싸는 래퍼       |
| **UI 라이브러리**    | `DialogHelper.showLoading()`, `PopupHelper.showConfirm()` 등 복잡한 로직 단순화 |

### ✅ 6. 장점

| 장점                               | 설명                              |
| ---------------------------------- | --------------------------------- |
| 서브시스템 캡슐화                  | 내부 구조 숨김으로 유지보수 유리  |
| 사용 편의성 향상                   | 단순한 API 제공으로 진입장벽 낮춤 |
| 클라이언트와 시스템 간 결합도 낮춤 | 변경에도 영향 최소화              |

### ❌ 단점

| 단점                                                         | 설명 |
| ------------------------------------------------------------ | ---- |
| 너무 많은 기능 위임시 "하나의 거대한 God 클래스" 가능성      |      |
| 퍼사드에 너무 의존하면 내부 기능을 세밀하게 사용하지 못함 (유연성 저하) |      |

### ✅ 7. Facade vs 관련 패턴

| 비교 대상     | Facade               | 다른 패턴                  |
| ------------- | -------------------- | -------------------------- |
| **Adapter**   | 인터페이스 변환 목적 | 사용 방식 호환성 중시      |
| **Decorator** | 기능 확장 목적       | 기존 객체에 새 기능 덧붙임 |
| **Proxy**     | 접근 제어 목적       | 기능은 유지하되 제어만 함  |
| **Facade**    | 복잡한 시스템 단순화 | 내부 구현 다수 묶어 제공   |

### 🧠 마무리 요약

| 항목      | 내용                                                  |
| --------- | ----------------------------------------------------- |
| 정의      | **복잡한 서브시스템을 감싸는 단순한 인터페이스** 제공 |
| 구조      | Client → Facade → Subsystems                          |
| 핵심 장점 | 캡슐화, 결합도↓, 사용성↑                              |
| 사용 조건 | 내부 모듈 수가 많고, 이를 일괄 처리할 필요가 있을 때  |

## 2.6 Flyweight (플라이웨이트)

- 동일한 객체를 **공유**해서 메모리 절약
- 예: 텍스트 에디터에서 글자 객체 공유

### ✅ Flyweight 패턴이란?

> **객체를 공유해서 메모리 사용을 최소화**하는 구조 패턴
>  즉, **수많은 유사 객체를 효율적으로 관리**할 수 있도록
>  **공통 속성(불변, intrinsic)을 공유하고**,
>  **다른 속성(외부, extrinsic)은 외부에서 주입하는 방식**

### ✅ 1. 왜 사용하는가? (목적)

| 목적                                               | 설명                                                    |
| -------------------------------------------------- | ------------------------------------------------------- |
| 대규모 객체를 수천 개 이상 만들 경우 메모리 최적화 | 게임에서 수천 개의 나무, 문자 처리 등                   |
| 공통 속성 공유                                     | 동일한 형태의 객체를 반복 생성하지 않고 캐싱해서 재사용 |
| 성능 향상                                          | 객체 수를 줄여 GC 부담 감소                             |

### ✅ 2. 구성 요소 (핵심 구조)

| 구성                            | 설명                                        |
| ------------------------------- | ------------------------------------------- |
| **Flyweight (공통 인터페이스)** | 공유 가능한 객체의 인터페이스               |
| **ConcreteFlyweight**           | 내부 상태(intrinsic)를 가지며 재사용 가능   |
| **UnsharedFlyweight**           | 공유하지 않는 예외적 객체 (필요 시)         |
| **FlyweightFactory**            | Flyweight 객체를 생성하고 재사용하도록 관리 |
| **Client**                      | 외부 상태(extrinsic)를 전달하여 객체 사용   |

### ✅ 3. UML 구조

```
               Client
                 │
                 ▼
        ┌────────────────┐
        │ FlyweightFactory│
        └────────────────┘
                 │
      ┌──────────┼────────────┐
      ▼                       ▼
ConcreteFlyweightA    ConcreteFlyweightB
    ▲     ▲                 ▲
    │     │                 │
  내부 상태 공유     외부 상태는 Client가 전달
```

### ✅ 4. 핵심 개념: 내부 vs 외부 상태

| 구분                      | 설명                    | 예시                      |
| ------------------------- | ----------------------- | ------------------------- |
| **Intrinsic (내부 상태)** | 공유 가능한 불변 데이터 | 나무의 종류, 색상, 크기   |
| **Extrinsic (외부 상태)** | 매번 입력받는 개별 속성 | 위치(x, y), 방향, 상태 등 |

### ✅ 5. Java 예제: 나무(Tree) 렌더링 시뮬레이션

#### 🔸 Flyweight 인터페이스

```java
public interface TreeType {
    void render(int x, int y);
}
```

#### 🔸 ConcreteFlyweight

```java
public class TreeTypeImpl implements TreeType {
    private String name;
    private String color;
    private String texture;

    public TreeTypeImpl(String name, String color, String texture) {
        this.name = name;
        this.color = color;
        this.texture = texture;
    }

    public void render(int x, int y) {
        System.out.printf("(%d,%d) 위치에 [%s/%s] 나무 렌더링\n", x, y, name, color);
    }
}
```

#### 🔸 FlyweightFactory

```java
import java.util.*;

public class TreeFactory {
    private static final Map<String, TreeType> pool = new HashMap<>();

    public static TreeType getTreeType(String name, String color, String texture) {
        String key = name + color + texture;
        if (!pool.containsKey(key)) {
            pool.put(key, new TreeTypeImpl(name, color, texture));
        }
        return pool.get(key);
    }
}
```

#### 🔸 Client 사용 예시

```java
public class Forest {
    public static void main(String[] args) {
        TreeType oak = TreeFactory.getTreeType("Oak", "Green", "Rough");
        TreeType pine = TreeFactory.getTreeType("Pine", "DarkGreen", "Smooth");

        oak.render(10, 20);  // extrinsic (x, y)
        pine.render(15, 25);
        oak.render(100, 200);
    }
}
```

> 🧠 결과적으로 같은 TreeType 객체가 1개만 생성되어 여러 좌표에서 재사용됨

### ✅ 6. Python 예시 (간단)

```python
class TreeType:
    def __init__(self, name, color, texture):
        self.name = name
        self.color = color
        self.texture = texture

    def render(self, x, y):
        print(f"({x},{y}) 위치에 {self.name} 나무 [{self.color}] 렌더링")

class TreeFactory:
    _pool = {}

    @classmethod
    def get_tree(cls, name, color, texture):
        key = (name, color, texture)
        if key not in cls._pool:
            cls._pool[key] = TreeType(name, color, texture)
        return cls._pool[key]

# 사용
for i in range(0, 10000, 1000):
    tree = TreeFactory.get_tree("Oak", "Green", "Rough")
    tree.render(i, i)
```

### ✅ 7. 장점

| 장점            | 설명                                |
| --------------- | ----------------------------------- |
| 메모리 절약     | 공통 속성 공유 → 객체 수 감소       |
| 성능 향상       | GC, 메모리 비용 절감                |
| 시스템 확장성 ↑ | 많은 객체 생성에도 시스템 유지 가능 |

### ❌ 단점

| 단점                            | 설명                                 |
| ------------------------------- | ------------------------------------ |
| 코드 복잡도 증가                | 내부/외부 상태 구분 필요             |
| 멀티스레드 환경에서 동기화 주의 | 공유 객체에 동시 접근 시 오류 가능   |
| 객체 관리 복잡                  | 캐싱 전략, 재사용 정책이 명확해야 함 |

### ✅ 8. 실무 활용 예

| 분야            | 적용 예시                                |
| --------------- | ---------------------------------------- |
| **게임 엔진**   | 몬스터, 배경 나무, 총알 등 반복되는 개체 |
| **폰트 렌더링** | 자주 사용하는 글자 Glyph 객체 재사용     |
| **문서 편집기** | 스타일 정보 공유 (폰트, 크기, 색상 등)   |
| **지도 앱**     | 마커, 라벨 아이콘, 도형 공유             |

### ✅ 9. Flyweight vs Singleton vs Prototype

| 패턴          | 목적                  | 공유 여부     | 인스턴스 수           |
| ------------- | --------------------- | ------------- | --------------------- |
| **Flyweight** | 다수의 유사 객체 공유 | ✅             | 여러 개 (유형별 1개)  |
| **Singleton** | 전역 단일 인스턴스    | ✅             | 오직 1개              |
| **Prototype** | 객체 복제             | ❌ (개별 복사) | 복제할 때마다 새 객체 |

### 🧠 마무리 요약

| 항목        | 설명                                              |
| ----------- | ------------------------------------------------- |
| 정의        | **공통 속성을 공유하여 메모리 절약**하는 패턴     |
| 핵심 개념   | 내부 상태 공유, 외부 상태는 클라이언트가 제공     |
| 추천 사용처 | 수천~수만 개 객체 생성되는 상황                   |
| 구조        | `Client ↔ FlyweightFactory ↔ Flyweight 객체 공유` |

## 2.7 Proxy (프록시)

- 대상 객체를 **대신 사용하는 대리자**
- 예: 가상 프록시, 보안 프록시, RPC 프록시

### ✅ Proxy 패턴이란?

> 어떤 객체에 대한 **접근을 제어**하기 위해
>  **그 객체의 대리자(프록시)를 제공**하는 디자인 패턴.

즉, **진짜 객체 대신 Proxy 객체를 통해 접근**하고,
 그 과정에서 **추가 기능, 보안, 지연 처리, 로깅, 캐싱** 등을 수행할 수 있음.

### ✅ 1. 왜 사용하는가? (목적)

| 목적                   | 설명                                          |
| ---------------------- | --------------------------------------------- |
| 객체 생성 비용이 클 때 | 필요한 순간에만 실제 객체 생성 (Lazy Loading) |
| 접근 통제              | 보안 또는 권한 제어 목적                      |
| 로깅/캐싱              | 호출 전후의 작업 수행                         |
| 원격 통신              | 네트워크 넘어 있는 객체를 로컬처럼 사용       |

### ✅ 2. 구성 요소 (UML 구조)

```
Client
  │
  ▼
┌────────┐       implements       ┌────────────┐
│ Proxy  │ ─────────────────────▶ │ Subject     │
└────────┘                        └────────────┘
   │    ▲                            ▲
   ▼    │                            │
┌────────────┐            ┌──────────────────┐
│ RealSubject│◄───────────┘  (Concrete 구현) │
└────────────┘
```

- **Subject**: 공통 인터페이스 (Real + Proxy 모두 구현)
- **RealSubject**: 실제 작업을 수행하는 객체
- **Proxy**: RealSubject에 대한 접근을 대신 처리

### ✅ 3. Proxy 패턴의 유형

| 유형              | 설명                                 | 예시                     |
| ----------------- | ------------------------------------ | ------------------------ |
| **가상 프록시**   | 실제 객체 생성을 지연 (Lazy loading) | 이미지 로딩, 대형 문서   |
| **보호 프록시**   | 접근 권한 제어                       | 관리자 전용 페이지       |
| **원격 프록시**   | 네트워크 너머의 객체를 로컬처럼      | RMI, gRPC                |
| **스마트 프록시** | 사용량 측정, 로깅, 참조 카운팅       | 캐시 프록시, 로그 프록시 |

### ✅ 4. Java 예제: 가상 프록시

#### 🔸 Subject 인터페이스

```java
public interface Image {
    void display();
}
```

#### 🔸 RealSubject

```java
public class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk(); // 비용이 큰 작업
    }

    private void loadFromDisk() {
        System.out.println("이미지 로딩: " + filename);
    }

    public void display() {
        System.out.println("이미지 표시: " + filename);
    }
}
```

#### 🔸 Proxy

```java
public class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename); // 실제 객체 생성
        }
        realImage.display();
    }
}
```

#### 🔸 클라이언트 사용

```java
public class Client {
    public static void main(String[] args) {
        Image image = new ProxyImage("sample.png");

        System.out.println("프록시 생성 완료. 아직 로딩 X");
        image.display(); // 로딩 발생
        image.display(); // 캐싱된 객체 사용
    }
}
```

### ✅ 5. Python 예시 (가상 프록시)

```python
class RealImage:
    def __init__(self, filename):
        self.filename = filename
        self.load()

    def load(self):
        print(f"이미지 로딩: {self.filename}")

    def display(self):
        print(f"이미지 표시: {self.filename}")

class ProxyImage:
    def __init__(self, filename):
        self.filename = filename
        self.real = None

    def display(self):
        if not self.real:
            self.real = RealImage(self.filename)
        self.real.display()

# 사용
img = ProxyImage("cat.jpg")
print("프록시 생성됨")
img.display()
img.display()
```

### ✅ 6. 실무 활용 예

| 분야                           | 예시                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| **Spring AOP**                 | 프록시 기반으로 `@Transactional`, `@Cacheable`, `@Loggable` 적용 |
| **MyBatis / JPA Lazy Loading** | 연관 객체를 프록시로 감싸고, 필요 시 로딩                    |
| **보안 인증**                  | API 요청 프록시에서 인증 검사                                |
| **RPC / RMI**                  | Stub-Proxy 패턴으로 원격 객체 호출                           |

### ✅ 7. 장점

| 장점                                 | 설명                                              |
| ------------------------------------ | ------------------------------------------------- |
| 접근 제어                            | 보안, 인증, 제한된 권한 등 구현 가능              |
| Lazy Loading                         | 무거운 객체의 지연 생성 처리 가능                 |
| 기능 확장 용이                       | 로깅, 트래픽 제어, 모니터링 등 부가기능 삽입 용이 |
| 클라이언트는 RealSubject를 몰라도 됨 | 프록시와 같은 인터페이스 사용                     |

### ❌ 단점

| 단점                  | 설명                                 |
| --------------------- | ------------------------------------ |
| 구조 복잡도 증가      | Real + Proxy + Interface 구성 필요   |
| 프록시 객체 관리 부담 | 캐싱, 동기화, 참조 누수 등 주의 필요 |
| 성능 오버헤드         | 중간 경유 계층이 늘어남              |

### ✅ 8. Proxy vs Decorator vs Facade 비교

| 항목            | Proxy                        | Decorator               | Facade                     |
| --------------- | ---------------------------- | ----------------------- | -------------------------- |
| 목적            | **접근 제어 또는 대리 실행** | **기능 확장**           | **서브시스템 단순화**      |
| 클라이언트 입장 | 실제 객체처럼 보임           | 실제 객체에 기능 추가됨 | 서브시스템을 감싼 단일 API |
| 구조            | 인터페이스 공유              | 인터페이스 공유         | 완전히 새로운 진입점       |

### 🧠 마무리 요약

| 항목        | 내용                                                    |
| ----------- | ------------------------------------------------------- |
| 정의        | **진짜 객체에 대한 접근을 대리자 객체가 통제**하는 패턴 |
| 목적        | 접근 제어, 지연 로딩, 보안, 원격 호출 등                |
| 구조        | `Client → Proxy → RealSubject` (모두 같은 인터페이스)   |
| 활용 분야   | Spring AOP, ORM Lazy Loading, API 접근 제어, 캐시 서버  |
| 추천 사용처 | 성능 부담 크거나, 접근을 통제해야 하는 객체에 적합      |

## 🧱 3. **행위 패턴 (Behavioral)**

## 3.1 Chain of Responsibility (책임 연쇄)

- 요청을 처리할 수 있는 객체를 **연결 리스트로 연결**
- 예: 필터 체인, 인터셉터

### ✅ Chain of Responsibility 패턴이란?

> 요청을 처리할 수 있는 **여러 객체들을 체인처럼 연결**하고,
>  요청이 발생하면 **처리 가능한 객체가 책임을 맡도록 전달**하는 구조의 디자인 패턴.

즉, **하나의 요청을 여러 핸들러 중 하나가 처리**하며,
 처리할 수 없으면 **다음 핸들러로 넘기는 방식**.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                  | 설명                                                    |
| --------------------- | ------------------------------------------------------- |
| 요청 처리 로직을 분리 | 어떤 객체가 처리할지는 런타임까지 결정될 수 있도록 위임 |
| 유연한 책임 전가      | 조건에 따라 다른 객체가 처리하도록 체인 구성            |
| 조건 기반 다단계 처리 | 승인, 검증, 필터, 에러 처리 등 순차적 흐름 처리         |

### ✅ 2. 구조 (UML)

```
         Client
           │
           ▼
    ┌─────────────┐
    │  Handler     │ ◄─── 추상 클래스 or 인터페이스
    ├─────────────┤
    │+setNext()   │
    │+handle()    │
    └────┬────────┘
         ▼
 ┌──────────────┐
 │ HandlerA     │
 └──────────────┘
         ▼
 ┌──────────────┐
 │ HandlerB     │
 └──────────────┘
         ▼
 ┌──────────────┐
 │ HandlerC     │
 └──────────────┘
```

### ✅ 3. 흐름 요약

1. **Client**는 요청을 체인의 첫 번째 핸들러에 전달함
2. 각 핸들러는 요청을 **처리하거나**, 다음 핸들러에게 **위임**
3. 어느 핸들러도 처리하지 못하면 체인의 끝에서 종료됨

### ✅ 4. Java 예제: 권한 요청 승인 체인

#### 🔸 Handler 인터페이스

```java
public abstract class Approver {
    protected Approver next;

    public void setNext(Approver next) {
        this.next = next;
    }

    public void handleRequest(int amount) {
        if (next != null) {
            next.handleRequest(amount);
        }
    }
}
```

#### 🔸 ConcreteHandler

```java
public class Manager extends Approver {
    public void handleRequest(int amount) {
        if (amount <= 1000) {
            System.out.println("매니저 승인 완료: " + amount);
        } else {
            super.handleRequest(amount);
        }
    }
}

public class Director extends Approver {
    public void handleRequest(int amount) {
        if (amount <= 5000) {
            System.out.println("이사 승인 완료: " + amount);
        } else {
            super.handleRequest(amount);
        }
    }
}

public class CEO extends Approver {
    public void handleRequest(int amount) {
        System.out.println("CEO 최종 승인: " + amount);
    }
}
```

#### 🔸 클라이언트 코드

```java
public class Client {
    public static void main(String[] args) {
        Approver manager = new Manager();
        Approver director = new Director();
        Approver ceo = new CEO();

        manager.setNext(director);
        director.setNext(ceo);

        manager.handleRequest(500);     // Manager
        manager.handleRequest(3000);    // Director
        manager.handleRequest(8000);    // CEO
    }
}
```

### ✅ 5. Python 예시 (간단)

```python
class Handler:
    def __init__(self, next_handler=None):
        self.next = next_handler

    def handle(self, level):
        if self.next:
            self.next.handle(level)

class TeamLead(Handler):
    def handle(self, level):
        if level <= 1:
            print("팀장이 처리")
        else:
            super().handle(level)

class Manager(Handler):
    def handle(self, level):
        if level <= 2:
            print("매니저가 처리")
        else:
            super().handle(level)

class CEO(Handler):
    def handle(self, level):
        print("CEO가 처리")

# 체인 연결
chain = TeamLead(Manager(CEO()))
chain.handle(1)  # 팀장
chain.handle(2)  # 매니저
chain.handle(3)  # CEO
```

### ✅ 6. 실무 활용 예

| 분야                | 적용 사례                               |
| ------------------- | --------------------------------------- |
| **웹 필터 체인**    | 인증 → 권한 → 로깅 → 캐싱 순으로 처리   |
| **GUI 이벤트 처리** | 이벤트 버블링: 자식 → 부모 → 조상 위임  |
| **에러 핸들링**     | 예외 유형에 따라 적절한 핸들러에게 위임 |
| **결재 프로세스**   | 팀장 → 부장 → 이사 → 사장 승인          |

### ✅ 7. 장점

| 장점              | 설명                                         |
| ----------------- | -------------------------------------------- |
| 책임 분리         | 각 처리 로직이 별도 클래스로 분리됨          |
| 유연한 확장       | 핸들러 추가/제거/순서 변경이 쉬움            |
| 클라이언트 단순화 | 누가 처리할지 몰라도 체인의 시작점만 알면 됨 |

### ❌ 단점

| 단점                  | 설명                                            |
| --------------------- | ----------------------------------------------- |
| 디버깅 어려움         | 어떤 핸들러가 실제로 처리했는지 추적 어려움     |
| 요청이 누락될 수 있음 | 어느 핸들러도 처리하지 않으면 silent fail 발생  |
| 순서 중요             | 체인 순서를 잘못 구성하면 잘못된 결과 발생 가능 |

### ✅ 8. 관련 패턴 비교

| 패턴                        | 목적                   | 비교 포인트                          |
| --------------------------- | ---------------------- | ------------------------------------ |
| **Chain of Responsibility** | 책임을 연쇄적으로 전달 | 처리자가 여러 명, 순서대로 요청 전달 |
| **Command**                 | 요청을 객체로 캡슐화   | 실행/취소/저장 기능 중심             |
| **Observer**                | 이벤트 전파            | 여러 리스너에게 알림 (브로드캐스트)  |
| **Decorator**               | 기능 확장              | 기능을 누적 조립 (요청 전달은 유사)  |

### 🧠 마무리 요약 | Chain of Responsibility Pattern

| 항목          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 요청을 처리할 수 있는 객체들을 연결한 **체인 구조**로, 요청이 처리될 때까지 **다음 객체로 전달**되는 패턴 |
| **구조**      | `Handler → next → next → ...` (각 핸들러는 다음 핸들러로 요청을 전달함) |
| **사용 시점** | 다단계 승인 처리, GUI 이벤트 전파, 필터 체인 (Spring Filter, Servlet Filter 등) |
| **장점**      | 처리 책임이 분리되어 **유연한 확장**이 가능하며, **클라이언트 코드가 단순화**됨 |
| **주의점**    | 체인 구성 순서가 중요하고, **처리 누락 가능성** 있음 (모든 핸들러가 실패할 수 있음) |

## 3.2 Command (커맨드)

- 요청을 **객체로 캡슐화**, 실행 취소 / 큐 처리
- 예: Ctrl+Z, Undo 기능

### ✅ 1. 목적 (언제 쓰는가?)

| 목적             | 설명                               |
| ---------------- | ---------------------------------- |
| 요청을 캡슐화    | 요청, 실행자, 인자들을 객체로 포장 |
| 실행 취소/재실행 | 요청 기록 및 되돌리기 가능         |
| 큐잉/로그 처리   | 명령 저장, 스케줄링 가능           |
| 요청과 실행 분리 | 클라이언트와 실행 로직을 완전 분리 |

### ✅ 2. 구조 (UML)

```
Client
  │
  ▼
Invoker ──▶ Command ──▶ Receiver
              │
      + execute()
```

| 구성요소            | 설명                                 |
| ------------------- | ------------------------------------ |
| **Command**         | 실행 명령을 정의하는 인터페이스      |
| **ConcreteCommand** | 실제 실행 로직을 포함                |
| **Receiver**        | 명령을 수행하는 실제 대상            |
| **Invoker**         | 명령을 보관하고 실행하는 객체        |
| **Client**          | Command 객체를 생성해 Invoker에 전달 |

### ✅ 3. Java 예제: 리모컨 제어

#### 🔸 Receiver (실제 동작 주체)

```java
public class Light {
    public void on() {
        System.out.println("💡 불 켜짐");
    }
    public void off() {
        System.out.println("💡 불 꺼짐");
    }
}
```

#### 🔸 Command 인터페이스

```java
public interface Command {
    void execute();
}
```

#### 🔸 ConcreteCommand

```java
public class LightOnCommand implements Command {
    private Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.on();
    }
}

public class LightOffCommand implements Command {
    private Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    public void execute() {
        light.off();
    }
}
```

#### 🔸 Invoker (리모컨)

```java
public class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        Light light = new Light();

        Command on = new LightOnCommand(light);
        Command off = new LightOffCommand(light);

        RemoteControl remote = new RemoteControl();

        remote.setCommand(on);
        remote.pressButton(); // 💡 불 켜짐

        remote.setCommand(off);
        remote.pressButton(); // 💡 불 꺼짐
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Light:
    def on(self): print("💡 불 켜짐")
    def off(self): print("💡 불 꺼짐")

class Command:
    def execute(self): pass

class LightOnCommand(Command):
    def __init__(self, light): self.light = light
    def execute(self): self.light.on()

class LightOffCommand(Command):
    def __init__(self, light): self.light = light
    def execute(self): self.light.off()

class RemoteControl:
    def set_command(self, cmd): self.cmd = cmd
    def press_button(self): self.cmd.execute()

# 사용
light = Light()
on = LightOnCommand(light)
off = LightOffCommand(light)
remote = RemoteControl()

remote.set_command(on); remote.press_button()
remote.set_command(off); remote.press_button()
```

### ✅ 5. 실무 활용 예시

| 분야                   | 예시                                   |
| ---------------------- | -------------------------------------- |
| **UI 버튼 동작**       | 버튼 클릭 시 Command 객체 실행         |
| **Undo/Redo 시스템**   | 실행 기록을 저장하여 `undo()` 가능     |
| **매크로 실행**        | 여러 Command 조합으로 복잡한 동작 수행 |
| **네트워크 요청 큐잉** | Command를 큐에 넣고 순차 처리          |
| **스케줄러**           | 명령을 시간에 따라 실행                |

### ✅ 6. 장점

| 장점                   | 설명                                          |
| ---------------------- | --------------------------------------------- |
| 실행과 요청 분리       | 클라이언트는 실행 대상 몰라도 됨              |
| 취소, 재실행 구현 용이 | `undo()` 구현 시 효과적                       |
| 커맨드 큐 구현 가능    | 요청을 저장하고 순서대로 실행 가능            |
| 확장 용이              | 새로운 명령 추가 시 기존 코드 수정 없음 (OCP) |

### ❌ 단점

| 단점           | 설명                         |
| -------------- | ---------------------------- |
| 클래스 수 증가 | 명령마다 별도 클래스 필요    |
| 구조 복잡      | 간단한 작업에는 과할 수 있음 |

### ✅ 7. Command vs Strategy vs Observer

| 비교 대상    | 목적               | 구조 특징                    |
| ------------ | ------------------ | ---------------------------- |
| **Command**  | 요청 캡슐화 → 실행 | 실행 대상과 분리             |
| **Strategy** | 알고리즘 교체      | 실행 자체는 즉시 실행        |
| **Observer** | 이벤트 전파        | 등록된 객체에게 브로드캐스트 |

### 🧠 마무리 요약

| 항목          | 내용                                                        |
| ------------- | ----------------------------------------------------------- |
| **정의**      | **요청을 객체로 캡슐화**하여 실행, 취소, 큐잉이 가능한 구조 |
| **핵심 구성** | `Command ↔ Receiver`, `Invoker`는 명령을 실행               |
| **장점**      | 요청/실행 분리, undo/redo 가능, 큐/로그/스케줄링 적용 가능  |
| **단점**      | 클래스 수 증가, 단순 작업에 과도할 수 있음                  |
| **사용처**    | 리모컨 제어, GUI 이벤트 처리, 매크로, 트랜잭션 실행 기록 등 |

## 3.3 Interpreter (인터프리터)

- 언어 문법을 클래스 구조로 구현
- 예: 정규표현식 파서

### ✅ Interpreter 패턴이란?

> **언어(문법)를 객체화하여**,
>  해당 언어의 **문장을 해석(interpret)**하는 구조를 정의하는 패턴
>  즉, **작은 도메인 언어(DSL)**를 정의하고 해석할 수 있는 구조를 만드는 것

### ✅ 1. 언제 사용하는가? (목적)

| 목적                | 설명                                  |
| ------------------- | ------------------------------------- |
| 표현식 계산         | 수식 계산기, 논리 연산 해석 등        |
| DSL 해석            | 특정 분야에 특화된 언어의 해석기 구현 |
| 문법 기반 로직 표현 | 규칙, 조건, 명령을 문장 구조로 해석   |

### ✅ 2. 구조 (UML)

```
    ┌──────────────┐
    │ AbstractExpr │◄────────────┐
    └──────┬───────┘             │
           │                    │
  ┌────────▼────────┐   ┌───────▼───────┐
  │ TerminalExpr    │   │ NonTerminalExpr│
  └────────┬────────┘   └───────┬────────┘
           │                    │
         interpret()          interpret()
                               (다른 Expr 조합)

         ┌──────────────┐
         │   Context    │ ← 문자열, 변수, 결과 저장소
         └──────────────┘
```

| 요소                      | 설명                                         |
| ------------------------- | -------------------------------------------- |
| **Context**               | 해석에 필요한 정보 저장 (문자열, 변수 맵 등) |
| **AbstractExpression**    | 모든 표현식의 공통 인터페이스                |
| **TerminalExpression**    | 더 이상 쪼갤 수 없는 단말 표현식             |
| **NonTerminalExpression** | 다른 표현식들을 조합해서 해석하는 구성식     |

### ✅ 3. 간단 예시: Boolean 수식 해석기

> 예: "true OR false AND false"를 해석

### ✅ 4. Java 예제

#### 🔸 Expression 인터페이스

```java
public interface Expression {
    boolean interpret();
}
```

#### 🔸 TerminalExpression

```java
public class BoolLiteral implements Expression {
    private final boolean value;

    public BoolLiteral(boolean value) {
        this.value = value;
    }

    public boolean interpret() {
        return value;
    }
}
```

#### 🔸 NonTerminalExpression

```java
public class AndExpr implements Expression {
    private Expression left, right;

    public AndExpr(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    public boolean interpret() {
        return left.interpret() && right.interpret();
    }
}

public class OrExpr implements Expression {
    private Expression left, right;

    public OrExpr(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    public boolean interpret() {
        return left.interpret() || right.interpret();
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        // (true OR false) AND false
        Expression expr = new AndExpr(
            new OrExpr(
                new BoolLiteral(true),
                new BoolLiteral(false)
            ),
            new BoolLiteral(false)
        );

        System.out.println(expr.interpret()); // false
    }
}
```

### ✅ 5. Python 예시 (간단한 수식 해석기)

```python
class Expression:
    def interpret(self): pass

class Literal(Expression):
    def __init__(self, value): self.value = value
    def interpret(self): return self.value

class And(Expression):
    def __init__(self, left, right):
        self.left, self.right = left, right
    def interpret(self):
        return self.left.interpret() and self.right.interpret()

class Or(Expression):
    def __init__(self, left, right):
        self.left, self.right = left, right
    def interpret(self):
        return self.left.interpret() or self.right.interpret()

# 사용
expr = And(Or(Literal(True), Literal(False)), Literal(False))
print(expr.interpret())  # False
```

### ✅ 6. 실무 응용 사례

| 분야            | 예시                                                   |
| --------------- | ------------------------------------------------------ |
| 수식 계산기     | 계산기, 수학 파서                                      |
| SQL/정규식 파서 | WHERE 조건 해석기                                      |
| 텍스트 명령 DSL | 게임 AI, 챗봇 문법 해석                                |
| 정책 엔진       | 권한 조건 DSL (`user.is_admin AND resource.is_public`) |

### ✅ 7. 장점

| 장점                    | 설명                                        |
| ----------------------- | ------------------------------------------- |
| 문법을 객체화           | 문법 트리를 코드 구조로 표현 가능           |
| 확장성 ↑                | 새 문법 추가가 쉬움 (`And`, `Or`, `Not` 등) |
| 도메인 언어 설계에 유리 | Rule 기반 DSL 만들기 좋음                   |

### ❌ 단점

| 단점                   | 설명                                                |
| ---------------------- | --------------------------------------------------- |
| 성능 낮음              | 트리 구조가 커질수록 재귀적 해석 부담 ↑             |
| 복잡도 증가            | 문법 요소가 많아지면 클래스 수 증가                 |
| 문법이 복잡하면 부적합 | 정규식, 컴파일러 등에는 파서 제너레이터가 더 효율적 |

### ✅ 8. Interpreter vs Visitor vs Composite

| 패턴            | 역할                   | 비교                                    |
| --------------- | ---------------------- | --------------------------------------- |
| **Interpreter** | **문장을 해석**        | Expression Tree 기반                    |
| **Visitor**     | **노드마다 동작 분리** | Interpreter보다 연산 추가에 유리        |
| **Composite**   | **트리 구조 표현**     | Interpreter는 Composite를 기반으로 동작 |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | **언어의 문법 규칙을 클래스로 표현**하고, 해석 로직을 통해 실행 |
| **구성**      | Terminal/NonTerminal Expression + Context                    |
| **적용 시점** | 도메인 언어, 수식 해석기, 정책 시스템                        |
| **장점**      | 문법 객체화, DSL 구현, 확장성 우수                           |
| **단점**      | 느림, 복잡한 문법에 부적합, 클래스 수 증가                   |

## 3.4 Iterator (이터레이터)

- 집합 객체의 요소를 **순차적으로 접근**
- `hasNext()`, `next()`

### ✅ Iterator 패턴이란?

> 컬렉션 객체 내부 구조를 노출하지 않고,
>  그 **요소들을 순차적으로 접근할 수 있는 방법을 제공**하는 디자인 패턴

즉, `next()`, `hasNext()` 같은 방식으로
 **일관된 순회 인터페이스**를 제공하는 것

### ✅ 1. 왜 사용하는가? (목적)

| 목적                    | 설명                                                       |
| ----------------------- | ---------------------------------------------------------- |
| 컬렉션 구조 은닉        | 내부 구조를 노출하지 않고 순회                             |
| 다양한 컬렉션 순회 통일 | 배열, 리스트, 해시맵 등 다양한 구조를 동일한 방식으로 접근 |
| 커스터마이징 가능       | 역방향, 필터링 등 사용자 정의 순회도 가능                  |

### ✅ 2. 구조 (UML)

```
Client
  │
  ▼
Iterator ◄──────────── Aggregate
  │
  ▼
ConcreteIterator       ConcreteAggregate
```

| 구성요소              | 역할                                    |
| --------------------- | --------------------------------------- |
| **Aggregate**         | 컬렉션 인터페이스 (`createIterator()`)  |
| **ConcreteAggregate** | 실제 컬렉션                             |
| **Iterator**          | 순회 인터페이스 (`next()`, `hasNext()`) |
| **ConcreteIterator**  | 컬렉션 순회 구현체                      |

### ✅ 3. Java 예제: Book 컬렉션 순회

#### 🔸 Book 객체

```java
public class Book {
    private String title;

    public Book(String title) { this.title = title; }
    public String getTitle() { return title; }
}
```

#### 🔸 Iterator 인터페이스

```java
public interface Iterator {
    boolean hasNext();
    Object next();
}
```

#### 🔸 BookShelf (ConcreteAggregate)

```java
import java.util.ArrayList;

public class BookShelf {
    private ArrayList<Book> books = new ArrayList<>();

    public void addBook(Book book) {
        books.add(book);
    }

    public Book getBookAt(int index) {
        return books.get(index);
    }

    public int getLength() {
        return books.size();
    }

    public BookIterator iterator() {
        return new BookIterator(this);
    }
}
```

#### 🔸 BookIterator (ConcreteIterator)

```java
public class BookIterator implements Iterator {
    private BookShelf shelf;
    private int index = 0;

    public BookIterator(BookShelf shelf) {
        this.shelf = shelf;
    }

    public boolean hasNext() {
        return index < shelf.getLength();
    }

    public Object next() {
        return shelf.getBookAt(index++);
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        BookShelf shelf = new BookShelf();
        shelf.addBook(new Book("자바의 정석"));
        shelf.addBook(new Book("Effective Java"));

        Iterator it = shelf.iterator();
        while (it.hasNext()) {
            Book book = (Book) it.next();
            System.out.println(book.getTitle());
        }
    }
}
```

### ✅ 4. Python 예시 (Python은 기본적으로 지원)

```python
class Book:
    def __init__(self, title):
        self.title = title

class BookShelf:
    def __init__(self):
        self.books = []

    def add(self, book):
        self.books.append(book)

    def __iter__(self):
        return iter(self.books)

# 사용
shelf = BookShelf()
shelf.add(Book("Clean Code"))
shelf.add(Book("Design Patterns"))

for book in shelf:
    print(book.title)
```

### ✅ 5. 실무 활용 예

| 분야                    | 예시                                             |
| ----------------------- | ------------------------------------------------ |
| **Java Collection**     | `Iterator<E>` 인터페이스 (`next()`, `hasNext()`) |
| **Python for-loop**     | `__iter__()`와 `__next__()` 기반                 |
| **Cursor 기반 DB 탐색** | JDBC ResultSet, MongoDB Cursor                   |
| **파일/디렉터리 순회**  | Java `Files.walk()`, Python `os.walk()`          |

### ✅ 6. 장점

| 장점           | 설명                                     |
| -------------- | ---------------------------------------- |
| 캡슐화 유지    | 내부 구조를 노출하지 않고 순회           |
| 순회 방식 통일 | 다양한 컬렉션을 같은 방식으로 순회 가능  |
| 유연한 확장    | 역순, 필터링, 중첩 순회도 쉽게 구현 가능 |

### ❌ 단점

| 단점                                 | 설명                                            |
| ------------------------------------ | ----------------------------------------------- |
| 여러 이터레이터 동시 사용 시 주의    | 동일 컬렉션을 동시에 순회하면 충돌 가능         |
| 복잡한 순회 로직은 커스터마이징 필요 | 트리, 그래프 등은 일반 이터레이터로 처리 어려움 |

### ✅ 7. Iterator vs 다른 패턴

| 비교 대상     | 목적                  | 구조 차이                                |
| ------------- | --------------------- | ---------------------------------------- |
| **Iterator**  | 컬렉션 순회           | 컬렉션 구조 은닉                         |
| **Visitor**   | 구조 순회 + 기능 추가 | 방문 시점마다 행동 다르게                |
| **Composite** | 트리 구조 표현        | 트리와 순회 조합 시 이터레이터 사용 가능 |

### 🧠 마무리 요약

| 항목          | 내용                                                       |
| ------------- | ---------------------------------------------------------- |
| **정의**      | 컬렉션 요소를 **순차적으로 접근하는 방법을 제공**하는 패턴 |
| **핵심 요소** | `Iterator`, `Aggregate`                                    |
| **목적**      | 구조 은닉 + 순회 방식 통일                                 |
| **활용**      | for-loop, 컬렉션 순회, 데이터 커서                         |
| **장점**      | 일관된 순회, 구조 은닉, 확장 유연성                        |
| **단점**      | 순회 충돌, 비정형 자료구조에는 부적합                      |

## 3.5 Mediator (미디에이터)

- 객체 간 직접 통신 대신 **중재자(Mediator)**가 통제
- 예: 채팅방 관리

### ✅ Mediator 패턴이란?

> 객체 간 복잡한 **상호작용을 중재자(Mediator) 객체에 위임**하여,
>  객체들이 직접 서로를 참조하지 않고 **중앙 집중식 통신 구조**를 만드는 패턴

즉, **컴포넌트끼리 직접 통신하지 않고**
 **중간 관리자(Mediator)를 통해서만 상호작용**함.

### ✅ 1. 왜 사용하는가? (목적)

| 목적                             | 설명                                           |
| -------------------------------- | ---------------------------------------------- |
| 객체 간 의존도 감소              | 많은 객체가 서로 직접 참조하면 구조 복잡해짐   |
| 느슨한 결합                      | Mediator가 통제함으로써 객체 간 직접 연결 제거 |
| 복잡한 제어 흐름을 중앙에서 관리 | 변경, 확장, 테스트 용이                        |

### ✅ 2. 구조 (UML)

```
           ┌────────────┐
           │  Mediator  │◄────────────┐
           └─────┬──────┘             │
                 │                    │
        ┌────────▼────────┐   ┌───────▼────────┐
        │ ConcreteMediator │   │   Colleague    │
        └────────┬────────┘   └─────────────────┘
                 │                    ▲
        ┌────────▼──────┐     ┌───────┴────────┐
        │ ColleagueA    │     │  ColleagueB    │
        └───────────────┘     └────────────────┘
```

| 구성요소             | 설명                                  |
| -------------------- | ------------------------------------- |
| **Mediator**         | Colleague 간 상호작용을 정의          |
| **ConcreteMediator** | 구체적 중재 로직 구현                 |
| **Colleague**        | 참가자 객체, Mediator를 통해서만 통신 |

### ✅ 3. Java 예제: 채팅방 시스템

#### 🔸 Mediator 인터페이스

```java
public interface ChatRoomMediator {
    void showMessage(User user, String message);
}
```

#### 🔸 ConcreteMediator

```java
public class ChatRoom implements ChatRoomMediator {
    public void showMessage(User user, String message) {
        System.out.println(user.getName() + ": " + message);
    }
}
```

#### 🔸 Colleague 클래스

```java
public class User {
    private String name;
    private ChatRoomMediator mediator;

    public User(String name, ChatRoomMediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }

    public String getName() {
        return name;
    }

    public void send(String message) {
        mediator.showMessage(this, message);
    }
}
```

#### 🔸 클라이언트 코드

```java
public class Client {
    public static void main(String[] args) {
        ChatRoomMediator mediator = new ChatRoom();

        User alice = new User("Alice", mediator);
        User bob = new User("Bob", mediator);

        alice.send("안녕, Bob!");
        bob.send("안녕, Alice!");
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class ChatRoom:
    def show_message(self, user, message):
        print(f"{user.name}: {message}")

class User:
    def __init__(self, name, room):
        self.name = name
        self.room = room

    def send(self, message):
        self.room.show_message(self, message)

# 사용
room = ChatRoom()
alice = User("Alice", room)
bob = User("Bob", room)

alice.send("Hi Bob!")
bob.send("Hi Alice!")
```

### ✅ 5. 실무 활용 예

| 분야                      | 예시                                                         |
| ------------------------- | ------------------------------------------------------------ |
| **UI 컴포넌트**           | 버튼 클릭 → 텍스트 입력 → 리스트 갱신 등 이벤트 전달을 Mediator로 통제 |
| **항공관제 시스템**       | 항공기끼리 직접 통신 X, 관제탑(Mediator)이 중재              |
| **챗봇 구성 요소**        | Intent, NLP, 응답기 등 중간 허브로 분리                      |
| **Spring EventPublisher** | ApplicationEventPublisher가 중간 브로커 역할 수행            |

### ✅ 6. 장점

| 장점                | 설명                          |
| ------------------- | ----------------------------- |
| 객체 간 결합도 낮춤 | 변경 시 다른 객체 영향 최소화 |
| 로직 중앙 집중화    | 상호작용 흐름을 한곳에서 관리 |
| 테스트 용이         | 객체 단위 테스트가 쉬움       |

### ❌ 단점

| 단점                        | 설명                                                   |
| --------------------------- | ------------------------------------------------------ |
| Mediator 클래스 복잡도 증가 | 모든 상호작용이 한 곳에 집중되면 **God Object** 가능성 |
| 동적 관계가 많아지면 부담   | 구조 설계가 복잡한 경우 Mediator만으로 처리 어려움     |

### ✅ 7. Mediator vs Observer vs Facade

| 비교 대상    | 목적                | 주요 차이점                             |
| ------------ | ------------------- | --------------------------------------- |
| **Mediator** | 객체 간 통신 중재   | Colleague 간 직접 참조 제거             |
| **Observer** | 이벤트 브로드캐스트 | Publisher → N명에게 전달                |
| **Facade**   | 서브시스템 단순화   | 여러 클래스 묶어 단일 API 제공 (통신 X) |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 객체들 간의 통신을 **중재자에게 위임**하여, 직접 통신을 막고 **결합도를 낮추는 패턴** |
| **핵심 구성** | `Mediator ↔ Colleague`, 중앙에서 통신 제어                   |
| **사용 시점** | UI 이벤트 처리, 채팅, 항공관제, 이벤트 버스 등               |
| **장점**      | 결합도↓, 코드 변경 유연, 중앙 제어 가능                      |
| **단점**      | Mediator가 비대해질 수 있음 (God Object 우려)                |

## 3.6 Memento (메멘토)

- 객체 상태를 저장하고 복원
- 예: 게임 저장, Undo 기능

### ✅ Memento 패턴이란?

> 객체의 **내부 상태를 저장**해 두었다가,
>  나중에 **그 상태로 복원할 수 있게** 해주는 디자인 패턴.

즉, **“Ctrl+Z(Undo)” 기능을 객체화한 것**이라고 생각하면 됨.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                    | 설명                                                    |
| ----------------------- | ------------------------------------------------------- |
| 실행 취소 기능 구현     | 이전 상태로 되돌릴 수 있도록 스냅샷 저장                |
| 복잡한 객체의 상태 보존 | 객체 외부에서는 내부 상태를 알 수 없어도 상태 복원 가능 |
| 임시 상태 저장          | 작업 중 임시 저장/복원 시                               |

### ✅ 2. 구조 (UML)

```
 ┌─────────────┐
 │   Originator│────────────┐
 └─────┬───────┘            │
       │ createMemento()    │
       │ restore(memento)   │
       ▼                    │
 ┌─────────────┐            │
 │   Memento   │◄───────────┘ ← 상태를 보관하는 캡슐화 객체
 └─────────────┘
       ▲
       │
 ┌──────────────┐
 │ Caretaker    │ ← Memento를 보관하고, 요청 시 Originator에게 복원 요청
 └──────────────┘
```

| 구성요소       | 설명                                              |
| -------------- | ------------------------------------------------- |
| **Originator** | 상태를 가지며, Memento를 생성/복원할 수 있는 객체 |
| **Memento**    | 상태 저장 캡슐. 내부 구조는 외부에서 접근 불가    |
| **Caretaker**  | Memento를 저장하고 필요 시 Originator에게 전달    |

### ✅ 3. Java 예제: 텍스트 편집기 Undo

#### 🔸 Memento (불변 상태 캡슐)

```java
public class TextMemento {
    private final String state;

    public TextMemento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}
```

#### 🔸 Originator (문서 편집기)

```java
public class Editor {
    private String text = "";

    public void type(String words) {
        text += words;
    }

    public String getText() {
        return text;
    }

    public TextMemento save() {
        return new TextMemento(text);
    }

    public void restore(TextMemento memento) {
        this.text = memento.getState();
    }
}
```

#### 🔸 Caretaker (Undo 히스토리)

```java
import java.util.Stack;

public class EditorHistory {
    private Stack<TextMemento> history = new Stack<>();

    public void push(TextMemento m) {
        history.push(m);
    }

    public TextMemento pop() {
        return history.pop();
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        Editor editor = new Editor();
        EditorHistory history = new EditorHistory();

        editor.type("Hello ");
        history.push(editor.save());

        editor.type("World!");
        System.out.println(editor.getText()); // Hello World!

        editor.restore(history.pop());
        System.out.println(editor.getText()); // Hello
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Memento:
    def __init__(self, state): self._state = state
    def get_state(self): return self._state

class Editor:
    def __init__(self): self.text = ""
    def type(self, words): self.text += words
    def save(self): return Memento(self.text)
    def restore(self, memento): self.text = memento.get_state()

# 사용
editor = Editor()
history = []

editor.type("Hello ")
history.append(editor.save())

editor.type("World!")
print(editor.text)  # Hello World!

editor.restore(history.pop())
print(editor.text)  # Hello
```

### ✅ 5. 실무 활용 예

| 분야           | 예시                           |
| -------------- | ------------------------------ |
| 텍스트 편집기  | undo/redo 기능                 |
| 게임 상태 저장 | 저장 시점마다 스냅샷 보관      |
| 그래픽 툴      | 상태 복원, 이력 관리           |
| IDE            | 코드 리팩토링 시 상태 되돌리기 |

### ✅ 6. 장점

| 장점                | 설명                                |
| ------------------- | ----------------------------------- |
| 상태 보존           | 이전 상태로 완전하게 복원 가능      |
| 캡슐화 유지         | 내부 구현 숨기면서 상태만 전달 가능 |
| Undo/Redo 구현 쉬움 | 스택을 활용한 히스토리 저장         |

### ❌ 단점

| 단점                          | 설명                                   |
| ----------------------------- | -------------------------------------- |
| 메모리 부담                   | 상태가 클 경우 저장 비용 증가          |
| 많은 스냅샷 저장 시 성능 저하 | GC, 디스크 등 부하 고려 필요           |
| Caretaker 책임 증가           | Memento 관리, 스택 관리 등의 책임 집중 |

### ✅ 7. Memento vs Command vs Snapshot

| 패턴         | 목적            | 핵심 비교                            |
| ------------ | --------------- | ------------------------------------ |
| **Memento**  | 상태 저장/복원  | 상태 자체 저장, 외부는 접근 불가     |
| **Command**  | 실행 캡슐화     | 실행/되돌리기(undo) 포함             |
| **Snapshot** | DB 상태 보관 등 | 상태 덤프 저장, 범용적 개념 (패턴 X) |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 객체의 상태를 저장하고, 필요 시 그 상태로 복원할 수 있는 구조 |
| **핵심 구성** | `Originator`, `Memento`, `Caretaker`                         |
| **활용 사례** | 텍스트 편집기, 게임 저장, Undo 시스템                        |
| **장점**      | 캡슐화 유지, 복원 가능, 구조적 명확                          |
| **단점**      | 메모리 비용, 관리 책임 증가                                  |

## 3.7 Observer (옵저버)

- **한 객체의 상태 변화**를 **의존 객체에 자동 알림**
- 예: 이벤트 리스너, `@EventListener`

### ✅ Observer 패턴이란?

> **한 객체의 상태 변화**를
>  **의존하는 여러 객체에게 자동으로 통지**하도록 하는 패턴.
>  즉, **“발행-구독(Pub-Sub)” 구조를 객체화**한 것.

### ✅ 1. 언제 사용하는가? (목적)

| 목적           | 설명                                        |
| -------------- | ------------------------------------------- |
| 상태 변화 감지 | 객체의 상태 변경을 실시간으로 알림          |
| 느슨한 결합    | 주체(Subject)는 옵저버가 누구인지 몰라도 됨 |
| 실시간 반응    | 이벤트 기반 프로그래밍에 필수               |

### ✅ 2. 구조 (UML)

```
        ┌────────────┐
        │  Subject   │◄────────────────────────┐
        └─────┬──────┘                         │
              │                                │
     ┌────────▼─────────┐         ┌────────────▼────────────┐
     │ ConcreteSubject   │───────▶│       Observer           │
     └────────┬──────────┘         └────────────┬────────────┘
              │                                 ▼
              ▼                         ┌───────────────┐
     notifyObservers()                  │ConcreteObserver│
                                        └───────────────┘
```

| 구성 요소            | 설명                                          |
| -------------------- | --------------------------------------------- |
| **Subject**          | 옵저버 등록/해제/알림 인터페이스              |
| **ConcreteSubject**  | 실제 상태를 가지고, 변경 시 옵저버들에게 알림 |
| **Observer**         | 상태 변경을 통보받는 인터페이스               |
| **ConcreteObserver** | 통보를 받아 행동하는 실제 객체들              |

### ✅ 3. Java 예제: 뉴스 알림 시스템

#### 🔸 Observer 인터페이스

```java
public interface Subscriber {
    void update(String news);
}
```

#### 🔸 ConcreteObserver

```java
public class EmailSubscriber implements Subscriber {
    private String name;

    public EmailSubscriber(String name) {
        this.name = name;
    }

    public void update(String news) {
        System.out.println(name + "에게 이메일 발송: " + news);
    }
}
```

#### 🔸 Subject 인터페이스

```java
public interface NewsAgency {
    void subscribe(Subscriber s);
    void unsubscribe(Subscriber s);
    void notifySubscribers(String news);
}
```

#### 🔸 ConcreteSubject

```java
import java.util.*;

public class YTN implements NewsAgency {
    private List<Subscriber> list = new ArrayList<>();

    public void subscribe(Subscriber s) {
        list.add(s);
    }

    public void unsubscribe(Subscriber s) {
        list.remove(s);
    }

    public void notifySubscribers(String news) {
        for (Subscriber s : list) {
            s.update(news);
        }
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        NewsAgency ytn = new YTN();

        Subscriber s1 = new EmailSubscriber("철수");
        Subscriber s2 = new EmailSubscriber("영희");

        ytn.subscribe(s1);
        ytn.subscribe(s2);

        ytn.notifySubscribers("속보: 자바 패턴 시험 출제!");
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Observer:
    def update(self, msg): pass

class Subscriber(Observer):
    def __init__(self, name): self.name = name
    def update(self, msg): print(f"{self.name}에게 알림: {msg}")

class Publisher:
    def __init__(self): self.subscribers = []
    def subscribe(self, obs): self.subscribers.append(obs)
    def notify(self, msg):
        for obs in self.subscribers:
            obs.update(msg)

# 사용
pub = Publisher()
pub.subscribe(Subscriber("Alice"))
pub.subscribe(Subscriber("Bob"))

pub.notify("새 기사 올라옴!")
```

### ✅ 5. 실무 활용 예시

| 분야                 | 예시                                                         |
| -------------------- | ------------------------------------------------------------ |
| **UI/데이터 바인딩** | Model 변경 시 View 자동 반영 (MVVM, MVC)                     |
| **Event Bus**        | Spring `ApplicationEventPublisher`, Android `LiveData`, RxJava |
| **알림 시스템**      | 뉴스 알림, 주식 가격 변동, 상태 모니터링                     |
| **실시간 통신**      | WebSocket, MQTT 등에서 구독 구조 활용                        |

### ✅ 6. 장점

| 장점          | 설명                        |
| ------------- | --------------------------- |
| 느슨한 결합   | Subject와 Observer가 독립적 |
| 유연한 구조   | 구독자 추가/삭제가 쉬움     |
| 실시간 반응형 | 상태 변경 → 즉시 알림       |

### ❌ 단점

| 단점                  | 설명                                           |
| --------------------- | ---------------------------------------------- |
| 알림 순서/시점 불확실 | 비동기 알림 시 디버깅 어려움                   |
| 옵저버 관리 책임 필요 | 구독 해제 누락 시 메모리 누수 가능             |
| 무한 루프 발생 가능성 | 옵저버 내부에서 Subject 변경 시 재귀 발생 위험 |

### ✅ 7. Observer vs Mediator vs Event Bus

| 비교 대상     | 역할                    | 차이점                              |
| ------------- | ----------------------- | ----------------------------------- |
| **Observer**  | 다수에게 상태 변경 알림 | 1:N 전파 구조                       |
| **Mediator**  | 상호작용 중재           | 다대다 구조 제어                    |
| **Event Bus** | 비동기 브로드캐스트     | 등록자끼리 서로 모름 (pub-sub 분리) |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | **한 객체의 상태 변경**을 **여러 객체가 자동으로 통보받도록** 만드는 패턴 |
| **핵심 구조** | `Subject ↔ Observer` (1:N)                                   |
| **사용처**    | 데이터 변경 감지, 실시간 통신, UI 반응형 구조                |
| **장점**      | 느슨한 결합, 동적 연결, 반응형 시스템 구성 용이              |
| **단점**      | 순서 제어 어려움, 무한 루프 주의, 옵저버 정리 필요           |

## 3.8 State (상태)

- 객체 상태에 따라 행위를 변경 (if/else 제거)
- 예: 문서 상태(작성 → 승인 → 게시)

### ✅ State 패턴이란?

> **객체의 내부 상태에 따라 동작을 다르게** 하도록
>  **상태를 객체화**하여, 상태 전환 시 객체의 행동도 변경되도록 만드는 패턴

즉, **“if/else 상태 분기를 객체로 대체”**하는 구조

### ✅ 1. 언제 사용하는가? (목적)

| 목적                       | 설명                                         |
| -------------------------- | -------------------------------------------- |
| 상태 전환에 따른 행동 변화 | 상태에 따라 동작이 바뀌어야 할 때            |
| 조건문 제거                | if-else/switch 블록을 객체로 분리            |
| 실행 중 동적으로 상태 변경 | 런타임에서 행동이 자연스럽게 전환되도록 구성 |

### ✅ 2. 구조 (UML)

```
   ┌──────────────┐
   │   Context     │
   ├──────────────┤
   │ state: State  │──┐
   └──────┬────────┘  │
          ▼           ▼
      ┌──────────────┐
      │   State       │◄────────────┐
      └──────┬────────┘             │
             ▼                      │
    ┌──────────────────┐     ┌──────────────────┐
    │ ConcreteStateA    │     │ ConcreteStateB    │
    └──────────────────┘     └──────────────────┘
```

| 구성 요소         | 설명                                      |
| ----------------- | ----------------------------------------- |
| **Context**       | 상태를 가지고 있고, 상태에 따라 동작 위임 |
| **State**         | 상태 인터페이스 (행동 메서드 정의)        |
| **ConcreteState** | 각 상태에서의 구체적 행동 정의            |

### ✅ 3. Java 예제: 전자문서 결재 시스템

#### 🔸 State 인터페이스

```java
public interface DocumentState {
    void handle(Document doc);
}
```

#### 🔸 ConcreteState들

```java
public class DraftState implements DocumentState {
    public void handle(Document doc) {
        System.out.println("현재 상태: 초안 → 검토 중으로 변경");
        doc.setState(new ReviewState());
    }
}

public class ReviewState implements DocumentState {
    public void handle(Document doc) {
        System.out.println("현재 상태: 검토 → 승인 대기로 변경");
        doc.setState(new ApprovalState());
    }
}

public class ApprovalState implements DocumentState {
    public void handle(Document doc) {
        System.out.println("현재 상태: 승인 완료. 더 이상 상태 전이 없음.");
    }
}
```

#### 🔸 Context (상태를 가진 객체)

```java
public class Document {
    private DocumentState state;

    public Document() {
        this.state = new DraftState(); // 초기 상태
    }

    public void setState(DocumentState state) {
        this.state = state;
    }

    public void process() {
        state.handle(this); // 현재 상태에 따라 동작 위임
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        Document doc = new Document();

        doc.process(); // 초안 → 검토
        doc.process(); // 검토 → 승인
        doc.process(); // 승인 완료
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class State:
    def handle(self, context): pass

class Draft(State):
    def handle(self, context):
        print("초안 → 검토")
        context.state = Review()

class Review(State):
    def handle(self, context):
        print("검토 → 승인")
        context.state = Approval()

class Approval(State):
    def handle(self, context):
        print("승인 완료")

class Document:
    def __init__(self): self.state = Draft()
    def process(self): self.state.handle(self)

# 사용
doc = Document()
doc.process()
doc.process()
doc.process()
```

### ✅ 5. 실무 활용 예

| 분야                 | 예시                                     |
| -------------------- | ---------------------------------------- |
| **결제 상태 전이**   | 요청 → 결제 중 → 성공/실패               |
| **TCP 상태 관리**    | LISTEN → SYN_RECEIVED → ESTABLISHED 등   |
| **게임 캐릭터 상태** | 서기 / 걷기 / 점프 / 공격 등 상태별 동작 |
| **UI 컴포넌트 상태** | 활성화/비활성화/포커스/호버 등           |

### ✅ 6. 장점

| 장점             | 설명                                         |
| ---------------- | -------------------------------------------- |
| 조건문 제거      | 상태 전이에 따른 `if-else` 코드 제거         |
| 상태별 책임 분리 | 각 상태가 자체적으로 행동을 정의             |
| 확장성 ↑         | 새로운 상태 추가 시 기존 코드 수정 거의 없음 |

### ❌ 단점

| 단점           | 설명                                   |
| -------------- | -------------------------------------- |
| 클래스 수 증가 | 상태 수만큼 클래스 필요                |
| 복잡도 증가    | 단순 분기일 경우 과도한 구조일 수 있음 |

### ✅ 7. State vs Strategy vs Observer

| 패턴         | 목적                  | 차이점                                       |
| ------------ | --------------------- | -------------------------------------------- |
| **State**    | 상태에 따라 행동 변화 | 현재 객체 상태에 따라 내부적으로 동작이 바뀜 |
| **Strategy** | 알고리즘 선택         | 외부에서 전략을 주입함                       |
| **Observer** | 이벤트 알림           | 상태가 바뀌면 다른 객체에 통지               |

### 🧠 마무리 요약

| 항목          | 내용                                                       |
| ------------- | ---------------------------------------------------------- |
| **정의**      | 객체의 상태에 따라 동작을 변경하는 패턴. 상태를 클래스화함 |
| **핵심 구성** | `Context`, `State`, `ConcreteState`                        |
| **사용처**    | 결제 흐름, 상태 머신, 문서 처리, 게임 캐릭터               |
| **장점**      | if/switch 제거, 상태별 책임 분리, 확장 용이                |
| **단점**      | 클래스 수 증가, 단순한 로직에 과하면 오히려 복잡           |

## 3.9 Strategy (전략)

- **행위를 캡슐화하여** 동적으로 교체 가능
- 예: 정렬 방식 선택, 할인 정책 교체

### ✅ Strategy 패턴이란?

> **알고리즘(전략)을 객체로 캡슐화**하여,
>  런타임에 알고리즘을 **자유롭게 바꿀 수 있도록** 만드는 패턴

즉, **“행동을 클래스로 분리”**하고,
 **동적으로 선택 가능하도록 전략을 외부화**한 구조

### ✅ 1. 언제 사용하는가? (목적)

| 목적                 | 설명                                   |
| -------------------- | -------------------------------------- |
| 알고리즘 교체 유연화 | 동작 방식(전략)을 실행 중 바꿔야 할 때 |
| 코드 중복 제거       | 전략별 분기를 클래스화하여 중복 제거   |
| 조건문 제거          | if/switch 대신 전략 주입 방식으로 전환 |

### ✅ 2. 구조 (UML)

```
Client
    │
    ▼
  Context ─────────────→ Strategy (interface)
    │                         ▲
    ▼                         │
  doSomething()        ┌─────────────┐
                       │ConcreteStrategyA│
                       │ConcreteStrategyB│
                       └─────────────┘
```

| 구성 요소            | 설명                           |
| -------------------- | ------------------------------ |
| **Strategy**         | 알고리즘 인터페이스            |
| **ConcreteStrategy** | 구체적인 알고리즘 구현체       |
| **Context**          | 전략을 주입받고 실행하는 객체  |
| **Client**           | 전략을 선택해서 Context에 전달 |

### ✅ 3. Java 예제: 정렬 전략

#### 🔸 Strategy 인터페이스

```java
public interface SortStrategy {
    void sort(int[] arr);
}
```

#### 🔸 ConcreteStrategies

```java
import java.util.Arrays;

public class BubbleSort implements SortStrategy {
    public void sort(int[] arr) {
        System.out.println("버블 정렬 실행");
        // 실제 로직 생략
        Arrays.sort(arr); // 예시로 sort
    }
}

public class QuickSort implements SortStrategy {
    public void sort(int[] arr) {
        System.out.println("퀵 정렬 실행");
        Arrays.sort(arr); // 실제 로직 생략
    }
}
```

#### 🔸 Context

```java
public class Sorter {
    private SortStrategy strategy;

    public void setStrategy(SortStrategy strategy) {
        this.strategy = strategy;
    }

    public void sort(int[] arr) {
        strategy.sort(arr);
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        int[] data = {5, 3, 1, 4};

        Sorter sorter = new Sorter();

        sorter.setStrategy(new BubbleSort());
        sorter.sort(data); // 버블 정렬 실행

        sorter.setStrategy(new QuickSort());
        sorter.sort(data); // 퀵 정렬 실행
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Strategy:
    def sort(self, data): pass

class BubbleSort(Strategy):
    def sort(self, data):
        print("버블 정렬:", sorted(data))

class QuickSort(Strategy):
    def sort(self, data):
        print("퀵 정렬:", sorted(data))

class Sorter:
    def __init__(self, strategy): self.strategy = strategy
    def set_strategy(self, strategy): self.strategy = strategy
    def sort(self, data): self.strategy.sort(data)

# 사용
data = [4, 2, 1, 3]
s = Sorter(BubbleSort())
s.sort(data)

s.set_strategy(QuickSort())
s.sort(data)
```

### ✅ 5. 실무 활용 예

| 분야                     | 예시                                                     |
| ------------------------ | -------------------------------------------------------- |
| **정렬 알고리즘 선택**   | `Collections.sort()`에 Comparator 전달                   |
| **AI 행위 결정**         | 캐릭터 전략(공격/회피/도망 등) 주입                      |
| **암호화/압축 알고리즘** | 전략 객체를 통해 압축 방식 교체                          |
| **스프링**               | `PaymentStrategy`, `AuthenticationStrategy` 등 DI와 결합 |

### ✅ 6. 장점

| 장점               | 설명                               |
| ------------------ | ---------------------------------- |
| 알고리즘 교체 유연 | 실행 중 전략 바꿔도 문제 없음      |
| 조건문 제거        | 분기 없이 전략 객체로 대체         |
| OCP 원칙 준수      | 기존 코드 변경 없이 전략 추가 가능 |

### ❌ 단점

| 단점                          | 설명                                  |
| ----------------------------- | ------------------------------------- |
| 클래스 수 증가                | 전략마다 별도 클래스 필요             |
| 클라이언트가 전략을 알아야 함 | 적절한 전략을 선택/전달하는 책임 필요 |

### ✅ 7. Strategy vs State vs Template Method

| 패턴                | 목적                         | 주체               | 실행 시점   |
| ------------------- | ---------------------------- | ------------------ | ----------- |
| **Strategy**        | 알고리즘 교체                | 외부 주입          | 런타임      |
| **State**           | 상태별 행동 변화             | 내부에서 전환      | 런타임      |
| **Template Method** | 공통 로직 정의 + 일부만 변경 | 상속으로 구조 고정 | 컴파일 타임 |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 알고리즘(전략)을 객체로 분리하여 동적으로 교체할 수 있는 구조 |
| **핵심 구성** | `Strategy` 인터페이스 + `ConcreteStrategy` + `Context`       |
| **적용 예시** | 정렬, 검색, 행동 결정, 압축, 인증 등                         |
| **장점**      | 전략 변경 유연, 코드 확장성↑, 조건문 제거                    |
| **단점**      | 전략 관리 책임, 클래스 증가                                  |

## 3.10 Template Method (템플릿 메서드)

- 알고리즘 구조는 고정하고, 세부 단계는 서브클래스에서 정의
- `execute()` 안에서 `doStep1()`, `doStep2()` 호출

### ✅ Template Method 패턴이란?

> **알고리즘의 뼈대(템플릿)를 상위 클래스에 정의하고**,
>  세부적인 처리는 하위 클래스에서 구현하도록 하는 디자인 패턴.

즉, **"공통 알고리즘은 고정하고, 일부 단계만 오버라이드"** 하도록 만드는 구조야.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                     | 설명                                                 |
| ------------------------ | ---------------------------------------------------- |
| 알고리즘의 구조를 재사용 | 전체 구조는 고정, 일부만 유연하게 오버라이딩         |
| 코드 중복 제거           | 반복되는 흐름은 부모 클래스에 두고, 변화 부분만 분리 |
| 후킹(hook) 제공          | 선택적으로 오버라이드 가능한 메서드 구조 제공        |

### ✅ 2. 구조 (UML)

```
         ┌────────────────────┐
         │  AbstractClass     │
         ├────────────────────┤
         │ templateMethod()   │ ← 고정된 알고리즘 순서
         │ + step1()          │
         │ + step2()          │
         └──────┬─────────────┘
                ▼
         ┌────────────────────┐
         │  ConcreteClass     │ ← 세부 단계 구현
         └────────────────────┘
```

| 구성요소          | 설명                                           |
| ----------------- | ---------------------------------------------- |
| **AbstractClass** | 알고리즘 뼈대(템플릿 메서드) 정의              |
| **ConcreteClass** | 실제 알고리즘 단계 구현                        |
| **hook method**   | 기본 구현을 제공하지만 필요 시 오버라이드 가능 |

### ✅ 3. Java 예제: 커피/차 만드는 과정

#### 🔸 AbstractClass

```java
public abstract class CaffeineBeverage {
    // 템플릿 메서드 (final로 고정)
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    abstract void brew();
    abstract void addCondiments();

    void boilWater() {
        System.out.println("물 끓이는 중");
    }

    void pourInCup() {
        System.out.println("컵에 따르는 중");
    }

    // Hook method (선택 구현)
    boolean customerWantsCondiments() {
        return true;
    }
}
```

#### 🔸 ConcreteClass

```java
public class Tea extends CaffeineBeverage {
    void brew() {
        System.out.println("찻잎을 우려내는 중");
    }

    void addCondiments() {
        System.out.println("레몬 추가");
    }
}

public class Coffee extends CaffeineBeverage {
    void brew() {
        System.out.println("커피를 내리는 중");
    }

    void addCondiments() {
        System.out.println("설탕과 우유 추가");
    }

    @Override
    boolean customerWantsCondiments() {
        return false; // 사용자 요청에 따라 생략
    }
}
```

#### 🔸 Client

```java
public class Client {
    public static void main(String[] args) {
        CaffeineBeverage tea = new Tea();
        tea.prepareRecipe();

        CaffeineBeverage coffee = new Coffee();
        coffee.prepareRecipe();
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class CaffeineBeverage:
    def prepare_recipe(self):
        self.boil_water()
        self.brew()
        self.pour_in_cup()
        if self.customer_wants_condiments():
            self.add_condiments()

    def boil_water(self):
        print("물 끓이는 중")

    def pour_in_cup(self):
        print("컵에 따르는 중")

    def customer_wants_condiments(self):
        return True  # hook method

    def brew(self): pass
    def add_condiments(self): pass

class Tea(CaffeineBeverage):
    def brew(self): print("찻잎 우림")
    def add_condiments(self): print("레몬 추가")

class Coffee(CaffeineBeverage):
    def brew(self): print("커피 추출")
    def add_condiments(self): print("설탕, 우유 추가")
    def customer_wants_condiments(self): return False

# 사용
Tea().prepare_recipe()
Coffee().prepare_recipe()
```

### ✅ 5. 실무 활용 예

| 분야                     | 예시                                                         |
| ------------------------ | ------------------------------------------------------------ |
| **프레임워크 구조 제어** | Spring `AbstractController`, `JdbcTemplate`                  |
| **테스트 케이스**        | JUnit `setUp()`, `tearDown()`                                |
| **게임 루프 엔진**       | `initialize() → update() → render()` 구조 고정               |
| **빌더 템플릿**          | `buildHeader() → buildBody() → buildFooter()` 등 UI 구조 고정 |

### ✅ 6. 장점

| 장점                 | 설명                                |
| -------------------- | ----------------------------------- |
| 알고리즘 구조 재사용 | 코드 중복 최소화, 유지 보수 용이    |
| 확장성 ↑             | 서브클래스에서 원하는 부분만 재정의 |
| 후킹 기능            | 선택적 커스터마이징 가능            |

### ❌ 단점

| 단점                    | 설명                                            |
| ----------------------- | ----------------------------------------------- |
| 상속 강제               | 서브클래스 사용이 강제됨 (조합 불가능)          |
| 클래스 수 증가          | 변형이 많을 경우 클래스를 많이 만들어야 함      |
| 런타임 동적 변경 어려움 | 실행 중 전략을 바꾸려면 구조 자체를 변경해야 함 |

### ✅ 7. Template Method vs Strategy vs State

| 패턴                | 목적                               | 차이점                                     |
| ------------------- | ---------------------------------- | ------------------------------------------ |
| **Template Method** | 알고리즘의 구조 고정 + 단계만 변경 | **상속 기반**, 알고리즘 흐름 고정          |
| **Strategy**        | 알고리즘 교체                      | **조합(Composition)** 기반, 동적 변경 가능 |
| **State**           | 상태에 따라 행동 변화              | 상태 객체 내부에서 전환이 발생             |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 알고리즘의 전체 구조(템플릿)를 상위 클래스에 정의하고, 일부 단계만 서브클래스가 구현 |
| **핵심 구성** | `templateMethod()` + `abstract step()` + (선택적) `hook()`   |
| **적용 예시** | 프레임워크 설계, 게임 루프, 알고리즘 구조 재사용             |
| **장점**      | 중복 제거, 재사용 가능, 후킹 기능                            |
| **단점**      | 상속 강제, 전략 교체 어려움, 클래스 증가                     |

## 3.11 Visitor (방문자)

- **구조와 행위 분리**, 요소 구조는 그대로 두고 행위만 추가
- 예: 문서 검증기, HTML 렌더러

### ✅ Visitor 패턴이란?

> 객체 구조(예: 트리, 그래프 등)를 변경하지 않고도
>  **새로운 연산(기능)을 추가**할 수 있게 해주는 패턴.
>  즉, **연산(행동)을 객체에서 분리하여 방문자 객체에 위임**하는 방식.

### ✅ 1. 언제 사용하는가? (목적)

| 목적                             | 설명                                             |
| -------------------------------- | ------------------------------------------------ |
| 구조는 고정, 행동만 유동         | 기존 클래스 수정 없이 새로운 기능을 추가         |
| 연산 분리                        | 자료 구조와 연산을 완전히 분리                   |
| 다중 분산 (Double Dispatch) 구현 | 객체 타입 + 방문자 타입 둘 다 기준으로 동작 선택 |

### ✅ 2. 구조 (UML)

```
             ┌────────────┐
             │  Visitor   │◄────────────┐
             └────┬───────┘             │
                  ▼                    ▼
       ┌────────────────┐     ┌────────────────────┐
       │ ConcreteVisitor │     │     Element         │
       └────────────────┘     └────────┬────────────┘
                                       ▼
                               ┌──────────────┐
                               │ConcreteElement│
                               └──────────────┘
```

| 구성 요소           | 설명                                          |
| ------------------- | --------------------------------------------- |
| **Visitor**         | 수행할 연산의 인터페이스 (visitXXX 메서드들)  |
| **ConcreteVisitor** | 실제 연산 구현                                |
| **Element**         | 방문자를 받아들이는 인터페이스 (`accept()`)   |
| **ConcreteElement** | 연산을 받아들이고, `visitor.visit(this)` 호출 |

### ✅ 3. Java 예제: 도형 렌더링 + 면적 계산

#### 🔸 Element 인터페이스

```java
public interface Shape {
    void accept(Visitor visitor);
}
```

#### 🔸 ConcreteElement 클래스들

```java
public class Circle implements Shape {
    public double radius = 3.0;

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}

public class Rectangle implements Shape {
    public double width = 5.0;
    public double height = 2.0;

    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
```

#### 🔸 Visitor 인터페이스

```java
public interface Visitor {
    void visit(Circle c);
    void visit(Rectangle r);
}
```

#### 🔸 ConcreteVisitor 구현

```java
public class AreaCalculator implements Visitor {
    public void visit(Circle c) {
        System.out.println("원의 면적: " + (Math.PI * c.radius * c.radius));
    }

    public void visit(Rectangle r) {
        System.out.println("사각형 면적: " + (r.width * r.height));
    }
}

public class ShapeRenderer implements Visitor {
    public void visit(Circle c) {
        System.out.println("원을 그립니다.");
    }

    public void visit(Rectangle r) {
        System.out.println("사각형을 그립니다.");
    }
}
```

#### 🔸 Client 코드

```java
public class Client {
    public static void main(String[] args) {
        Shape[] shapes = { new Circle(), new Rectangle() };

        Visitor areaVisitor = new AreaCalculator();
        Visitor renderVisitor = new ShapeRenderer();

        for (Shape s : shapes) {
            s.accept(areaVisitor);   // 면적 계산
            s.accept(renderVisitor); // 그리기
        }
    }
}
```

### ✅ 4. Python 예시 (간단)

```python
class Visitor:
    def visit_circle(self, c): pass
    def visit_rectangle(self, r): pass

class Shape:
    def accept(self, visitor): pass

class Circle(Shape):
    def __init__(self): self.radius = 3
    def accept(self, visitor): visitor.visit_circle(self)

class Rectangle(Shape):
    def __init__(self): self.width = 5; self.height = 2
    def accept(self, visitor): visitor.visit_rectangle(self)

class AreaVisitor(Visitor):
    def visit_circle(self, c):
        print("원의 면적:", 3.14 * c.radius ** 2)

    def visit_rectangle(self, r):
        print("사각형 면적:", r.width * r.height)

shapes = [Circle(), Rectangle()]
for s in shapes:
    s.accept(AreaVisitor())
```

### ✅ 5. 실무 활용 예

| 분야            | 예시                                        |
| --------------- | ------------------------------------------- |
| **컴파일러**    | AST 노드를 방문하여 해석, 최적화, 코드 생성 |
| **파일 시스템** | 디렉터리/파일 구조 순회하며 동작 수행       |
| **UI 구성요소** | 각 컴포넌트를 방문하며 렌더링, 이벤트 적용  |
| **통계 수집기** | 객체를 방문하며 데이터 추출, 요약           |

### ✅ 6. 장점

| 장점                      | 설명                                                 |
| ------------------------- | ---------------------------------------------------- |
| 기능 추가 용이            | 기존 구조 변경 없이 새로운 연산 추가 가능 (OCP 만족) |
| 구조-행동 분리            | 데이터와 로직을 완전히 분리하여 관리                 |
| 복잡한 구조에도 적용 가능 | 트리, 그래프, 복합 구조에 유용                       |

### ❌ 단점

| 단점                                | 설명                                                      |
| ----------------------------------- | --------------------------------------------------------- |
| Element 수정 시 Visitor도 수정 필요 | 구조 변경이 생기면 모든 Visitor에 영향                    |
| 방문 메서드 폭발 가능성             | 각 Element마다 `visitXXX()`가 필요 → 인터페이스 증가      |
| 다형성 저하                         | 런타임 동적 다형성보다 타입 분기를 명시적으로 작성해야 함 |

### 🧠 마무리 요약

| 항목          | 내용                                                         |
| ------------- | ------------------------------------------------------------ |
| **정의**      | 객체 구조는 그대로 두고, 새로운 연산을 **방문자 객체에 위임**하는 패턴 |
| **핵심 구성** | `Element.accept(Visitor)`, `Visitor.visit(Element)`          |
| **적용 사례** | AST 해석기, 도형 렌더링, 구조 순회 처리                      |
| **장점**      | 기능 확장 용이, 구조와 동작 분리, 유지보수성 ↑               |
| **단점**      | Element 변경 시 Visitor 전부 수정, 방문 메서드 과다 가능성   |